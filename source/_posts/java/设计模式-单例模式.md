---
title: 单例模式
url: Singleton_Pattern
tags:
  - 设计模式
categories:
  - 设计模式
date: 2019-02-15 00:15:02
---

# 什么是单例模式？
单例模式算是设计模式入门的最简单的一个模式, 由于 `Java` 语言的特性(指令重排序), 导致同时也是最难的一个模式。

所幸, 先驱者`Joshua Bloch`在`Google I/O 2008`上的新书`Effective Java`介绍了单例模式的最佳实践。这本神书我还没来的及看, 但在国外好像备受推崇, 所以有机会还是看看。
<!-- more -->

一个`android`应用程序的一个单例模式的类只能有且只有一个实例对象。
通俗的讲，就是构造方法私有化，并在类内创建唯一一个私有的类实例,提供一个用于获取唯一实例的公有方法。
```java
public class A {
    private static A instance;  //创建唯一一个私有实例
    private A() {}              //私有化构造函数
    public static A getInstance() {
        instance = new A(); //初始化
        return instance;    //返回唯一实例
    }
}
```

**单例模式分为以下两种类型**
1. 饿汉模式：类**加载**的时候便进行创建（加载类时较慢，运行时获取对象较快，线程安全）
1. 懒汉模式：要**使用**的时候才进行创建（加载类时较快，运行时获取对象较慢，线程不安全）

# 饿汉模式
## 在Java 5 之前的最佳实践
直接在声明的时候初始化, 当类加载时, `instance = new A()`就会执行.
```java
public class A {
    private static A instance = new A(); //注意这里初始化的时机
    private A() {}                       //私有化构造函数
    public static A getInstance() {
        return instance;                 //返回唯一实例
    }
}
```

## Java 5 之后的最佳实践
` enum ` 作为枚举关键字, 很难想像到它和 `单例模式` 联系到一起。
但是换种思路, 枚举类只有一个元素, 不就是单例模式了吗?
枚举类还可以添加自定义的方法。完全可以当成一个类来使用。
```java
public enum A {
    INSTANCE;
    public static A getInstance() { return INSTANCE; }
}
```

# 懒汉模式
>要使用的时候才进行创建

## 静态内部类 (在Java 5 之前的最佳实践)
因为`Holder`是静态内部类, 只有`getInstance()`方法访问到`Holder`, 才会初始化静态内部类的`static`的变量.
```java
public class A {  
    private static class Holder {  
        private static final A instance = new A();  
    }  
    private A (){}  
    public static final A getInstance() {  
        return Holder.instance; 
    }  
}
```

## 双重锁+volatile (在Java 5 之后的最佳实践)
### 双重锁的优化
上面提到，懒汉式是线程不安全的，对于多线程比较陌生的可能不太理解，先看代码
```java
public class A {
    private static A instance;
    private A() {}
    public static A getInstance() {
        if(instance == null) {// 一
            instance = new A();// 二
        }
        return instance;// 三
    }
}
```
当我们获取调用`getInstance()`方法获取`A`的实例对象时，如果有多个线程调用`getInstance()方法`，就会出现线程不安全，怎么解释呢？

假设有两个线程同时调用了`getInstance()`方法.
1. 当线程1执行到`if(instance == null)`时, 判断为`true`, 进入`if`内, 此时线程1时间片结束, `CPU`切换到线程2.
1. 此时线程2执行到`if(instance == null)`, 因为线程1还未来得及执行`instance = A()`, 所以`if`判断为`true`, 进入方法体, 此时线程2时间片结束, `CPU`切换到线程1.
1. 此时线程1执行`instance = A()`, `instance`的`hashcode`为`850`, 然后`return`, 执行结束, 切换回线程2.
1. 此时线程2在`if`内, 执行`instance = A()`, `instance`的`hashcode`为`851`, 然后`return`.

看到了吗? 这样就创建了两个`A`的实例. 说好的单例模式呢?

那么改一下, 加上`synchronized`同步一下.
```java
public class A{
    private static A instance;
    private A() {}
    public static A getInstance() {
        if(instance == null) {          // 一
            synchronized (A.class) {    // 二
                if(instance == null) {  // 三
                    instance = new A(); // 四
                }
            }
        }
        return instance; // 五
    }
}
```
假设有两个线程同时调用了`getInstance()`方法.
1. 当线程1执行到`if(instance == null)`时, 判断为`true`, 进入`if`内, 此时线程1时间片结束, `CPU`切换到线程2.
1. 此时线程2执行到`if(instance == null)`, 因为线程1还未来得及执行`instance = A()`, 所以`if`判断为`true`, 进入方法体, 此时线程2时间片结束, `CPU`切换到线程1.
1. 线程1拿到`A.class`锁, 进入`synchronized`, 此时就算切换回线程2, 线程2也会因为拿不到`A.class`锁对象, 阻塞在同步代码块外面.
1. 线程1继续执行`if`, 执行`instance = A()`, `instance`的`hashcode`为`850`, 然后`return`, 执行结束, 切换回线程2.
1. 此时线程2拿到`A.class`锁, 进入`synchronized`, `if`判断为`false`, 直接`return`.

> 为什么不把第一个`if`去掉, 直接留个`synchronized + if`呢?
> 因为`synchronized`耗时长, 消耗性能, 双重锁只要保证第一次并发不产生多个对象即可.

你以为这样就线程安全了吗! `Java`还有个**指令重排序**的大招等着你呢.

### volatile 优化
`volatile`关键字用来解决指令重排序在多线程下的问题, 它有两个功能.
1. 保证内存可见性
2. 防止指令重排序

我们先看内存可见性(其实这已经被`synchronized`解决了)
`Java`内存模型规定, 变量存储在主存中, 每个线程拥有该变量的一个拷贝副本在自己的工作内存中, 线程修改变量是修改自己工作内存中的变量, 而修改完毕后, 会将自己工作内存中的修改后的值回写到主存中.
```java
public class A {
    private static A instance;
    private A() {}
    public static A getInstance() {
        if(instance == null) {          // 一
            synchronized (A.class) {    // 二
                if(instance == null) {  // 三
                    instance = new A(); // 四
                }
            }
        }
        return instance; // 五
    }
}
```
假设有两个线程同时调用了`getInstance()`方法.
1. 当线程1执行到`if(instance == null)`时, 判断为`true`, 进入`if`内, 拿到`A.class`锁, 进入`synchronized`, 继续执行`if`, 执行`instance = A()`, `instance`的`hashcode`为`850`, **此时`instance`没有回写到主存**, 切换回线程2.
1. 线程2执行到第一个`if`, 因为线程1的值没有回写到主存, 所以还是会进入`if`内, 但是被`synchronized`阻塞了.
1. 线程1将变量回写到主存, 并`return`.
1. 此时线程2拿到`A.class`锁, 进入`synchronized`, `if`判断为`false`, 直接`return`.
所以就算没有使用`volatile`保证内存可见性, 也不会导致出错.
其实`synchronized`就有保证内存可见性的功能.
> 在 [java.util.concurrent.locks.Lock](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Lock.html) 接口的Javadoc中有这样一段话：
> All Lock implementations must enforce the **same memory synchronization semantics as provided by the built-in monitor lock**

再来看指令重排序
`instance = A();` 这条命令并不是原子性的, 它包含3个操作.
1. 在堆内存申请`A`实例的内存空间.
2. 初始化`A`实例.
3. 将`instance`变量指向内存中的`A`实例的内存空间(执行完这步 `instance` 就为非 `null` 了)
由于`JVM`的指令重排序, 步骤`123`可能会变成`132`, 多线程下会导致出错.

假设有两个线程同时调用了`getInstance()`方法. 指令顺序为`132`.
1. 当线程1执行到`if(instance == null)`时, 判断为`true`, 进入`if`内, 拿到`A.class`锁, 进入`synchronized`, 继续执行`if`, 执行`instance = A()`.
1. 先在堆内存申请`A`实例的内存空间, 由于指令重排序, 将`instance`变量指向没有初始化的, 但是已经申请了的内存空间. 此时线程1时间片结束, CPU切换到线程2.
1. 线程2执行到第一个`if`, 因为`instance`已经指向没有初始化的内存空间, 所以直接`return`. 这时调用这个单例, 因为还未初始化, 所以会导致错误出现.

而`volatile`可以防止指令重排序, 让指令严格按照`123`的顺序执行.
**但是, 在`Java 5`之前, 因为`Java`内存模型的缺陷, `volatile`不能解决指令重排序的问题.**
所以最佳实践就是
```java
public class A {
    private volatile static A instance;
    private A() {}
    public static A getInstance() {
        if(instance == null) {
            synchronized (A.class) {
                if(instance == null) {
                    instance = new A();
                }
            }
        }
        return instance;
    }
}
```

# 破坏单例模式的攻击
## 克隆 clone 攻击
要用`clone`攻击单例模式只需要两步.
1. `A`类实现`Cloneable`接口, 虽然里面啥也没有, 主要时为了解决`CloneNotSupportedException`.
2. 重写`Object`中的`protected native Object clone()`方法, 不然外部访问不了.
然后运行`main`方法, `a1==a2`得到`false`.
```java
public class A implements Cloneable {
    private volatile static A instance;
    private A() {}
    public static A getInstance() {
        if(instance == null) {
            synchronized (A.class) {
                if(instance == null) {
                    instance = new A();
                }
            }
        }
        return instance;
    }
    
    public Object clone() throws CloneNotSupportedException {
        return (A) super.clone();
    }
}

public class Main {
    public static void main(String[] args) throws Exception {
        A a1 = A.getInstance();
        A a2 = (A) a1.clone();
        System.out.println(a1 == a2); // false
    }
}
```
要解决`clone`攻击也很简单, 既然是`clone`方法的问题, 那我们就直接在`clone`方法改动即可.
```java
public class A implements Cloneable {
    public Object clone() throws CloneNotSupportedException {
        return getInstance();
    }
}
```

## 反射攻击
用`constructor.setAccessible(true);`破解私有构造函数.
```java
public class A {
    private volatile static A instance;
    private A() {}
    public static A getInstance() {
        if(instance == null) {
            synchronized (A.class) {
                if(instance == null) {
                    instance = new A();
                }
            }
        }
        return instance;
    }
}

public class Main {
    public static void main(String[] args) throws Exception {
        A a1 = A.getInstance();
        A a2 = create(A.class);
        System.out.println(a1 == a2); // false
    }

    public static <T> T create(Class<T> clazz) {
        try {
            Constructor<T> constructor = clazz.getDeclaredConstructor();
            constructor.setAccessible(true);
            return constructor.newInstance();
        } catch (InstantiationException | InvocationTargetException | NoSuchMethodException | IllegalAccessException e) {
            e.printStackTrace();
        }
        return null;
    }
}
```
那我们只能在构造函数体做文章了.
判断如果被初始化过了, 再次初始化则抛出异常即可.
```java
public class A {
    private static A instance;  //创建唯一一个私有实例
    private A() {               //私有化构造函数
        if(instance != null) {  //避免反射创建
            throw new IllegalStateException("单例模式不允许再创建");
        }
    }
    public static A getInstance() {
        instance = new A(); //初始化
        return instance;    //返回唯一实例
    }
}
```

## 序列化攻击
只要对`A`类实现`Serializable`接口, 即可进行对象序列化.
```java
public class A implements Serializable {
    private volatile static A instance;
    private A() {}
    public static A getInstance() {
        if(instance == null) {
            synchronized (A.class) {
                if(instance == null) {
                    instance = new A();
                }
            }
        }
        return instance;
    }
}
public class Main {
    public static void main(String[] args) throws Exception {
        File file = new File("serializable.txt");
        A a1 = A.getInstance();
        // 1. 序列化
        try (FileOutputStream fos = new FileOutputStream(file);
             ObjectOutputStream oos = new ObjectOutputStream(fos);) {
            oos.writeObject(a1);
            oos.flush();
        }
        // 2. 反序列化
        try (FileInputStream fis = new FileInputStream(file);
             ObjectInputStream ois = new ObjectInputStream(fis);) {
            A a2 = (A) ois.readObject();
            System.out.println(a1 == a2); // false
        }
    }
}
```
要化解序列化攻击, 很简单, 我们先看`ois.readObject()`这个方法.
![readObject调用链](https://yuml.me/diagram/nofunky/class/[readObject]->[readObject0],[readObject0]->[readOrdinaryObject])
最终调用的是`readOrdinaryObject`方法.
```java
public class ObjectInputStream extends InputStream implements ObjectInput, ObjectStreamConstants {
    private Object readOrdinaryObject(boolean unshared) throws IOException {
        // 省略部分代码
        ObjectStreamClass desc = readClassDesc(false);
        desc.checkDeserialize();
        // 省略部分代码
        Object obj;
        try {
            // =============== !!注意这里!! ===============
            obj = desc.isInstantiable() ? desc.newInstance() : null;
            // =============== !!注意这里!! ===============
        } catch (Exception ex) {
            throw (IOException) new InvalidClassException(desc.forClass().getName(), "unable to create instance").initCause(ex);
        }

        if (obj != null && handles.lookupException(passHandle) == null &&
            desc.hasReadResolveMethod()) { // 注意这里, false
            // 省略部分代码
        }

        return obj;
    }
}
```
我们可以看到`desc.isInstantiable()`返回`true`之后, 反序列化会通过反射创建一个新的对象.
看下`isInstantiable()`的文档.
> Returns true if represented class is serializable/externalizable and can be instantiated by the serialization runtime--i.e., if it is externalizable and defines a public no-arg constructor, or if it is non-externalizable and its first non-serializable superclass defines an accessible no-arg constructor.  Otherwise, returns false.

也就是说, 满足以下两种情况任意一种, 则返回`true`
1. 类实现了`Externalizable`接口, 并定义了一个无参构造器
2. 类没有实现`Externalizable`接口, 它的第一个非`Serializable`父类(如`Object`)定义了一个无参构造器.

我们继续往下看, 根据方法名, 如果`A`类实现了`readResolve`方法, 就会调用`readResolve`方法, 并返回出去.
```java
public class ObjectInputStream extends InputStream implements ObjectInput, ObjectStreamConstants {
    private Object readOrdinaryObject(boolean unshared) throws IOException {
        Object obj;
        // 省略部分代码
        if (obj != null && handles.lookupException(passHandle) == null &&
            desc.hasReadResolveMethod()) { // 注意这里, true
            Object rep = desc.invokeReadResolve(obj);
            // 省略部分代码
            if (rep != obj) {
                // 省略部分代码
                obj = rep;
                // 省略部分代码
            }
        }

        return obj;
    }
}
```
所以, 要化解序列化攻击, 只需要写一个`readResolve`方法.
```java
public class A implements Serializable {
    private Object readResolve() {
        return getInstance();
    }
}
```

# 究极无敌完全进化完美精华牛逼上天单例模式懒汉版
```java
public class A implements Serializable, Cloneable {
    private volatile static A instance;
    private A() {
        if(instance != null) {  // 化解反射攻击
            throw new IllegalStateException("单例模式不允许再创建");
        }
    }

    /**
     * 双重锁保证线程安全
     */
    public static A getInstance() {
        if(instance == null) {
            synchronized (A.class) {
                if(instance == null) {
                    instance = new A();
                }
            }
        }
        return instance;
    }

    /**
     * 化解克隆攻击
     */
    public Object clone() throws CloneNotSupportedException {
        return getInstance();
    }

    /**
     * 化解序列化攻击
     */
    private Object readResolve() {
        return getInstance();
    }
}
```

# 参考资料
- [What is an efficient way to implement a singleton pattern in Java?](https://stackoverflow.com/questions/70689)
- [Double Checked Locking is Broken](http://kanlei.github.io/design%20pattern/2017/04/16/double-checked-locking-is-broken)
- [如何正确地写出单例模式](http://www.importnew.com/21141.html)
- [Java锁是如何保证数据可见性的](http://ifeve.com/java%E9%94%81%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84/)