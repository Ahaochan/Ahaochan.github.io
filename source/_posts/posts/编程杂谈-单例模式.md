---
title: 单例模式
url: Singleton_Pattern
tags:
  - 设计模式
categories:
  - 编程杂谈
date: 2016-07-21 09:03:02
---

# 什么是单例模式？
现在有一个需求，公司接了个项目，那这个项目肯定要有一个负责人，那么钦定了负责人之后，肯定不允许再出现第二个负责人了，不然员工听哪个负责人的？
<!-- more -->

一个`android`应用程序的一个单例模式的类只能有且只有一个实例对象。
通俗的讲，就是构造方法私有化，并在类内创建唯一一个私有的类实例,提供一个用于获取唯一实例的公有方法。
```java
public class A{
    private static A instance;//创建唯一一个私有实例
    private A(){}//私有化构造函数
    public static A getInstance(){
        instance = new A();//初始化
        return instance;//返回唯一实例
    }
}
```

**单例模式分为以下两种类型**
1. 饿汉模式：类**加载**的时候便进行创建（加载类时较慢，运行时获取对象较快，线程安全）
1. 懒汉模式：要**使用**的时候才进行创建（加载类时较快，运行时获取对象较慢，线程不安全）

## 饿汉模式
>饿汉模式：类加载的时候便进行了创建（占资源）

```java
public class A{
    private static A instance = new A();//注意这里初始化的时机
    private A(){}//私有化构造函数
    public static A getInstance(){
        return instance;//返回唯一实例
    }
}
```

## 懒汉模式
>要使用的时候才进行创建

```java
public class A{
    private static A instance;//创建唯一一个私有实例
    private A(){}//私有化构造函数
    public static A getInstance(){
        if(instance==null){
            instance = new A();//初始化
        }
        return instance;//返回唯一实例
    }
}
```

# 多线程下的优化
上面提到，懒汉式是线程不安全的，对于多线程比较陌生的可能不太理解，先看代码
```java
public class A{
    private static A instance;
    private A(){}
    public static A getInstance(){
        if(instance==null){//①
            instance = new A();//②
        }
        return instance;//③
    }
}
```
当我们获取调用`getInstance()`方法获取`A`的实例对象时，如果有多个线程调用`getInstance()方法`，就会出现线程不安全，怎么解释呢？
比如说，线程Ⅰ执行`getInstance()`，判断①为true，即`instance`为`null`。
这时，线程Ⅰ因为某种未知的原因卡住了不能执行②，而线程Ⅱ也开始执行`getInstance()`，同样判断①为true。
即`instance`为`null`，因为线程Ⅰ还没执行②，然后线程Ⅱ执行③，返回了一个实例对象。
这时，线程Ⅰ启动了，执行了②③，返回了一个实例对象。
结果是`getInstance()` 方法创建了两个`A`对象，而它本该只创建一个对象。

## 最优方案
多线程同步的问题自然是想到了用同步锁
```java
public class A{
    private static A instance;
    private A(){}
    public static A getInstance(){
        if(instance==null){//①
            sychronized(A.class) {//②
                if(instance==null){//③
                    instance = new A();//④
                }
            }
        }
        return instance;//⑤
    }
}
```
并不是简单加个`sychronized`就完事了，注意两个`if`语句，这叫双重检查锁。
当多个线程同时进入第一个if语句的时候。因为同步锁，所以肯定只有线程Ⅰ（不按先后排序）进去执行④。
当线程Ⅰ退出同步锁且还没执行⑤的时候，线程Ⅱ进入同步块，因为已经有实例对象了，所以线程Ⅱ执行③为`false`，直接退出同步锁。

## JVM指令重排序带来的弊端(2017/5/31更新)
> 参考资料: 
> [Double Checked Locking is Broken](http://kanlei.github.io/design%20pattern/2017/04/16/double-checked-locking-is-broken)
> [如何正确地写出单例模式](http://www.importnew.com/21141.html)

在上面代码中的`instance = new A();`这条代码做了三件事。
1. 给 `A` 分配内存
1. 调用 `A` 的构造函数来初始化成员变量
1. 将`instance`对象指向分配的内存空间（执行完这步 `instance` 就为非 `null` 了）

Java指令重排序会打乱这一执行顺序，造成`132`或者`123`的执行顺序，如果线程一执行了`13`，这时候instance不为null，这时候线程二使用instance就会出错。

解决方案：
1. 在jdk5之后，Java使用了新的内存模型，使用`volatile`修饰instance，禁止指令重排序。
1. 饿汉式解决，使用`static final field`修饰instance。
