---
title: 单例模式
url: Singleton_Pattern
tags:
  - 设计模式
categories:
  - 设计模式
date: 2019-02-15 00:15:02
---

# 什么是单例模式？
单例模式算是设计模式入门的最简单的一个模式, 由于 `Java` 语言的特性(指令重排序), 导致同时也是最难的一个模式。

所幸, 先驱者`Joshua Bloch`在`Google I/O 2008`上的新书`Effective Java`介绍了单例模式的最佳实践。这本神书我还没来的及看, 但在国外好像备受推崇, 所以有机会还是看看。
<!-- more -->

一个`android`应用程序的一个单例模式的类只能有且只有一个实例对象。
通俗的讲，就是构造方法私有化，并在类内创建唯一一个私有的类实例,提供一个用于获取唯一实例的公有方法。
```java
public class A {
    private static A instance;  //创建唯一一个私有实例
    private A() {}              //私有化构造函数
    public static A getInstance() {
        instance = new A(); //初始化
        return instance;    //返回唯一实例
    }
}
```

**单例模式分为以下两种类型**
1. 饿汉模式：类**加载**的时候便进行创建（加载类时较慢，运行时获取对象较快，线程安全）
1. 懒汉模式：要**使用**的时候才进行创建（加载类时较快，运行时获取对象较慢，线程不安全）

# 饿汉模式
## 在Java 5 之前的最佳实践
直接在声明的时候初始化, 当类加载时, `instance = new A()`就会执行.
```java
public class A {
    private static A instance = new A(); //注意这里初始化的时机
    private A() {}                       //私有化构造函数
    public static A getInstance() {
        return instance;                 //返回唯一实例
    }
}
```

## Java 5 之后的最佳实践
` enum ` 作为枚举关键字, 很难想像到它和 `单例模式` 联系到一起。
但是换种思路, 枚举类只有一个元素, 不就是单例模式了吗?
枚举类还可以添加自定义的方法。完全可以当成一个类来使用。
```java
public enum A {
    INSTANCE;
    public static A getInstance() { return INSTANCE; }
}
```

# 懒汉模式
>要使用的时候才进行创建

## 静态内部类 (在Java 5 之前的最佳实践)
因为`Holder`是静态内部类, 只有`getInstance()`方法访问到`Holder`, 才会初始化静态内部类的`static`的变量.
```java
public class A {  
    private static class Holder {  
        private static final A instance = new A();  
    }  
    private A (){}  
    public static final A getInstance() {  
        return Holder.instance; 
    }  
}
```

## 双重锁+volatile (在Java 5 之后的最佳实践)
### 双重锁的优化
上面提到，懒汉式是线程不安全的，对于多线程比较陌生的可能不太理解，先看代码
```java
public class A {
    private static A instance;
    private A() {}
    public static A getInstance() {
        if(instance == null) {// 一
            instance = new A();// 二
        }
        return instance;// 三
    }
}
```
当我们获取调用`getInstance()`方法获取`A`的实例对象时，如果有多个线程调用`getInstance()方法`，就会出现线程不安全，怎么解释呢？

假设有两个线程同时调用了`getInstance()`方法.
1. 当线程1执行到`if(instance == null)`时, 判断为`true`, 进入`if`内, 此时线程1时间片结束, `CPU`切换到线程2.
1. 此时线程2执行到`if(instance == null)`, 因为线程1还未来得及执行`instance = A()`, 所以`if`判断为`true`, 进入方法体, 此时线程2时间片结束, `CPU`切换到线程1.
1. 此时线程1执行`instance = A()`, `instance`的`hashcode`为`850`, 然后`return`, 执行结束, 切换回线程2.
1. 此时线程2在`if`内, 执行`instance = A()`, `instance`的`hashcode`为`851`, 然后`return`.

看到了吗? 这样就创建了两个`A`的实例. 说好的单例模式呢?

那么改一下, 加上`synchronized`同步一下.
```java
public class A{
    private static A instance;
    private A() {}
    public static A getInstance() {
        if(instance == null) {          // 一
            synchronized (A.class) {    // 二
                if(instance == null) {  // 三
                    instance = new A(); // 四
                }
            }
        }
        return instance; // 五
    }
}
```
假设有两个线程同时调用了`getInstance()`方法.
1. 当线程1执行到`if(instance == null)`时, 判断为`true`, 进入`if`内, 此时线程1时间片结束, `CPU`切换到线程2.
1. 此时线程2执行到`if(instance == null)`, 因为线程1还未来得及执行`instance = A()`, 所以`if`判断为`true`, 进入方法体, 此时线程2时间片结束, `CPU`切换到线程1.
1. 线程1拿到`A.class`锁, 进入`synchronized`, 此时就算切换回线程2, 线程2也会因为拿不到`A.class`锁对象, 阻塞在同步代码块外面.
1. 线程1继续执行`if`, 执行`instance = A()`, `instance`的`hashcode`为`850`, 然后`return`, 执行结束, 切换回线程2.
1. 此时线程2拿到`A.class`锁, 进入`synchronized`, `if`判断为`false`, 直接`return`.

> 为什么不把第一个`if`去掉, 直接留个`synchronized + if`呢?
> 因为`synchronized`耗时长, 消耗性能, 双重锁只要保证第一次并发不产生多个对象即可.

你以为这样就线程安全了吗! `Java`还有个**指令重排序**的大招等着你呢.

### volatile 优化
`volatile`关键字用来解决指令重排序在多线程下的问题, 它有两个功能.
1. 保证内存可见性
2. 防止指令重排序

我们先看内存可见性(其实这已经被`synchronized`解决了)
`Java`内存模型规定, 变量存储在主存中, 每个线程拥有该变量的一个拷贝副本在自己的工作内存中, 线程修改变量是修改自己工作内存中的变量, 而修改完毕后, 会将自己工作内存中的修改后的值回写到主存中.
```java
public class A{
    private static A instance;
    private A() {}
    public static A getInstance() {
        if(instance == null) {          // 一
            synchronized (A.class) {    // 二
                if(instance == null) {  // 三
                    instance = new A(); // 四
                }
            }
        }
        return instance; // 五
    }
}
```
假设有两个线程同时调用了`getInstance()`方法.
1. 当线程1执行到`if(instance == null)`时, 判断为`true`, 进入`if`内, 拿到`A.class`锁, 进入`synchronized`, 继续执行`if`, 执行`instance = A()`, `instance`的`hashcode`为`850`, **此时`instance`没有回写到主存**, 切换回线程2.
1. 线程2执行到第一个`if`, 因为线程1的值没有回写到主存, 所以还是会进入`if`内, 但是被`synchronized`阻塞了.
1. 线程1将变量回写到主存, 并`return`.
1. 此时线程2拿到`A.class`锁, 进入`synchronized`, `if`判断为`false`, 直接`return`.
所以就算没有使用`volatile`保证内存可见性, 也不会导致出错.
其实`synchronized`就有保证内存可见性的功能.
> 在 [java.util.concurrent.locks.Lock](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Lock.html) 接口的Javadoc中有这样一段话：
> All Lock implementations must enforce the **same memory synchronization semantics as provided by the built-in monitor lock**

再来看指令重排序
`instance = A();` 这条命令并不是原子性的, 它包含3个操作.
1. 在堆内存申请`A`实例的内存空间.
2. 初始化`A`实例.
3. 将`instance`变量指向内存中的`A`实例的内存空间(执行完这步 `instance` 就为非 `null` 了)
由于`JVM`的指令重排序, 步骤`123`可能会变成`132`, 多线程下会导致出错.

假设有两个线程同时调用了`getInstance()`方法. 指令顺序为`132`.
1. 当线程1执行到`if(instance == null)`时, 判断为`true`, 进入`if`内, 拿到`A.class`锁, 进入`synchronized`, 继续执行`if`, 执行`instance = A()`.
1. 先在堆内存申请`A`实例的内存空间, 由于指令重排序, 将`instance`变量指向没有初始化的, 但是已经申请了的内存空间. 此时线程1时间片结束, CPU切换到线程2.
1. 线程2执行到第一个`if`, 因为`instance`已经指向没有初始化的内存空间, 所以直接`return`. 这时调用这个单例, 因为还未初始化, 所以会导致错误出现.

而`volatile`可以防止指令重排序, 让指令严格按照`123`的顺序执行.
**但是, 在`Java 5`之前, 因为`Java`内存模型的缺陷, `volatile`不能解决指令重排序的问题.**
所以最佳实践就是
```java
public class A{
    private volatile static A instance;
    private A() {}
    public static A getInstance() {
        if(instance == null) {
            synchronized (A.class) {
                if(instance == null) {
                    instance = new A();
                }
            }
        }
        return instance;
    }
}
```

# 反射攻击破坏单例(2019.5.15)
```java
public class ReflectHelper {
    public static <T> T create(Class<T> clazz) {
        try {
            Constructor<T> constructor = clazz.getDeclaredConstructor();
            constructor.setAccessible(true);
            return constructor.newInstance();
        } catch (InstantiationException | InvocationTargetException | NoSuchMethodException | IllegalAccessException e) {
            logger.error(String.format("实例化%s失败", clazz.getName()), e);
        }
        return null;
    }
}
```
私有构造函数被`constructor.setAccessible(true);`破解. 那我们只能在构造函数体做文章了.
```java
public class A {
    private static A instance;  //创建唯一一个私有实例
    private A() {               //私有化构造函数
        if(instance != null) {  //避免反射创建
            throw new IllegalStateException("单例模式不允许再创建");
        }
    }
    public static A getInstance() {
        instance = new A(); //初始化
        return instance;    //返回唯一实例
    }
}
```

# 参考资料
- [What is an efficient way to implement a singleton pattern in Java?](https://stackoverflow.com/questions/70689)
- [Double Checked Locking is Broken](http://kanlei.github.io/design%20pattern/2017/04/16/double-checked-locking-is-broken)
- [如何正确地写出单例模式](http://www.importnew.com/21141.html)
- [Java锁是如何保证数据可见性的](http://ifeve.com/java%E9%94%81%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84/)