---
title: Tomcat顶层结构启动流程详解
url: Tomcat Top-level structure startup process
tags:
  - Tomcat
categories:
  - Java Web
date: 2017-05-16 22:23:23
---
# 前言
Tomcat是一个Web容器中间件。本文只描述Server、Service、Cornector、Container的层级关系。
后续文章:
{% post_link Tomcat之Container详解 Tomcat之Container详解 %}

<!-- more -->

# 结构
<img src="https://yuml.me/diagram/nofunky/class/[Server]1-*[Service],[Service]1-*[Connector],[Service]1-1[Container]"/>
Tomcat最顶层是一个Server，代表服务器。
Server由多个Service服务组成，提供具体服务。
Service由多个Connector(负责网络连接、request/response的创建)和Container(处理Servlet)。

# Tomcat启动流程
在Bootstrap中反射创建Catalina实例

## Bootstrap详解
在`org.apache.catalina.startip.Bootstrap`中
`static代码块`完成对`catalinaHomeFile`和`catalinaBaseFile`的初始化。
其中HOME是Tomcat安装目录，Base是Tomcat工作目录。

`main`方法。
创建Bootstrap，并初始化Bootstrap实例。
```java
/* org.apache.catalina.startup.Bootstrap */
public final class Bootstrap {
    private static Bootstrap daemon = null;
    public static void main(String args[]) {
        if (daemon == null) {
            Bootstrap bootstrap = new Bootstrap();
            bootstrap.init();   // 调用init方法进行初始化
            daemon = bootstrap;
        } else {
            Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);
        }
        /** 省略部分代码 */
    }
}
```

`init`方法主要做了以下事
1. 初始化`ClassLoader(commonLoader、catalinaLoader、sharedLoader)`
1. 通过反射创建`Catalina实例`
1. 并通过反射调用`setParentClassLoader`设置`ClassLoader`
1. 保存到`catalinaDaemon`属性中


很明显，第一次调用start命令。调用了`setAwait`、`load`、`start`方法。
这三个方法都是通过反射调用`Catalina`实例中的方法。
```java
/* org.apache.catalina.startup.Bootstrap */
public final class Bootstrap {
    private static Bootstrap daemon = null;
    public static void main(String args[]) {
        /** 省略部分代码 */
        String command = "start";
        if (args.length > 0) {
            command = args[args.length - 1];
        }
        
        if (command.equals("startd"))     {     /* 执行startd命令 */    }
        else if (command.equals("stopd")) {     /* 执行stopd命令 */     }
        else if (command.equals("start")) {
            daemon.setAwait(true);  // 设置等待状态的标志位
            daemon.load(args);      // 从conf/server.xml中加载配置信息
            daemon.start();         // 启动Catalina
        }
        else if (command.equals("stop"))       {     /* 执行stop命令 */     }
        else if (command.equals("configtest")) {     /* 执行configtest命令 */     }
        else {
            log.warn("Bootstrap: command \"" + command + "\" does not exist.");
        }
    }
}
```

## Catalina详解
Catalina的setAwait设置Server启动后是否进入等待状态。
```java
/* org.apache.catalina.startup.Catalina */
public void setAwait(boolean b) {
    await = b;
}
```

load方法解析`conf/server.xml`，并创建Server
```java
/* org.apache.catalina.startup.Catalina */
public void load() {
    long t1 = System.nanoTime();
    // 从conf/server.xml中读取配置信息，并用Digester进行解析，创建Server
    // 完成了Connector和Container的初始化工作
    // 省略部分代码
    getServer().init();
}
```

start方法调用了Server的`start`方法
```java
/* org.apache.catalina.startup.Catalina */
public void start() {
    // 省略部分代码
    try {
        getServer().start();    // 调用Server的start方法
    } catch (LifecycleException e) {
        getServer().destroy();  // 调用Server的destroy方法
    }
    // 省略注册关闭钩子代码
    if (await) {    // 进入等待状态
        await();    // 调用Server的await方法，死循环
        stop();     // 关闭服务器
    }
}
```

## Server详解
Server的默认实现是`org.apache.catalina.core.StandardServer`
继承树
<img src="https://yuml.me/diagram/nofunky/class/[<<Lifecycle>>;interface]^-[<<Server>>;interface], [<<Server>>;interface]^-[StandardServer], [LifecycleMBeanBase]^-[StandardServer], [LifecycleBase]^-[LifecycleMBeanBase], [<<Lifecycle>>;interface]^-[LifecycleBase], [<<JmxEnabled>>;interface]^-[LifecycleMBeanBase], [<<MBeanRegistration>>;interface]^-[<<JmxEnabled>>;interface]"/>
在Catalina中调用了Server的`init`和`start`方法。

`init`方法的实现在`StandardServer`的父类`LifecycleBase`中实现，调用了`initInternal()`方法。
`initInternal()`是抽象方法，交给子类`StandardServer`实现。
类似观察者模式，调用`Service`中的`init`方法。
```java
/* org.apache.catalina.core.StandardServer */
/* 省略类似的startIniternal方法 */
@Override
protected void initInternal() throws LifecycleException {
    // 省略部分代码
    for (int i = 0; i < services.length; i++) {
        services[i].init();     // 调用Service的init方法
    }
}
```

在Catalina中还调用了Server的`await`方法。
接收`SHUTDOWN`命令则跳出循环，关闭服务器(在Catalina的start方法中)。
```java
/* org.apache.catalina.core.StandardServer */
@Override
public void await() {
    if( port == -2 ) {  return; } // 端口为-2,不进入循环
    if( port == -1 ) { // 通过stopAwait标志位，进入循环   }
    // 新建一个监听关闭命令的ServerSocket
    awaitSocket = new ServerSocket(port, 1, InetAddress.getByName(address));
    try {
        while (!stopAwait) {
            ServerSocket serverSocket = awaitSocket;

            Socket socket = null;
            StringBuilder command = new StringBuilder();
            
            InputStream stream;
            socket = serverSocket.accept();     // 等待连接，打开Socket
            stream = socket.getInputStream();   // 获取输入流
          
            int expected = 1024;
            while (expected > 0)    command.append((char) ch);  // 获取命令
            
            boolean match = command.toString().equals("SHUTDOWN");// 如果是关闭命令则跳出循环
            if (match) {    break;  } 
        }
    } finally {
        // 关闭Socket
    }
}
```
这里的`port`端口和`shutdown`命令在`conf/server.xml`中配置
```xml
<!-- server.xml -->
<Server port="8005" shutdown="SHUTDOWN"/>
```

## Service详解
在Server详解中，提到了Server的`initInternal`和`startInternal`方法实际上调用了Service的`init`和`start`方法。
<img src="https://yuml.me/diagram/nofunky/class/[LifecycleMBeanBase]^-[StandardService], [<<Service>>;interface]^-[StandardService], [<<Lifecycle>>;interface]^-[<<Service>>;interface],[LifecycleBase]^-[LifecycleMBeanBase],[<<Lifecycle>>;interface]^-[LifecycleBase], [<<JmxEnabled>>;interface]^-[LifecycleMBeanBase],[<<MBeanRegistration>>;interface]^-[<<JmxEnabled>>;interface]"/>
和Server类似，Service的`start`和`init`方法，都交给其父类`LifecycleBase`实现，并调用了默认子类`StandardService`的`initInternal`和`startInternal`方法。

```java
/* org.apache.catalina.core.StandardService */
/* 省略类似的startIniternal方法 */
@Override
protected void initInternal() throws LifecycleException {
    /* 省略部分代码 */
    // Engine是Container的子接口，Container具体处理Servlet
    engine.init();
    
    // Executor是Connectors中管理线程的线程池
    for (Executor executor : findExecutors()) {
        if (executor instanceof JmxEnabled) {
            ((JmxEnabled) executor).setDomain(getDomain());
        }
        executor.init();    // 调用executors的init方法
    }

    // Mapper的监听器，监听Container的变化
    mapperListener.init();

    // Connector负责网络连接、request/response的创建
    synchronized (connectorsLock) {
        for (Connector connector : connectors) {
            connector.init();
        }
    }
}
```

# 总结
`Bootstrap`入口`main`方法执行`init()`方法，初始化`ClassLoader`和`Catalina`实例。
调用Catalina的`setAwait`、`load`、`start`方法。
Catalina的`load`方法从`conf/server.xml`中读取配置信息，并用Digester进行解析，调用Server的`init`方法初始化Server容器
Server的`init`方法最终调用了StandardServer的`initInternal`方法。并对Server中的所有`Service`进行初始化。
Service的默认实现类StandardService的`startInternal`方法，则对其中的`Container`、`Executor`、`MapperListener`、`Connector`进行初始化。

start同理，详见下方时序图
```sequence 
Bootstrap->Bootstrap: main()
Bootstrap->Bootstrap: init()
Bootstrap->Bootstrap: load()

Bootstrap->Catalina: load()
Catalina->Standard\nServer: init()
Standard\nServer->Standard\nService: init()
Standard\nService->Container: init()
Container-->Standard\nService: 
Standard\nService->Mapper\nListener: init()
Mapper\nListener-->Standard\nService: 
Standard\nService->Executor: init()
Executor-->Standard\nService: 
Standard\nService->Connector: init()
Connector-->Standard\nService: 
Standard\nService-->Standard\nServer: 
Standard\nServer-->Catalina: 
Catalina-->Bootstrap: 

Bootstrap->Bootstrap: start()
Bootstrap->Catalina: start()
Catalina->Standard\nServer: start()
Standard\nServer->Standard\nService: start()
Standard\nService->Container: start()
Container-->Standard\nService: 
Standard\nService->Mapper\nListener: start()
Mapper\nListener-->Standard\nService: 
Standard\nService->Executor: start()
Executor-->Standard\nService: 
Standard\nService->Connector: start()
Connector-->Standard\nService: 
Standard\nService-->Standard\nServer: 
Standard\nServer-->Catalina: 
Catalina-->Bootstrap: 
```

# 参考资料
- 看透SpringMVC源代码分析与实践