<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ahaochan&#39;s Blog</title>
    <link>https://blog.ahao.moe/</link>
    
    <atom:link href="https://blog.ahao.moe/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>你也是程序猿friends呢~</description>
    <pubDate>Mon, 21 Nov 2022 02:35:06 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Redission在debug模式下抛出解锁异常</title>
      <link>https://blog.ahao.moe/posts/not_locked_by_current_thread_by_node_id_in_debug_mode.html</link>
      <guid>https://blog.ahao.moe/posts/not_locked_by_current_thread_by_node_id_in_debug_mode.html</guid>
      <pubDate>Thu, 27 Oct 2022 07:07:55 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近用&lt;code&gt;Redission&lt;/code&gt;出现一个很有趣的问题，在线上环境加锁解锁没有问题，但是一旦进行&lt;code&gt;debug&lt;/code&gt;调试，就会抛出异常。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近用<code>Redission</code>出现一个很有趣的问题，在线上环境加锁解锁没有问题，但是一旦进行<code>debug</code>调试，就会抛出异常。</p><span id="more"></span><h1 id="场景复现"><a href="#场景复现" class="headerlink" title="场景复现"></a>场景复现</h1><p>编写以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AhaoTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlockDebug</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(REDIS_KEY);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            Assertions.fail(<span class="string">&quot;加锁失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 打断点30秒以上</span></span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        Assertions.assertEquals(<span class="number">0</span>, lock.getHoldCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后以<code>debug</code>模式执行，在断点处停留<code>30</code>秒以上。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id: e8f58212-5f8e-43db-94ba-606e07e9d984 thread-id: 1</span><br><span class="line">  at org.redisson.RedissonBaseLock.lambda$unlockAsync$1(RedissonBaseLock.java:312)</span><br><span class="line">  at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)</span><br><span class="line">  ...</span><br><span class="line">  at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)</span><br><span class="line">  at org.redisson.RedissonBaseLock.lambda$evalWriteAsync$0(RedissonBaseLock.java:224)</span><br><span class="line">  at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)</span><br><span class="line">  ...</span><br><span class="line">  at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)</span><br><span class="line">  at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)</span><br><span class="line">  at org.redisson.command.CommandBatchService.lambda$executeAsync$7(CommandBatchService.java:326)</span><br><span class="line">  at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)</span><br><span class="line">  ...</span><br><span class="line">  at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)</span><br><span class="line">  at org.redisson.command.RedisCommonBatchExecutor.handleResult(RedisCommonBatchExecutor.java:130)</span><br><span class="line">  at org.redisson.command.RedisExecutor.checkAttemptPromise(RedisExecutor.java:447)</span><br><span class="line">  at org.redisson.command.RedisExecutor.lambda$execute$3(RedisExecutor.java:169)</span><br><span class="line">  at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)</span><br><span class="line">  ...</span><br><span class="line">  at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)</span><br><span class="line">  at org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:293)</span><br><span class="line">  at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:188)</span><br><span class="line">  at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:116)</span><br><span class="line">  at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:101)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>可以看到，这个异常堆栈很诡异，异常堆栈里没有任何我编写的代码的痕迹，全是<code>Redisson</code>和<code>Netty</code>的代码。</p><h1 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h1><h2 id="求助搜索引擎"><a href="#求助搜索引擎" class="headerlink" title="求助搜索引擎"></a>求助搜索引擎</h2><p>网上大部分都是锁使用方式不对，测试代码已经是最简化的了，正常执行的情况下不会有任何报错。</p><h2 id="异常信息里有node-id和thread-id"><a href="#异常信息里有node-id和thread-id" class="headerlink" title="异常信息里有node id和thread id"></a>异常信息里有node id和thread id</h2><p>先解释下这里的两个参数</p><ul><li><code>node id</code>是构造锁对象时，拿到的连接管理器<code>id</code></li><li><code>thread id</code>是当前线程<code>id</code></li></ul><p>所以我开始怀疑是否是因为<code>debug</code>模式下，导致这两个<code>id</code>发生了变化。</p><p><code>thread id</code>好拿，使用<code>Thread.currentThread().getId()</code>就拿到了。<br><code>node id</code>要去构造函数里面获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.redisson.RedissonBaseLock</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RedissonBaseLock</span> <span class="keyword">extends</span> <span class="title class_">RedissonExpirable</span> <span class="keyword">implements</span> <span class="title class_">RLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedissonBaseLock</span><span class="params">(CommandAsyncExecutor commandExecutor, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(commandExecutor, name);</span><br><span class="line">        <span class="built_in">this</span>.commandExecutor = commandExecutor;</span><br><span class="line">        <span class="built_in">this</span>.id = commandExecutor.getConnectionManager().getId();</span><br><span class="line">        <span class="comment">// 这里打断点, 得到node id为ef35f099-4f38-48c2-93d6-2136b8c160aa</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一通折腾完，发现<code>node id</code>和<code>thread id</code>根本没变。</p><h2 id="分析异常堆栈"><a href="#分析异常堆栈" class="headerlink" title="分析异常堆栈"></a>分析异常堆栈</h2><p>查看最顶层的异常堆栈位置<br><code>at org.redisson.RedissonBaseLock.lambda$unlockAsync$1(RedissonBaseLock.java:312)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.redisson.RedissonBaseLock</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RedissonBaseLock</span> <span class="keyword">extends</span> <span class="title class_">RedissonExpirable</span> <span class="keyword">implements</span> <span class="title class_">RLock</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RFuture&lt;Void&gt; <span class="title function_">unlockAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">        RPromise&lt;Void&gt; result = <span class="keyword">new</span> <span class="title class_">RedissonPromise</span>&lt;&gt;();</span><br><span class="line">        RFuture&lt;Boolean&gt; future = unlockInnerAsync(threadId);</span><br><span class="line">        future.onComplete((opStatus, e) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略部分代码</span></span><br><span class="line">            <span class="keyword">if</span> (opStatus == <span class="literal">null</span>) &#123; <span class="comment">// 关注这里</span></span><br><span class="line">                <span class="type">IllegalMonitorStateException</span> <span class="variable">cause</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>(<span class="string">&quot;attempt to unlock lock, not locked by current thread by node id: &quot;</span> + id + <span class="string">&quot; thread-id: &quot;</span> + threadId);</span><br><span class="line">                result.tryFailure(cause);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 省略部分代码</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，只有<code>opStatus</code>为<code>null</code>时才会进入这个<code>if</code>判断里。<br>这个<code>onComplete</code>明显是<code>unlockInnerAsync</code>异步解锁完成后的回调函数，那么是哪里调用了这个回调函数呢？<br>我们在这个<code>if</code>判断这里打个断点。里面有一些<code>netty</code>的代码，先跳过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.redisson.RedissonBaseLock</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RedissonBaseLock</span> <span class="keyword">extends</span> <span class="title class_">RedissonExpirable</span> <span class="keyword">implements</span> <span class="title class_">RLock</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; RFuture&lt;T&gt; <span class="title function_">evalWriteAsync</span><span class="params">(String key, Codec codec, RedisCommand&lt;T&gt; evalCommandType, String script, List&lt;Object&gt; keys, Object... params)</span> &#123;</span><br><span class="line">        <span class="type">CommandBatchService</span> <span class="variable">executorService</span> <span class="operator">=</span> createCommandBatchService();</span><br><span class="line">        <span class="comment">// redis异步执行lua脚本</span></span><br><span class="line">        RFuture&lt;T&gt; result = executorService.evalWriteAsync(key, codec, evalCommandType, script, keys, params);</span><br><span class="line">        <span class="keyword">if</span> (commandExecutor <span class="keyword">instanceof</span> CommandBatchService) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        RPromise&lt;T&gt; r = <span class="keyword">new</span> <span class="title class_">RedissonPromise</span>&lt;&gt;();</span><br><span class="line">        RFuture&lt;BatchResult&lt;?&gt;&gt; future = executorService.executeAsync();</span><br><span class="line">        future.onComplete((res, ex) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123;</span><br><span class="line">                r.tryFailure(ex);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 关注这里，这里的result.getNow()就是上面拿到的opStatus</span></span><br><span class="line">            r.trySuccess(result.getNow());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们猜，这里的<code>result.getNow()</code>就是上面回调函数的入参<code>opStatus</code>，实际上如果你跟着我打断点，可以确定这个猜想是正确的。<br>这个<code>result</code>是<code>Redis</code>异步执行解锁<code>Lua</code>脚本的时候返回的。我们看看解锁脚本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.redisson.RedissonLock</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonLock</span> <span class="keyword">extends</span> <span class="title class_">RedissonBaseLock</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title function_">unlockInnerAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">                <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return nil;&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;if (counter &gt; 0) then &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return 0; &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;redis.call(&#x27;del&#x27;, KEYS[1]); &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return nil;&quot;</span>,</span><br><span class="line">                Arrays.asList(getRawName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>hexists</code>不存在的时候才会返回<code>null</code>。也就是<code>Redis</code>锁数据丢失了。<br>使用<code>redis-cli -h 127.0.0.1</code>命令上去看看，果然<code>get</code>不到数据了。<br>所以是因为<code>Redis</code>锁数据丢失，才导致异步解锁失败，抛出了异常。</p><h1 id="问题根因"><a href="#问题根因" class="headerlink" title="问题根因"></a>问题根因</h1><p>那么很奇怪，为什么加的锁为什么在<code>debug</code>模式会丢失数据呢？为什么不打断点就不会丢数据，而打断点就会丢失数据呢？</p><p>这里就涉及了<code>Redission</code>锁的自动续期机制，叫做<code>watch dog</code>。<br>简单的说，<code>Redission</code>默认加锁的存活时间是<code>30秒</code>，然后后台会有一个定时任务给这个<code>Redis Key</code>续期。</p><p>当我们打了断点后，<code>watch dog</code>就暂停了，无法对锁进行续期，导致加的锁在超出一定时间后就自动过期失效了。<br>后面放开断点，再去解锁，就解锁异常了。</p><p>线上环境是不允许打断点的，所以不会有这个问题。</p>]]></content:encoded>
      
      
      <category domain="https://blog.ahao.moe/categories/Redis/">Redis</category>
      
      
      <category domain="https://blog.ahao.moe/tags/Redis/">Redis</category>
      
      
      <comments>https://blog.ahao.moe/posts/not_locked_by_current_thread_by_node_id_in_debug_mode.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>你必须知道的Markdown高级用法汇总</title>
      <link>https://blog.ahao.moe/posts/advanced_usage_of_Markdown.html</link>
      <guid>https://blog.ahao.moe/posts/advanced_usage_of_Markdown.html</guid>
      <pubDate>Mon, 24 Oct 2022 08:03:03 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://daringfireball.net/projects/markdown/&quot;&gt;Markdown&lt;/a&gt; 作为一种网络书写语言，特别适合程序员书写文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全文本格式，方便进行&lt;code&gt;diff&lt;/code&gt;，&lt;code&gt;patch&lt;/code&gt;和版本的管理；&lt;/li&gt;
&lt;li&gt;格式直观，简单易学，便于书写和阅读；&lt;/li&gt;
&lt;li&gt;兼容 &lt;code&gt;HTML&lt;/code&gt;，能方便地转换为 &lt;code&gt;pdf&lt;/code&gt;，&lt;code&gt;doc&lt;/code&gt;等格式；&lt;/li&gt;
&lt;li&gt;支持 &lt;code&gt;Linux&lt;/code&gt;，&lt;code&gt;Windows&lt;/code&gt;，&lt;code&gt;Mac&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;支持内嵌代码和语法高亮；&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><a href="http://daringfireball.net/projects/markdown/">Markdown</a> 作为一种网络书写语言，特别适合程序员书写文档：</p><ul><li>全文本格式，方便进行<code>diff</code>，<code>patch</code>和版本的管理；</li><li>格式直观，简单易学，便于书写和阅读；</li><li>兼容 <code>HTML</code>，能方便地转换为 <code>pdf</code>，<code>doc</code>等格式；</li><li>支持 <code>Linux</code>，<code>Windows</code>，<code>Mac</code>；</li><li>支持内嵌代码和语法高亮；</li></ul><span id="more"></span><p>本文的目标读者是对<code>Markdown</code>有一定了解的群体，能简单书写<code>Markdown</code>笔记</p><h1 id="通过-plantuml-编程式插入UML图片"><a href="#通过-plantuml-编程式插入UML图片" class="headerlink" title="通过 plantuml 编程式插入UML图片"></a>通过 <a href="https://plantuml.com/zh/"><code>plantuml</code></a> 编程式插入<code>UML</code>图片</h1><p><code>yuml.me</code>只适用于简单的<code>UML</code>图片生成，如果是比较复杂的<code>UML</code>，那么响应的描述预言挤在<code>url</code>里，会导致<code>url</code>特别长。而浏览器的<code>url</code><a href="https://stackoverflow.com/questions/417142">长度是有限制的</a></p><p>在<code>Markdown</code>里使用<code>plantuml</code>绘图，需要<code>IDE</code>的支持。</p><h2 id="IDEA支持UML"><a href="#IDEA支持UML" class="headerlink" title="IDEA支持UML"></a><code>IDEA</code>支持<code>UML</code></h2><p>我使用的是<code>Intellij IDEA</code>进行编辑。<code>IDEA</code>现在有个关于<code>Markdown</code>的<a href="https://youtrack.jetbrains.com/issue/IDEA-285306"><code>Bug IDEA-285306</code></a>` ，还没标记为修复。</p><blockquote></blockquote><p>第一步，打开<code>plantuml</code>的配置，<code>File-&gt;Settings-&gt;Language &amp; Frameworks -&gt; Markdown -&gt; plantuml</code></p><img data-src="/posts/advanced_usage_of_Markdown/01.png" class=""><p>第二步，下载 <a href="https://github.com/plantuml/plantuml/releases/tag/v1.2021.16"><code>plantuml-1.2021.16.jar</code></a> ，改名为<code>plantuml.jar</code>。<br>拷贝到<code>IDEA</code>的数据目录<code>%LOCALAPPDATA%\JetBrains\IntelliJIdea2021.3</code>里面的<code>download-cache\plantuml</code>目录下。</p><p>第三步，重启<code>IDEA</code>即可。</p><p>如果还有问题，可以参考下<a href="https://youtrack.jetbrains.com/issue/IDEA-285306"><code>IDEA-285306</code></a></p><h2 id="Hexo支持plantuml"><a href="#Hexo支持plantuml" class="headerlink" title="Hexo支持plantuml"></a><code>Hexo</code>支持<code>plantuml</code></h2><p>不止编辑器预览需要支持<code>plantuml</code>，渲染到<code>hexo</code>博客上也需要支持<code>plantuml</code>。<br>我们安装依赖<a href="https://github.com/miao1007/hexo-filter-plantuml"><code>hexo-filter-plantuml</code></a><br>然后编写<code>plantuml</code>语法即可。</p><img data-src="/posts/advanced_usage_of_Markdown/02.png" class=""><img data-src='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMDhweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjI5NXB4O2hlaWdodDoyMDhweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAyOTUgMjA4IiB3aWR0aD0iMjk1cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTtzdHJva2UtZGFzaGFycmF5OjUuMCw1LjA7IiB4MT0iMjkiIHgyPSIyOSIgeTE9IjM2LjI5NjkiIHkyPSIxNzIuODI4MSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41O3N0cm9rZS1kYXNoYXJyYXk6NS4wLDUuMDsiIHgxPSIyNjciIHgyPSIyNjciIHkxPSIzNi4yOTY5IiB5Mj0iMTcyLjgyODEiLz48cmVjdCBmaWxsPSIjRTJFMkYwIiBoZWlnaHQ9IjMwLjI5NjkiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9IjQ5IiB4PSI1IiB5PSI1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMzUiIHg9IjEyIiB5PSIyNC45OTUxIj5BbGljZTwvdGV4dD48cmVjdCBmaWxsPSIjRTJFMkYwIiBoZWlnaHQ9IjMwLjI5NjkiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9IjQ5IiB4PSI1IiB5PSIxNzEuODI4MSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjM1IiB4PSIxMiIgeT0iMTkxLjgyMzIiPkFsaWNlPC90ZXh0PjxyZWN0IGZpbGw9IiNFMkUyRjAiIGhlaWdodD0iMzAuMjk2OSIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iNDMiIHg9IjI0NiIgeT0iNSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI5IiB4PSIyNTMiIHk9IjI0Ljk5NTEiPkJvYjwvdGV4dD48cmVjdCBmaWxsPSIjRTJFMkYwIiBoZWlnaHQ9IjMwLjI5NjkiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9IjQzIiB4PSIyNDYiIHk9IjE3MS44MjgxIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjkiIHg9IjI1MyIgeT0iMTkxLjgyMzIiPkJvYjwvdGV4dD48cG9seWdvbiBmaWxsPSIjMTgxODE4IiBwb2ludHM9IjI1NS41LDYzLjQyOTcsMjY1LjUsNjcuNDI5NywyNTUuNSw3MS40Mjk3LDI1OS41LDY3LjQyOTciIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjI5LjUiIHgyPSIyNjEuNSIgeTE9IjY3LjQyOTciIHkyPSI2Ny40Mjk3Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTUwIiB4PSIzNi41IiB5PSI2Mi4zNjM4Ij5BdXRoZW50aWNhdGlvbiBSZXF1ZXN0PC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiMxODE4MTgiIHBvaW50cz0iNDAuNSw5Mi41NjI1LDMwLjUsOTYuNTYyNSw0MC41LDEwMC41NjI1LDM2LjUsOTYuNTYyNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7c3Ryb2tlLWRhc2hhcnJheToyLjAsMi4wOyIgeDE9IjM0LjUiIHgyPSIyNjYuNSIgeTE9Ijk2LjU2MjUiIHkyPSI5Ni41NjI1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTYwIiB4PSI0Ni41IiB5PSI5MS40OTY2Ij5BdXRoZW50aWNhdGlvbiBSZXNwb25zZTwvdGV4dD48cG9seWdvbiBmaWxsPSIjMTgxODE4IiBwb2ludHM9IjI1NS41LDEyMS42OTUzLDI2NS41LDEyNS42OTUzLDI1NS41LDEyOS42OTUzLDI1OS41LDEyNS42OTUzIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIyOS41IiB4Mj0iMjYxLjUiIHkxPSIxMjUuNjk1MyIgeTI9IjEyNS42OTUzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjA0IiB4PSIzNi41IiB5PSIxMjAuNjI5NCI+QW5vdGhlciBhdXRoZW50aWNhdGlvbiBSZXF1ZXN0PC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiMxODE4MTgiIHBvaW50cz0iNDAuNSwxNTAuODI4MSwzMC41LDE1NC44MjgxLDQwLjUsMTU4LjgyODEsMzYuNSwxNTQuODI4MSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7c3Ryb2tlLWRhc2hhcnJheToyLjAsMi4wOyIgeDE9IjM0LjUiIHgyPSIyNjYuNSIgeTE9IjE1NC44MjgxIiB5Mj0iMTU0LjgyODEiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIyMTQiIHg9IjQ2LjUiIHk9IjE0OS43NjIyIj5Bbm90aGVyIGF1dGhlbnRpY2F0aW9uIFJlc3BvbnNlPC90ZXh0PjwhLS1NRDU9W2E5NzAyYzkyODBkYmJhOTUzMGVlODEwOTZmZTliNmE1XQpAc3RhcnR1bWwNCkFsaWNlIC0+IEJvYjogQXV0aGVudGljYXRpb24gUmVxdWVzdA0KQm9iIC0gLT4gQWxpY2U6IEF1dGhlbnRpY2F0aW9uIFJlc3BvbnNlDQoNCkFsaWNlIC0+IEJvYjogQW5vdGhlciBhdXRoZW50aWNhdGlvbiBSZXF1ZXN0DQpBbGljZSA8LSAtIEJvYjogQW5vdGhlciBhdXRoZW50aWNhdGlvbiBSZXNwb25zZQ0KQGVuZHVtbA0KClBsYW50VU1MIHZlcnNpb24gMS4yMDIyLjEzYmV0YTgoVW5rbm93biBjb21waWxlIHRpbWUpCihHUEwgc291cmNlIGRpc3RyaWJ1dGlvbikKSmF2YSBSdW50aW1lOiBKYXZhKFRNKSBTRSBSdW50aW1lIEVudmlyb25tZW50CkpWTTogSmF2YSBIb3RTcG90KFRNKSA2NC1CaXQgU2VydmVyIFZNCkRlZmF1bHQgRW5jb2Rpbmc6IFVURi04Ckxhbmd1YWdlOiBlbgpDb3VudHJ5OiBVUwotLT48L2c+PC9zdmc+'><h1 id="使用LaTeX语法编写数学公式"><a href="#使用LaTeX语法编写数学公式" class="headerlink" title="使用LaTeX语法编写数学公式"></a>使用<code>LaTeX</code>语法编写数学公式</h1><p>在线生成图片的网站: <a href="https://latex.codecogs.com/eqneditor/editor.php?lang=zh-cn"><code>latex.codecogs.com</code></a></p><p>比如<code>https://latex.codecogs.com/gif.latex?x^&#123;2&#125;+y^&#123;2&#125;=z^&#123;2&#125;</code>，就可以得到下面的数学公式图片<br><img data-src="https://latex.codecogs.com/gif.latex?x%5E%7B2%7D+y%5E%7B2%7D=z%5E%7B2%7D"> </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://xiaocong.github.io/blog/2013/04/22/writing-development-documentation-with-markdown/">在 Markdown 中嵌入 UML 文档</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.ahao.moe/categories/%E5%B7%A5%E5%85%B7/">工具</category>
      
      
      <category domain="https://blog.ahao.moe/tags/Markdown/">Markdown</category>
      
      <category domain="https://blog.ahao.moe/tags/UML/">UML</category>
      
      
      <comments>https://blog.ahao.moe/posts/advanced_usage_of_Markdown.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hexo中Next主题最新版本的微信公众号引流教程</title>
      <link>https://blog.ahao.moe/posts/hexo_next_last_how_drainage_to_wechat_channel.html</link>
      <guid>https://blog.ahao.moe/posts/hexo_next_last_how_drainage_to_wechat_channel.html</guid>
      <pubDate>Fri, 21 Oct 2022 03:40:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;重拾博客&quot;&gt;&lt;a href=&quot;#重拾博客&quot; class=&quot;headerlink&quot; title=&quot;重拾博客&quot;&gt;&lt;/a&gt;重拾博客&lt;/h1&gt;&lt;p&gt;很久没有分享博客了，也是最近比较忙的原因。这几天对博客代码重构了一下，主要针对以下几点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;搭建本地&lt;code&gt;NodeJs&lt;/code&gt;环境&lt;/li&gt;
&lt;li&gt;优化&lt;code&gt;Github Action&lt;/code&gt;自动化构建流程&lt;/li&gt;
&lt;li&gt;调整&lt;code&gt;post&lt;/code&gt;目录下的文章目录结构&lt;/li&gt;
&lt;li&gt;开了一个公众号，逆向分析并修改&lt;code&gt;readMore&lt;/code&gt;脚本，引流到公众号&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="重拾博客"><a href="#重拾博客" class="headerlink" title="重拾博客"></a>重拾博客</h1><p>很久没有分享博客了，也是最近比较忙的原因。这几天对博客代码重构了一下，主要针对以下几点</p><ol><li>搭建本地<code>NodeJs</code>环境</li><li>优化<code>Github Action</code>自动化构建流程</li><li>调整<code>post</code>目录下的文章目录结构</li><li>开了一个公众号，逆向分析并修改<code>readMore</code>脚本，引流到公众号</li></ol><span id="more"></span><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>为了宣传我的公众号，我参考 <a href="https://gylq.gitee.io/posts/137.html">【知识积累】Hexo中next主题微信引流教程</a> 这篇文章进行配置。<br>但是过程中遇到了一个问题，我博客的<code>Next</code>主题似乎太新了，是<code>v8</code>版本的。因此带来了几个问题</p><ol><li>最新版的<code>Next</code>主题将<code>_layout.swig</code>改为了<code>_layout.njk</code></li><li><code>Next</code>在主题配置文件里支持了<code>custom_file_path</code>属性, 不需要再修改<code>_layout.njk</code></li><li><code>&lt;div id=&quot;content&quot;&gt;</code>不存在, 这里要修改原来的<code>readmore.js</code>的注入方式</li></ol><p>迫于网上答案过于陈旧，我这里重新再梳理下<code>v8</code>版本的<code>Next</code>主题要怎么使用<code>readmore.js</code>脚本。<br>这个思路可用于其他主题的适配。<del>（必可活用于下次</del></p><img data-src="/posts/hexo_next_last_how_drainage_to_wechat_channel/01.png" class=""><h1 id="自定义模块页面"><a href="#自定义模块页面" class="headerlink" title="自定义模块页面"></a>自定义模块页面</h1><p><code>Next</code>主题的 <a href="https://github.com/next-theme/hexo-theme-next/blob/v8.8.2/_config.yml#L21-L31">主题配置文件</a> 里已经提供了扩展点</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">footer:</span> <span class="string">source/_data/footer.njk</span></span><br></pre></td></tr></table></figure><p>我们修改完主题配置文件后, 在<code>source/_data</code>目录下创建一个<code>footer.njk</code>文件.<br>在里面填上<code>script</code>脚本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.comments %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/js/readmore.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;script src=&quot;https://readmore.openwrite.cn/js/readmore.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> btw = <span class="keyword">new</span> <span class="title class_">BTWPlugin</span>();</span></span><br><span class="line"><span class="language-javascript">    btw.<span class="title function_">init</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">id</span>: <span class="string">&#x27;container&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">blogId</span>: <span class="string">&#x27;30660-1666263355112-307&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&#x27;岁寒的编程随想&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">qrcode</span>: <span class="string">&#x27;https://blog.ahao.moe/images/config/wechat_channel.jpg&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">keyword</span>: <span class="string">&#x27;more&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h1 id="反混淆魔改readmore脚本"><a href="#反混淆魔改readmore脚本" class="headerlink" title="反混淆魔改readmore脚本"></a>反混淆魔改readmore脚本</h1><p>从上面那套<code>js</code>语法可以猜测出<code>readmore</code>的遮罩层，是根据<code>id</code>为<code>container</code>的<code>DOM</code>元素进行定位操作的。<br>但是我们发现<code>v8</code>版本的文章部分已经没有<code>id</code>这个属性了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main-inner &#123;% block class %&#125;&#123;% endblock %&#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;%- include &#x27;_partials/header/sub-menu.njk&#x27; -%&#125;</span><br><span class="line">  &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line">  &#123;%- include &#x27;_partials/comments.njk&#x27; -%&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的<code>&#123;% block content %&#125;&#123;% endblock %&#125;</code>语法，其实就是将<code>themes/next/layout/_macro/post.njk</code>这个文件引进来。</p><img data-src="/posts/hexo_next_last_how_drainage_to_wechat_channel/02.png" class=""><p>这个<code>&lt;article&gt;</code>就是文章的主要区域, 我们目标是<code>div.post-block</code>。</p><p>在<code>source/js</code>目录下创建一个<code>readmore.js</code>文件，将 <a href="https://readmore.openwrite.cn/js/readmore.js">原始<code>readmore.js</code></a> 的内容复制进去, 并格式化。<br>原始的<code>readmore.js</code>是经过混淆加密的，我们先借助<code>IDE</code>进行格式化.<br>然后找到我们熟悉的<code>init</code>初始化方法，加上<code>debugger</code>断点</p><img data-src="/posts/hexo_next_last_how_drainage_to_wechat_channel/03.png" class=""><p>可以看到这里是通过<code>jQuery</code>的<code>$(&#39;#container&#39;)</code>定位的, 那就简单了, 直接把这一行替换成以下代码即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_0x77ddx3 = $(<span class="string">&#x27;div.post-block&#x27;</span>);</span><br></pre></td></tr></table></figure><p>思路就是这样，如果你的主题不是<code>Next v8</code>，那么也是修改这行代码，取想要<code>hack</code>的元素即可。</p><h1 id="微信公众号的配置"><a href="#微信公众号的配置" class="headerlink" title="微信公众号的配置"></a>微信公众号的配置</h1><p>剩下的公众号配置就按照<code>openwrite</code>的教程来处理就可以了，这里不再赘诉<br><a href="https://openwrite.cn/guide/readmore/readmore.html">https://openwrite.cn/guide/readmore/readmore.html</a></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>想了想，最后还是没有强制引流到公众号。有感兴趣的就点击下面的微信公众号或者<code>RSS</code>订阅吧。</p>]]></content:encoded>
      
      
      <category domain="https://blog.ahao.moe/categories/JavaScript/">JavaScript</category>
      
      
      <category domain="https://blog.ahao.moe/tags/Hexo/">Hexo</category>
      
      
      <comments>https://blog.ahao.moe/posts/hexo_next_last_how_drainage_to_wechat_channel.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>内存映像工具jmap</title>
      <link>https://blog.ahao.moe/posts/jmap.html</link>
      <guid>https://blog.ahao.moe/posts/jmap.html</guid>
      <pubDate>Sun, 25 Apr 2021 14:27:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;jmap&lt;/code&gt;全称&lt;code&gt;Memory Map For Java&lt;/code&gt;虚拟机统计信息监视工具, 可以生成堆内存的快照, 在事后进行分析.&lt;br&gt;当然我们还可以给&lt;code&gt;JVM&lt;/code&gt;加上&lt;code&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/code&gt;, 在内存溢出的时候自动生成堆内存的快照.&lt;br&gt;命令格式: &lt;code&gt;jmap [option] vmid&lt;/code&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>jmap</code>全称<code>Memory Map For Java</code>虚拟机统计信息监视工具, 可以生成堆内存的快照, 在事后进行分析.<br>当然我们还可以给<code>JVM</code>加上<code>-XX:+HeapDumpOnOutOfMemoryError</code>, 在内存溢出的时候自动生成堆内存的快照.<br>命令格式: <code>jmap [option] vmid</code></p><span id="more"></span><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>vmid</code></td><td align="center">如果是本地虚拟机, 那就是<code>jps</code>的进程号. 如果是远程虚拟机, 则应该是<code>[protocol:][//]lvmid[@hostname[:port]/servername]</code></td></tr></tbody></table><p>选项<code>option</code>代表要查询的数据</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>-dump</code></td><td align="center">生成堆内存快照. 格式为<code>-dump:[live,]format=b,file=/tmp/heap.dump</code>, 其中<code>live</code>说明是否只<code>dump</code>存活的对象</td></tr><tr><td align="center"><code>-finalizerinfo</code></td><td align="center">显示在<code>F-Queue</code>中等待<code>Finalizer</code>线程执行<code>finalize</code>方法的对象.</td></tr><tr><td align="center"><code>-heap</code></td><td align="center">显示堆详细信息</td></tr><tr><td align="center"><code>-histo</code></td><td align="center">显示堆中对象统计信息</td></tr><tr><td align="center"><code>-permstat</code></td><td align="center">以<code>ClassLoader</code>为统计口径显示永久代内存状态</td></tr><tr><td align="center"><code>-F</code></td><td align="center"><code>-dump</code>没响应的时候, 强制生成<code>dump</code>快照</td></tr></tbody></table><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="jmap-heap-PID"><a href="#jmap-heap-PID" class="headerlink" title="jmap -heap PID"></a>jmap -heap PID</h2><p>用来查看堆内存, <code>jstat</code>已有相同的功能了, 并且更全面.<br><code>jstat</code>除了堆内存信息, 还有<code>GC</code>的相关信息.</p><h2 id="jmap-histo-PID"><a href="#jmap-histo-PID" class="headerlink" title="jmap -histo PID"></a>jmap -histo PID</h2><p>所以一般<code>jmap</code>都是用来查看堆内对象的具体内存信息的. 这是<code>jstat</code>做不到的事情.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:        190803       63620528  [B</span><br><span class="line">   2:         33239       40343096  [I</span><br><span class="line">   3:        349476       39534528  [C</span><br><span class="line">   4:        186246        4469904  java.lang.String</span><br><span class="line">   5:         14783        4389000  [Ljava.util.HashMap$Node;</span><br><span class="line">   6:         54116        2809872  [Ljava.lang.Object;</span><br><span class="line">   7:         29125        2563000  java.lang.reflect.Method</span><br><span class="line">...</span><br><span class="line">Total       1671051      186914432</span><br></pre></td></tr></table></figure><p>从输出信息可以看出<br><code>byte[]</code>类型有<code>190803</code>个实例, 占用<code>63620528</code>个字节.<br><code>int[]</code>类型有<code>33239</code>个实例, 占用<code>40343096</code>个字节.<br><code>char[]</code>类型有<code>349476</code>个实例, 占用<code>39534528</code>个字节.<br>以此类推</p><h2 id="jmap-dump-live-format-b-file-dump-hprof-PID"><a href="#jmap-dump-live-format-b-file-dump-hprof-PID" class="headerlink" title="jmap -dump:live,format=b,file=dump.hprof PID"></a>jmap -dump:live,format=b,file=dump.hprof PID</h2><p>当然生产环境不会给你慢慢的分析, 一般都是输出到文件, 把文件传到本地慢慢分析.<br>可以用<code>jhat dump.hprof -port 7000</code>分析, 但一般使用的是<code>MAT</code>做分析.</p>]]></content:encoded>
      
      
      <category domain="https://blog.ahao.moe/categories/Java/">Java</category>
      
      
      <category domain="https://blog.ahao.moe/tags/JVM/">JVM</category>
      
      
      <comments>https://blog.ahao.moe/posts/jmap.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>虚拟机统计信息监视工具jstat</title>
      <link>https://blog.ahao.moe/posts/jstat.html</link>
      <guid>https://blog.ahao.moe/posts/jstat.html</guid>
      <pubDate>Sat, 24 Apr 2021 16:39:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;jstat&lt;/code&gt;全称&lt;code&gt;JVM Statistics Monitoring Tool&lt;/code&gt;虚拟机统计信息监视工具, 可以用来监视虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据.&lt;br&gt;命令格式: &lt;code&gt;jstat [option vmid [interval[s|ms] [count]]]&lt;/code&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>jstat</code>全称<code>JVM Statistics Monitoring Tool</code>虚拟机统计信息监视工具, 可以用来监视虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据.<br>命令格式: <code>jstat [option vmid [interval[s|ms] [count]]]</code></p><span id="more"></span><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>vmid</code></td><td align="center">如果是本地虚拟机, 那就是<code>jps</code>的进程号. 如果是远程虚拟机, 则应该是<code>[protocol:][//]lvmid[@hostname[:port]/servername]</code></td></tr><tr><td align="center"><code>interval</code></td><td align="center">查询间隔</td></tr><tr><td align="center"><code>count</code></td><td align="center">查询次数</td></tr></tbody></table><p>选项<code>option</code>代表用户希望查询的虚拟机信息, 主要分为三类: 类加载、垃圾收集、运行期编译状况.<br>| 选项 | 作用 |<br>|:——:|:——:|<br>| <code>-gc</code> | 监视堆状况 |<br>| <code>-gcutil</code> | 和<code>-gc</code>基本相同, 但主要关注已使用空间占总空间的百分比 |</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="jstat-gc-PID"><a href="#jstat-gc-PID" class="headerlink" title="jstat -gc PID"></a>jstat -gc PID</h2><p>执行<code>jstat -gc PID</code>命令, 查看<code>JVM</code>状态<br>| 列 | 值 | 说明 |<br>|:——:|:——:|:——:|<br>| <code>S0C</code> | <code>14848.0</code>  | <code>From Survivor</code>区的内存大小 |<br>| <code>S1C</code> | <code>14336.0</code> | <code>To Survivor</code>区的内存大小 |<br>| <code>S0U</code> | <code>0.0</code> | <code>From Survivor</code>区已使用内存大小 |<br>| <code>S1U</code> | <code>11904.5</code> | <code>To Survivor</code>区已使用内存大小 |<br>| <code>EC</code> | <code>147456.0</code> | <code>Eden</code>区的内存大小 |<br>| <code>EU</code> | <code>145865.4</code> | <code>Eden</code>区已使用内存大小 |<br>| <code>OC</code> | <code>168960.0</code> | 老年代的内存大小 |<br>| <code>OU</code> | <code>18178.0</code> | 老年代已使用内存大小 |<br>| <code>MC</code> | <code>44328.0</code> | 方法区的内存大小 |<br>| <code>MU</code> | <code>41720.7</code> | 方法区已使用内存大小 |<br>| <code>CCSC</code> | <code>6440.0</code> | 压缩类空间的内存大小 |<br>| <code>CCSU</code> | <code>5907.5</code> | 压缩类空间已使用内存大小 |<br>| <code>YGC</code> | <code>9</code> | 系统运行迄今为止的<code>Young GC</code>次数 |<br>| <code>YGCT</code> | <code>0.036</code> | <code>Young GC</code>耗时 |<br>| <code>FGC</code> | <code>2</code> | 系统运行迄今为止的<code>Full GC</code>次数 |<br>| <code>FGCT</code> | <code>0.041</code> | <code>Full GC</code>耗时 |<br>| <code>GCT</code> | <code>0.077</code> | 所有<code>GC</code>耗时 |</p><h2 id="其他-jstat-命令"><a href="#其他-jstat-命令" class="headerlink" title="其他 jstat 命令"></a>其他 jstat 命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jstat -gccapacity PID <span class="comment"># 堆内存分析</span></span><br><span class="line">jstat -gcnew PID <span class="comment"># 年轻代GC分析，这里的TT和MTT可以看到对象在年轻代存活的年龄和存活的最大年龄</span></span><br><span class="line">jstat -gcnewcapacity PID <span class="comment"># 年轻代内存分析</span></span><br><span class="line">jstat -gcold PID <span class="comment"># 老年代GC分析</span></span><br><span class="line">jstat -gcoldcapacity PID <span class="comment"># 老年代内存分析</span></span><br><span class="line">jstat -gcmetacapacity PID <span class="comment"># 元数据区内存分析</span></span><br></pre></td></tr></table></figure><h1 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h1><h2 id="新生代对象增长速率"><a href="#新生代对象增长速率" class="headerlink" title="新生代对象增长速率"></a>新生代对象增长速率</h2><p>使用命令<code>jstat -gc PID 1000 10</code>, 表示每<code>1000</code>毫秒输出一次统计信息, 共输出<code>10</code>次.<br>就可以根据每次的<code>EU</code>, 计算出新生代对象增长速率</p><h2 id="YoungGC的触发频率"><a href="#YoungGC的触发频率" class="headerlink" title="YoungGC的触发频率"></a>YoungGC的触发频率</h2><p>既然知道了新生代对象增长速率，就可以用新生代内存大小除以速率, 得到新生代还有多久填满, 也就是多久触发一次<code>YoungGC</code>.</p><h2 id="YoungGC的每次耗时"><a href="#YoungGC的每次耗时" class="headerlink" title="YoungGC的每次耗时"></a>YoungGC的每次耗时</h2><p>直接用<code>YGCT</code>除以<code>YGC</code>就可以得到<code>YoungGC</code>的每次耗时</p><h2 id="每次YoungGC后有多少对象进入老年代"><a href="#每次YoungGC后有多少对象进入老年代" class="headerlink" title="每次YoungGC后有多少对象进入老年代"></a>每次YoungGC后有多少对象进入老年代</h2><p>其实就是看老年代的对象增长速率, 和新生代对象增长速率同样的方法.<br>使用命令<code>jstat -gc PID 1000 10</code>, 表示每<code>1000</code>毫秒输出一次统计信息, 共输出<code>10</code>次.<br>就可以根据每次的<code>OU</code>, 计算出新生代对象增长速率</p><h2 id="每次YoungGC后有多少对象存活下来"><a href="#每次YoungGC后有多少对象存活下来" class="headerlink" title="每次YoungGC后有多少对象存活下来"></a>每次YoungGC后有多少对象存活下来</h2><p>看<code>S</code>区的内存大小, 加上老年代内存增长大小</p><h2 id="FullGC的触发频率"><a href="#FullGC的触发频率" class="headerlink" title="FullGC的触发频率"></a>FullGC的触发频率</h2><p>和<code>YoungGC</code>触发频率同样的计算方式.<br>既然知道了老年代对象增长速率，就可以用老年代内存大小除以速率, 得到老年代还有多久填满, 也就是多久触发一次<code>FullGC</code>.</p><h2 id="FullGC的每次耗时"><a href="#FullGC的每次耗时" class="headerlink" title="FullGC的每次耗时"></a>FullGC的每次耗时</h2><p>直接用<code>FGCT</code>除以<code>FGC</code>就可以得到<code>FullGC</code>的每次耗时</p>]]></content:encoded>
      
      
      <category domain="https://blog.ahao.moe/categories/Java/">Java</category>
      
      
      <category domain="https://blog.ahao.moe/tags/JVM/">JVM</category>
      
      
      <comments>https://blog.ahao.moe/posts/jstat.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>NPM包管理工具入门</title>
      <link>https://blog.ahao.moe/posts/what_is_npm.html</link>
      <guid>https://blog.ahao.moe/posts/what_is_npm.html</guid>
      <pubDate>Mon, 01 Mar 2021 15:03:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;NPM&lt;/code&gt;对于&lt;code&gt;Nodejs&lt;/code&gt;, 就像&lt;code&gt;Maven&lt;/code&gt;对于&lt;code&gt;Java&lt;/code&gt;.&lt;br&gt;&lt;code&gt;NPM&lt;/code&gt;是一个包管理工具, 用于管理依赖. &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>NPM</code>对于<code>Nodejs</code>, 就像<code>Maven</code>对于<code>Java</code>.<br><code>NPM</code>是一个包管理工具, 用于管理依赖. </p><span id="more"></span><h1 id="npmrc-详解"><a href="#npmrc-详解" class="headerlink" title="npmrc 详解"></a>npmrc 详解</h1><p>作为一个包管理工具, 肯定有相关的配置.<br>比如, 从哪个仓库下载依赖, 保存到本地的哪个目录下.</p><p>安装好<code>NPM</code>后, 会有三个文件</p><ol><li>每个项目的配置文件(<code>/path/to/my/project/.npmrc</code>)</li><li>每个用户的配置文件(<code>〜/.npmrc</code>)</li><li>全局配置文件(<code>$PREFIX/etc/npmrc</code>)</li><li><code>NPM</code>内置配置文件(<code>/path/to/npm/npmrc</code>)</li></ol><p>具体可以看看<a href="https://docs.npmjs.com/cli/v7/configuring-npm/npmrc"><code>npmrc</code>官方文档</a></p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置远程仓库</span></span><br><span class="line">npm config set registry https://registry.npm.taobao.org </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置缓存位置</span></span><br><span class="line">npm config set cache &quot;D:\nodejs\node_cache&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置全局模块存放位置</span>  </span><br><span class="line">npm config set prefix &quot;D:\nodejs&quot;</span><br><span class="line"></span><br><span class="line">npm config ls</span><br></pre></td></tr></table></figure><p>像我们一开始都会配置国内仓库, 这些命令都是去修改用户的配置文件, 也就是<code>~/.npmrc</code></p><h1 id="package-json-和-package-lock-json"><a href="#package-json-和-package-lock-json" class="headerlink" title="package.json 和 package-lock.json"></a>package.json 和 package-lock.json</h1><p>和<code>pom.xml</code>类似, <code>package.json</code>就是描述这个项目的, 发布的时候会用到.<br>这里拿<code>hexo</code>的举个例子.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo-site&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo generate&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;clean&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;deploy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo deploy&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo server&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hexo&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5.3.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;hexo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-generator-archive&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-generator-category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-generator-index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-generator-tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-renderer-ejs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-renderer-marked&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-renderer-stylus&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-theme-landscape&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.0.3&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>name</code>和<code>version</code>是必填项, 用来标记项目名称和版本号. 这个<code>name</code>可以作为<code>require</code>的参数传递.<br><code>scripts</code>用来注册<code>npm</code>命令, 比如<code>npm clean</code>就会调用<code>hexo clean</code>命令.<br><code>hexo</code>是自定义的配置, 不用管.<br><code>dependencies</code>表示本项目的所有依赖名称以及版本哈.</p><p>具体可以看看<a href="https://docs.npmjs.com/cli/v7/configuring-npm/package-json"><code>package.json</code>官方文档</a></p><p><code>package-lock.json</code>和<code>package.json</code>结构差不多, 那为什么要有两个不同的文件呢?</p><h1 id="package-json-和-package-lock-json-1"><a href="#package-json-和-package-lock-json-1" class="headerlink" title="package.json 和 package-lock.json"></a>package.json 和 package-lock.json</h1><p>比如说<code>hexo</code>依赖的<code>hexo-renderer-ejs</code>在<code>package.json</code>的版本号是<code>1.0.0</code>.<br>在执行<code>npm install</code>的时候, <code>npm</code>会根据<code>package.json</code>的定义, 从本地磁盘或远程仓库里获取依赖.</p><p>假设<code>hexo-renderer-ejs</code>紧急发布了一个修复<code>bug</code>的版本<code>1.0.2</code>.<br>那在执行<code>npm install</code>的时候就会去根据主版本号<code>1</code>去获取最新的<code>hexo-renderer-ejs</code>版本.</p><p>正常按语义化版本的规范来说, 只要主版本号不变, 那都是兼容的.<br>但万一不按规范来, 比如<code>1.0.2</code>和<code>1.0.0</code>是不兼容的. 而<code>npm install</code>每次都会根据主版本号去拉取最新的依赖, 那风险就很大了.</p><p>为了解决这个问题, <code>package-lock.json</code>就出现了. <code>package-lock.json</code>和<code>package.json</code>结构差不多.<br>执行<code>npm install</code>的时候, <code>npm</code>会根据<code>package.json</code>拉取最新的依赖版本, 然后生成<code>package-lock.json</code>, 锁定版本号.<br>然后下次<code>npm install</code>的时候, 就会从<code>package-lock.json</code>中获取准确的版本号, 就不会出现升级风险. </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://docs.npmjs.com/cli/v7/">官方文档</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.ahao.moe/categories/Nodejs/">Nodejs</category>
      
      
      <category domain="https://blog.ahao.moe/tags/Nodejs/">Nodejs</category>
      
      
      <comments>https://blog.ahao.moe/posts/what_is_npm.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>PPT如何使用VBA批量替换字体</title>
      <link>https://blog.ahao.moe/posts/PPT_how_to_replace_font_by_vba.html</link>
      <guid>https://blog.ahao.moe/posts/PPT_how_to_replace_font_by_vba.html</guid>
      <pubDate>Thu, 25 Feb 2021 03:18:11 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近有个需求, 需要将&lt;code&gt;PPT&lt;/code&gt;内的字体全部修改为华文中宋, 并修改字号, 字符间距.&lt;br&gt;原以为可以和&lt;code&gt;notepad++&lt;/code&gt;录制宏, 但是&lt;code&gt;office&lt;/code&gt;居然把录制宏这个功能干掉了, 要实现这个需求, 只能自己写&lt;code&gt;VBA&lt;/code&gt;.&lt;br&gt;本文从零开始学习&lt;code&gt;VBA&lt;/code&gt;使用.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近有个需求, 需要将<code>PPT</code>内的字体全部修改为华文中宋, 并修改字号, 字符间距.<br>原以为可以和<code>notepad++</code>录制宏, 但是<code>office</code>居然把录制宏这个功能干掉了, 要实现这个需求, 只能自己写<code>VBA</code>.<br>本文从零开始学习<code>VBA</code>使用.</p><span id="more"></span><h1 id="什么是VBA"><a href="#什么是VBA" class="headerlink" title="什么是VBA"></a>什么是VBA</h1><blockquote><p>Visual Basic for Applications（VBA）是Visual Basic的一种宏语言，主要能用来扩展Windows的应用程序功能，特别是Microsoft Office软件。也可说是一种应用程序视觉化的Basic Script。 1994年发行的Excel 5.0版本中，即具备了VBA的宏功能。</p></blockquote><p>以上来自维基百科, 在我看来就是可以应用在<code>office</code>全家桶的一个编程语言. 既然是编程语言, 那就肯定有数据结构, 变量, 流程控制语句等.</p><h1 id="PPT内的VBA对象"><a href="#PPT内的VBA对象" class="headerlink" title="PPT内的VBA对象"></a>PPT内的VBA对象</h1><p><a href="https://docs.microsoft.com/en-us/office/vba/api/powerpoint.application.activepresentation"><code>ActivePresentation</code></a>: 返回一个<code>Presentation</code>对象, 该对象表示当前打开的<code>PPT</code>.<br><a href="https://docs.microsoft.com/en-us/office/vba/api/powerpoint.slides"><code>ActivePresentation.Slides</code></a>: 返回<code>PPT</code>内的幻灯片集合.<br><a href="https://docs.microsoft.com/en-us/office/vba/api/powerpoint.slide.shapes"><code>ActivePresentation.Slides.Shapes</code></a>: 返回幻灯片内的所有元素集合, 包括图片、文字等.<br><a href="https://docs.microsoft.com/en-us/office/vba/api/powerpoint.shape.textframe"><code>ActivePresentation.Slides.Shapes.TextFrame</code></a>: 修改元素内的文本属性<br><a href="https://docs.microsoft.com/en-us/office/vba/api/powerpoint.textframe2"><code>ActivePresentation.Slides.Shapes.TextFrame2</code></a>: 修改元素内的文本属性</p><p><code>TextFrame</code>和<code>TextFrame2</code>都是可以修改文本属性. 不需要纠结它们有什么不同.</p><h1 id="VBA语法"><a href="#VBA语法" class="headerlink" title="VBA语法"></a>VBA语法</h1><p><a href="https://docs.microsoft.com/en-us/office/vba/language/concepts/getting-started/declaring-variables"><code>Dim a As object</code></a>: 声明<code>object</code>类型的对象变量<code>a</code><br><a href="https://docs.microsoft.com/en-us/office/vba/language/concepts/getting-started/using-for-eachnext-statements"><code>For Each a In Array ... Next</code></a>: 循环遍历<code>Array</code>数组, 每个元素都赋值给变量<code>a</code>.<br><a href="https://docs.microsoft.com/en-us/office/vba/language/concepts/getting-started/using-ifthenelse-statements"><code>If...Then...Else</code></a>: 流程判断语句.<br><a href="https://docs.microsoft.com/en-us/dotnet/visual-basic/language-reference/operators/not-operator"><code>Not a</code></a>: 对表达式的值取反, 相当于<code>!a</code>.<br><a href="https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/with-statement"><code>With object ... End With</code></a>: 为<code>object</code>对象设置属性.<br><a href="https://docs.microsoft.com/en-us/dotnet/visual-basic/programming-guide/program-structure/comments-in-code"><code>&#39;我被单引号注释了</code></a>: 单引号表示注释</p><h1 id="完整例子"><a href="#完整例子" class="headerlink" title="完整例子"></a>完整例子</h1><p>整个逻辑很简单, 就是循环遍历, 判断有文字就修改文字的属性.<br>如果有不想修改的属性, 打上单引号注释掉, 或者直接删掉那一行代码就可以了.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Sub ChangeFont()</span><br><span class="line">    Dim oShape As Shape</span><br><span class="line">    Dim oSlide As Slide</span><br><span class="line">    Dim oTxtRange As TextRange</span><br><span class="line">    On Error Resume Next</span><br><span class="line">  </span><br><span class="line">    For Each oSlide In ActivePresentation.Slides</span><br><span class="line">        For Each oShape In oSlide.Shapes</span><br><span class="line">            Set oTxtRange1 = oShape.TextFrame.TextRange</span><br><span class="line">            If Not IsNull(oTxtRange1) Then</span><br><span class="line">                With oTxtRange1.Font</span><br><span class="line">                .NameFarEast = &quot;华文中宋&quot;           &#x27;中文字体名称</span><br><span class="line">                .Name = &quot;华文中宋&quot;                  &#x27;字体名称</span><br><span class="line">                .NameOther = &quot;华文中宋&quot;             &#x27;其他字体名称</span><br><span class="line">                .Size = 20                          &#x27;字体大小</span><br><span class="line">                .Color.RGB = RGB(Red:=0, Green:=0, Blue:=0) &#x27;字体颜色</span><br><span class="line">                .Bold = False                       &#x27;是否加粗</span><br><span class="line">                .Italic = False                     &#x27;是否倾斜</span><br><span class="line">                .Shadow = False                     &#x27;是否阴影</span><br><span class="line">                End With</span><br><span class="line">            End If</span><br><span class="line">            </span><br><span class="line">            Set oTxtRange2 = oShape.TextFrame2.TextRange</span><br><span class="line">            If Not IsNull(oTxtRange2) Then</span><br><span class="line">                With oTxtRange2.Font</span><br><span class="line">                .Spacing = 0                        &#x27;字体字符间距为普通</span><br><span class="line">                End With</span><br><span class="line">            End If</span><br><span class="line">        Next</span><br><span class="line">    Next</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>写<code>VBA</code>的主要难点是对<code>office</code>体系内的对象不了解, 就拿<code>TextFrame</code>和<code>TextFrame2</code>来说, 同样设置字体格式, 居然分为两个对象来设置.</p><p>目前的需求很简单, 已经能满足了, 如果后续有其他奇奇怪怪的需求, 再补充下这个代码.</p>]]></content:encoded>
      
      
      <category domain="https://blog.ahao.moe/categories/Microsoft-Office/">Microsoft Office</category>
      
      
      <category domain="https://blog.ahao.moe/tags/VBA/">VBA</category>
      
      
      <comments>https://blog.ahao.moe/posts/PPT_how_to_replace_font_by_vba.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring Cloud Gateway 聚合 swagger 3.0.0</title>
      <link>https://blog.ahao.moe/posts/integrate_swagger_3_in_spring_cloud_gateway.html</link>
      <guid>https://blog.ahao.moe/posts/integrate_swagger_3_in_spring_cloud_gateway.html</guid>
      <pubDate>Tue, 23 Feb 2021 03:55:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;网上关于&lt;code&gt;zuul&lt;/code&gt;聚合各个微服务的&lt;code&gt;swagger&lt;/code&gt;已经有很多文章了, 但是没有一个完整的关于&lt;code&gt;spring cloud gateway&lt;/code&gt;的聚合教程.&lt;br&gt;研究了一天, 写了个&lt;code&gt;demo&lt;/code&gt;, 然后写篇文章记录一下.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网上关于<code>zuul</code>聚合各个微服务的<code>swagger</code>已经有很多文章了, 但是没有一个完整的关于<code>spring cloud gateway</code>的聚合教程.<br>研究了一天, 写了个<code>demo</code>, 然后写篇文章记录一下.</p><span id="more"></span><h1 id="Swagger引入"><a href="#Swagger引入" class="headerlink" title="Swagger引入"></a>Swagger引入</h1><p><code>Springfox</code>现在已经更新到<code>3.0.0</code>了, 并且也支持了<code>starter</code>方式.<br>直接<a href="https://mvnrepository.com/artifact/io.springfox/springfox-boot-starter">引入</a>, 不需要加任何注解.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="聚合Swagger"><a href="#聚合Swagger" class="headerlink" title="聚合Swagger"></a>聚合Swagger</h1><p>和<code>zuul</code>的套路一样, 我们要实现<code>SwaggerResourcesProvider</code>接口, 然后根据各个服务的服务名拼接<code>uri</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> <span class="keyword">implements</span> <span class="title class_">SwaggerResourcesProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RouteDefinitionLocator routeDefinitionLocator; <span class="comment">// 获取路由定义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;SwaggerResource&gt; <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;SwaggerResource&gt; swaggerResourceList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        routeDefinitionLocator.getRouteDefinitions()</span><br><span class="line">            .map(<span class="built_in">this</span>::swaggerResource)           <span class="comment">// 转化为 SwaggerResource 对象</span></span><br><span class="line">            .subscribe(swaggerResourceList::add); <span class="comment">// Flux 转化为 List 对象</span></span><br><span class="line">        <span class="keyword">return</span> swaggerResourceList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SwaggerResource <span class="title function_">swaggerResource</span><span class="params">(RouteDefinition definition)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">location</span> <span class="operator">=</span> definition.getPredicates().stream()</span><br><span class="line">            .filter(predicate -&gt; <span class="string">&quot;Path&quot;</span>.equalsIgnoreCase(predicate.getName()))</span><br><span class="line">            .findFirst() <span class="comment">// 获取第一个名为 Path 的 predicate, 里面含有路由规则</span></span><br><span class="line">            .map(PredicateDefinition::getArgs) </span><br><span class="line">            <span class="comment">// 如果是从注册中心的路由规则, key 就是 pattern, 否则就是 _genkey_0</span></span><br><span class="line">            .map(map -&gt; map.getOrDefault(<span class="string">&quot;pattern&quot;</span>, map.get(NameUtils.GENERATED_NAME_PREFIX + <span class="string">&quot;0&quot;</span>)))</span><br><span class="line">            <span class="comment">// 拼接 url</span></span><br><span class="line">            .map(pattern -&gt; StringUtils.substringBefore(pattern, <span class="string">&quot;*&quot;</span>))</span><br><span class="line">            .map(pattern -&gt; pattern + <span class="string">&quot;v2/api-docs&quot;</span>)</span><br><span class="line">            .orElse(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">SwaggerResource</span> <span class="variable">swaggerResource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SwaggerResource</span>();</span><br><span class="line">        swaggerResource.setName(definition.getId());</span><br><span class="line">        swaggerResource.setLocation(location);</span><br><span class="line">        <span class="keyword">return</span> swaggerResource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个执行流程很简单, 就是从<strong>路由定义</strong>里面获取<strong>路由规则</strong>, 拼接成<code>swagger</code>的地址, 丢到<code>SwaggerResource</code>里面.<br>但是中间有一些比较坑的地方.</p><h2 id="Flux-转化为-List-对象"><a href="#Flux-转化为-List-对象" class="headerlink" title="Flux 转化为 List 对象"></a>Flux 转化为 List 对象</h2><p>不懂<code>Mono</code>和<code>Flux</code>的去搜索, 自己实现一个<code>webflux</code>的<code>hello world</code>程序.<br><code>Mono</code>和<code>Flux</code>都是支持泛型的类. 可以简单地认为, <code>Mono</code>是包装了一个对象的对象, <code>Flux</code>是包装了一堆对象的集合.<br>要进行转换有两种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SwaggerResource&gt; swaggerResourceList1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">routeDefinitionLocator.getRouteDefinitions()</span><br><span class="line">        .map(<span class="built_in">this</span>::swaggerResource)</span><br><span class="line">        .subscribe(swaggerResourceList1::add);</span><br><span class="line">    </span><br><span class="line">List&lt;SwaggerResource&gt; swaggerResourceList2 = routeDefinitionLocator.getRouteDefinitions()</span><br><span class="line">        .map(<span class="built_in">this</span>::swaggerResource)</span><br><span class="line">        .collectList()</span><br><span class="line">        .block(Duration.ofSeconds(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>但是我们只能用第一种, 第二种方法会抛出<code>IllegalStateException</code>异常.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reactor.core.publisher.Mono</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Mono</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">CorePublisher</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">block</span><span class="params">(Duration timeout)</span> &#123;</span><br><span class="line">        BlockingMonoSubscriber&lt;T&gt; subscriber = <span class="keyword">new</span> <span class="title class_">BlockingMonoSubscriber</span>&lt;&gt;();</span><br><span class="line">        subscribe((Subscriber&lt;T&gt;) subscriber);</span><br><span class="line">        <span class="keyword">return</span> subscriber.blockingGet(timeout.toMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reactor.core.publisher.BlockingSingleSubscriber</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BlockingSingleSubscriber</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">CountDownLatch</span> <span class="keyword">implements</span> <span class="title class_">InnerConsumer</span>&lt;T&gt;, Disposable &#123;</span><br><span class="line">    <span class="keyword">final</span> T <span class="title function_">blockingGet</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Schedulers.isInNonBlockingThread()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;block()/blockFirst()/blockLast() are blocking, which is not supported in thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reactor.core.scheduler.Schedulers</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Schedulers</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isInNonBlockingThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread() <span class="keyword">instanceof</span> NonBlocking;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取路由规则"><a href="#获取路由规则" class="headerlink" title="获取路由规则"></a>获取路由规则</h2><p><code>gateway</code>会从注册中心获取服务的相关信息, 初始化路由规则.<br><code>GatewayDiscoveryClientAutoConfiguration</code>会为<code>DiscoveryLocatorProperties</code>属性生成一个初始化的<code>PredicateDefinition</code>集合, 有点像原型模式.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayDiscoveryClientAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;PredicateDefinition&gt; <span class="title function_">initPredicates</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;PredicateDefinition&gt; definitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> add a predicate that matches the url at /serviceId?</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// add a predicate that matches the url at /serviceId/**</span></span><br><span class="line">        <span class="type">PredicateDefinition</span> <span class="variable">predicate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PredicateDefinition</span>();</span><br><span class="line">        predicate.setName(<span class="string">&quot;Path&quot;</span>); <span class="comment">// 所以上面才要根据 Path 进行过滤</span></span><br><span class="line">        predicate.addArg(<span class="string">&quot;pattern&quot;</span>, <span class="string">&quot;&#x27;/&#x27;+serviceId+&#x27;/**&#x27;&quot;</span>); <span class="comment">// 所以上面才要根据 pattern 进行过滤</span></span><br><span class="line">        definitions.add(predicate);</span><br><span class="line">        <span class="keyword">return</span> definitions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DiscoveryLocatorProperties <span class="title function_">discoveryLocatorProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DiscoveryLocatorProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DiscoveryLocatorProperties</span>();</span><br><span class="line">        properties.setPredicates(initPredicates());</span><br><span class="line">        properties.setFilters(initFilters());</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.springframework.cloud.gateway.discovery.DiscoveryClientRouteDefinitionLocator</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscoveryClientRouteDefinitionLocator</span> <span class="keyword">implements</span> <span class="title class_">RouteDefinitionLocator</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;RouteDefinition&gt; <span class="title function_">getRouteDefinitions</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">        <span class="keyword">return</span> serviceInstances.filter(instances -&gt; !instances.isEmpty())</span><br><span class="line">                .map(instances -&gt; instances.get(<span class="number">0</span>)).filter(includePredicate)</span><br><span class="line">                .map(instance -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 1. 获取服务名</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">serviceId</span> <span class="operator">=</span> instance.getServiceId();</span><br><span class="line"></span><br><span class="line">                    <span class="type">RouteDefinition</span> <span class="variable">routeDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RouteDefinition</span>();</span><br><span class="line">                    routeDefinition.setId(<span class="built_in">this</span>.routeIdPrefix + serviceId);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> urlExpr.getValue(evalCtxt, instance, String.class);</span><br><span class="line">                    routeDefinition.setUri(URI.create(uri));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">ServiceInstance</span> <span class="variable">instanceForEval</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegatingServiceInstance</span>(instance, properties);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 2. 获取 GatewayDiscoveryClientAutoConfiguration 初始化的默认 Predicate</span></span><br><span class="line">                    <span class="keyword">for</span> (PredicateDefinition original : <span class="built_in">this</span>.properties.getPredicates()) &#123;</span><br><span class="line">                        <span class="comment">// 3. 为服务初始化它自己的 Predicate 定义. 包括路由规则</span></span><br><span class="line">                        <span class="type">PredicateDefinition</span> <span class="variable">predicate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PredicateDefinition</span>();</span><br><span class="line">                        predicate.setName(original.getName());</span><br><span class="line">                        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : original.getArgs().entrySet()) &#123;</span><br><span class="line">                            <span class="comment">// 将 &#x27;/&#x27;+serviceId+&#x27;/**&#x27; 表达式替换成真正的路由规则</span></span><br><span class="line">                            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> parser.parseExpression(entry.getValue()).getValue(evalCtxt, instanceForEval, String.class);</span><br><span class="line">                            predicate.addArg(entry.getKey(), value);</span><br><span class="line">                        &#125;</span><br><span class="line">                        routeDefinition.getPredicates().add(predicate);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> routeDefinition;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="genkey-0是从哪来的"><a href="#genkey-0是从哪来的" class="headerlink" title="_genkey_0是从哪来的?"></a>_genkey_0是从哪来的?</h2><p>在上面的源码分析里已经看到了<code>pattern</code>这个<code>key</code>是从哪里生成的了.<br>但是为什么还有一个<code>_genkey_0</code>呢?</p><p>因为如果是手动在配置文件里面配置服务的话, <code>gateway</code>会自动生成<code>key</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.cloud.gateway.support.NameUtils</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NameUtils</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GENERATED_NAME_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;_genkey_&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateName</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> GENERATED_NAME_PREFIX + i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.springframework.cloud.gateway.handler.predicate.PredicateDefinition</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PredicateDefinition</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PredicateDefinition</span><span class="params">(String text)</span> &#123; <span class="comment">// 解析配置文件里的规则, 如 Path=/api/**</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">eqIdx</span> <span class="operator">=</span> text.indexOf(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (eqIdx &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ValidationException</span>(<span class="string">&quot;Unable to parse PredicateDefinition text &#x27;&quot;</span> + text + <span class="string">&quot;&#x27;&quot;</span> + <span class="string">&quot;, must be of the form name=value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setName(text.substring(<span class="number">0</span>, eqIdx));</span><br><span class="line"></span><br><span class="line">        String[] args = tokenizeToStringArray(text.substring(eqIdx + <span class="number">1</span>), <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 注意这里</span></span><br><span class="line">            <span class="built_in">this</span>.args.put(NameUtils.generateName(i), args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这, 你就会发现, 我写的代码其实有一个问题, 如果配置文件里有多个<code>predicate</code>.<br>那么一定要保证<code>Path</code>是第<code>0</code>个, 否则就获取不到路由规则. 目前也没想到什么好办法, 就这样将就用吧.</p><h2 id="服务id特别长怎么办"><a href="#服务id特别长怎么办" class="headerlink" title="服务id特别长怎么办"></a>服务id特别长怎么办</h2><p>有的同学会发现, 注册中心生成的服务<code>id</code>特别长, 不美观.<br><del>我只想安安静静做一个美男子</del><br>我只想要显示服务名, 可以把前缀都去掉吗?</p><img data-src="/images/SpringCloudGateway%E8%81%9A%E5%90%88swagger3_01.png" class=""><p>答案是不行.<br>在配置文件中加入配置项<code>spring.cloud.gateway.discovery.locator.route-id-prefix: &quot;你想要的前缀&quot;</code>即可.<br>但是不能填空字符串.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.cloud.gateway.discovery.DiscoveryClientRouteDefinitionLocator</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscoveryClientRouteDefinitionLocator</span> <span class="keyword">implements</span> <span class="title class_">RouteDefinitionLocator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DiscoveryClientRouteDefinitionLocator</span><span class="params">(String discoveryClientName, DiscoveryLocatorProperties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">        <span class="comment">// 如果判断是空字符串, 就用默认的前缀了</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(properties.getRouteIdPrefix())) &#123;</span><br><span class="line">            routeIdPrefix = properties.getRouteIdPrefix();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 默认的 discoveryClientName 是 discoveryClient.getClass().getSimpleName()</span></span><br><span class="line">            routeIdPrefix = discoveryClientName + <span class="string">&quot;_&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        evalCtxt = SimpleEvaluationContext.forReadOnlyDataBinding().withInstanceMethods().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实际的例子可以看我在<code>github</code>上的项目<a href="https://github.com/Ahaochan/project/tree/master/ahao-spring-cloud-gateway"><code>ahao-spring-cloud-gateway</code></a></p>]]></content:encoded>
      
      
      <category domain="https://blog.ahao.moe/categories/Spring-Cloud/">Spring Cloud</category>
      
      
      <category domain="https://blog.ahao.moe/tags/Spring-Cloud/">Spring Cloud</category>
      
      
      <comments>https://blog.ahao.moe/posts/integrate_swagger_3_in_spring_cloud_gateway.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JVM垃圾收集简介</title>
      <link>https://blog.ahao.moe/posts/garbage_collection_of_jvm.html</link>
      <guid>https://blog.ahao.moe/posts/garbage_collection_of_jvm.html</guid>
      <pubDate>Sun, 24 Jan 2021 14:25:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;相比于&lt;code&gt;C/C++&lt;/code&gt;最大的不同是不用手动进行管理内存, 这一特性得益于&lt;code&gt;Java&lt;/code&gt;的自动回收内存机制.&lt;br&gt;这一回收动作称为&lt;code&gt;Garbage Collection&lt;/code&gt;垃圾收集, 也就是&lt;code&gt;GC&lt;/code&gt;. 由此延伸出了垃圾收集算法, 垃圾收集器等.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Java</code>相比于<code>C/C++</code>最大的不同是不用手动进行管理内存, 这一特性得益于<code>Java</code>的自动回收内存机制.<br>这一回收动作称为<code>Garbage Collection</code>垃圾收集, 也就是<code>GC</code>. 由此延伸出了垃圾收集算法, 垃圾收集器等.</p><span id="more"></span><h1 id="如何判断一个对象可以回收"><a href="#如何判断一个对象可以回收" class="headerlink" title="如何判断一个对象可以回收"></a>如何判断一个对象可以回收</h1><p>我们判断一个对象<code>obj</code>是否可以回收, 一般是通过判断是否有其他对象对这个<code>obj</code>还持有引用. 如果没有, 这个<code>obj</code>就是可以回收的对象. 使用到的算法, 就是垃圾收集算法.</p><p>垃圾收集算法主要有两种</p><ol><li>引用计数算法</li><li>可达性分析算法</li></ol><h2 id="引用计数算法（不使用）"><a href="#引用计数算法（不使用）" class="headerlink" title="引用计数算法（不使用）"></a>引用计数算法（不使用）</h2><p>最简单高效的方法, 是在对象中添加一个计数器, 比如一个<code>count</code>字段, 有对象持有对它的引用则加一, 有对象失去对它的引用则减一.<br>只要计数器为<code>0</code>则说明没有其他对象引用它. 那么就可以对它进行垃圾回收.</p><p>但是目前主流的<code>Java</code>虚拟机都没有使用引用计数算法. 这个算法看似简单的背后, 要配合大量额外处理才能保证正常工作.<br>比如对象间相互循环引用的问题, 就不能简单使用引用计数算法来解决.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        a.val = b;</span><br><span class="line">        b.val = a;</span><br><span class="line">        </span><br><span class="line">        a = <span class="literal">null</span>;</span><br><span class="line">        b = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        System.gc(); <span class="comment">// a 和 b 不能被回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按引用计数算法的逻辑, 对象<code>a</code>和<code>b</code>各自的引用计数器的值都是<code>1</code>, 不能被回收.<br>但是外界已经没有对这两个对象的引用了, 按正常逻辑来说, 应该是可以被回收的.</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>所以, 主流的<code>JVM</code>还是使用可达性分析算法来判断对象是否可以被垃圾回收的. 涉及到图论相关知识.<br>基本思路就是通过一系列被称为<code>GC Roots</code>的跟对象作为起始节点, 从这些节点根据引用关系向下搜索, 搜索走过的路径称为<strong>引用链</strong>.<br>如果某个对象没有经过这个<strong>引用链</strong>, 那么就说明此对象可以被回收.<br>即使是循环引用的两个对象<code>DE</code>, 它们都没有经过<strong>引用链</strong>, 也可以被回收.<br><img data-src="https://yuml.me/diagram/nofunky;dir:UD/class/[GC%20Roots]-%3E[A],[GC%20Roots]-%3E[B],[B]-%3E[C],[D]-%3E[E],[E]-%3E[D]" alt="可达性分析算法"></p><h1 id="常见垃圾收集算法"><a href="#常见垃圾收集算法" class="headerlink" title="常见垃圾收集算法"></a>常见垃圾收集算法</h1><p>说到垃圾收集, 就不得不说到分代收集这个概念.<br><code>JVM</code>中大部分的对象都是朝生夕灭的, 当一个对象经历了多次<code>GC</code>还没有被回收, 就说明它是一个很难被回收的对象. 根据对象经过<code>GC</code>的次数, 将堆划分为新生代和老年代, 以此来使用不同的垃圾收集算法。</p><p>但是也有些收集器是不按分代收集的, 比如<code>G1</code>收集器是按一块一块的区域收集的.</p><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>标记-清除算法是最早出现的最基础的垃圾收集算法.<br>它主要是通过可达性分析算法, 标记出所有需要回收的对象, 然后做垃圾回收.<br>但它有两个缺点</p><ol><li>执行效率不稳定, 对象越多, 标记清除花费的时间越多</li><li>内存碎片化问题, 下次分配大内存对象的时候找不到足够连续大的内存空间导致提前进行垃圾回收<img data-src="/images/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%80%E4%BB%8B_01.png" class=""></li></ol><h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h2><p>标记-清除算法会出现内存碎片化的问题, 要解决内存碎片化的问题, 就需要对内存碎片进行整理. 标记-复制算法用了巧妙的方式, 用复制的方法避过了整理.<br>原理是将<strong>新生代</strong>内存空间划分为一个<code>Eden</code>区和两个<code>Survivor</code>区, 默认比例是<code>8:1:1</code>,<br>每次<code>GC</code>的时候, 会把<code>Eden</code>区和其中一块<code>Survivor</code>区做垃圾回收, 存活的对象复制到另一块未使用的<code>Survivor</code>区. 每次存活下来的对象年龄会加一, 到达一定年龄, 就复制到老年代去.</p><img data-src="/images/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%80%E4%BB%8B_02.png" class=""><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>标记-清除算法如果每次<code>GC</code>时存活的对象越多, 进行复制的成本也越高, 那就还不如直接进行内存整理了.</p><img data-src="/images/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%80%E4%BB%8B_03.png" class=""><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>从上面的垃圾收集算法, 可以知道, 根据不同分代的垃圾特性, 需要使用不同的垃圾收集算法, 也需要使用不同垃圾收集器.</p><p>下面简单列了一些收集器的特点</p><table><thead><tr><th align="center">垃圾收集器</th><th align="center">新生代</th><th align="center">老年代</th><th align="center">并行</th><th align="center">垃圾收集算法</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center"><code>Serial</code></td><td align="center">√</td><td align="center"></td><td align="center">单线程</td><td align="center">复制</td><td align="center">单核下效率最高</td></tr><tr><td align="center"><code>ParNew</code></td><td align="center">√</td><td align="center"></td><td align="center">多线程</td><td align="center">复制</td><td align="center"><code>Serial</code>多线程版本, 和<code>CMS</code>是官配</td></tr><tr><td align="center"><code>Parallel Scavenge</code></td><td align="center">√</td><td align="center"></td><td align="center">多线程</td><td align="center">复制</td><td align="center">吞吐量优先</td></tr><tr><td align="center"><code>Serial Old</code></td><td align="center"></td><td align="center">√</td><td align="center">单线程</td><td align="center">复制</td><td align="center"><code>Serial</code>老年代版本</td></tr><tr><td align="center"><code>Parallel Old</code></td><td align="center"></td><td align="center">√</td><td align="center">多线程</td><td align="center">整理</td><td align="center"><code>Parallel Scavenge</code>老年代版本</td></tr><tr><td align="center"><code>CMS</code></td><td align="center"></td><td align="center">√</td><td align="center">并发多线程</td><td align="center">清除</td><td align="center">尽量少停顿时间</td></tr><tr><td align="center"><code>G1</code></td><td align="center">√</td><td align="center">√</td><td align="center">并发多线程</td><td align="center">分区回收</td><td align="center">大内存无脑上</td></tr></tbody></table><p>各个分代间的垃圾收集器搭配</p><table><thead><tr><th align="center">老年代/年轻代</th><th align="center"><code>Serial</code></th><th align="center"><code>ParNew</code></th><th align="center"><code>Parallel Scavenge</code></th></tr></thead><tbody><tr><td align="center"><code>Serial Old</code></td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center"><code>Parallel Old</code></td><td align="center"></td><td align="center"></td><td align="center">√</td></tr><tr><td align="center"><code>CMS</code></td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr></tbody></table><p><code>Serial + Serial Old</code>是低配置服务端的解决方案.<br><code>ParNew + CMS</code> 是<code>JDK9</code>之前官方推荐的服务端模式下的收集器解决方案.<br><code>Parallel Scavenge + Parallel Old</code>是吞吐量优先的组合, 应用在处理器资源比较稀缺的场合.<br><code>G1</code>是超大堆的首选, 遇到超大堆就直接选<code>G1</code>.</p><h2 id="CMS-垃圾收集器"><a href="#CMS-垃圾收集器" class="headerlink" title="CMS 垃圾收集器"></a>CMS 垃圾收集器</h2><p><code>CMS</code>垃圾收集器是在老年代使用标记清除算法进行垃圾回收的, 一种以获取最短回收停顿时间为目标的收集器.</p><p>回收步骤如下</p><ol><li>初始标记, 只标记<code>GC Roots</code>的直接关联对象, 会发生<code>Stop the world</code></li><li>并发标记, 和用户线程并发执行, 用来遍历整个对象图</li><li>重新标记, 修正因为用户线程运行导致的引用变动, 也会发生<code>Stop the world</code></li><li>并发清除, 和用户线程并发执行, 因为不用去移动存活对象.</li></ol><p><code>ParNew + CMS</code> 是<code>JDK9</code>之前官方推荐的服务端模式下的收集器解决方案.</p><h2 id="G1-垃圾收集器"><a href="#G1-垃圾收集器" class="headerlink" title="G1 垃圾收集器"></a>G1 垃圾收集器</h2><p><code>Garbage First</code>简称<code>G1</code>, 不再使用分代收集策略, 是一个面向全堆收集的垃圾收集器.<br>将全堆内存划分为一块一块的<code>Region</code>区域, 然后根据每块<code>Region</code>区域的价值(有点类似背包问题), 进行垃圾回收, 从而做到<code>GC</code>时间可控制.</p><p>用于在超大内存下, 替换<code>ParNew + CMS</code>组合的收集器方案.</p>]]></content:encoded>
      
      
      <category domain="https://blog.ahao.moe/categories/Java/">Java</category>
      
      
      <category domain="https://blog.ahao.moe/tags/JVM/">JVM</category>
      
      
      <comments>https://blog.ahao.moe/posts/garbage_collection_of_jvm.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Feign 源码分析之初始化和执行</title>
      <link>https://blog.ahao.moe/posts/source_code_of_feign_and_init_and_execute.html</link>
      <guid>https://blog.ahao.moe/posts/source_code_of_feign_and_init_and_execute.html</guid>
      <pubDate>Fri, 22 Jan 2021 10:29:15 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Feign&lt;/code&gt;是一个面向对象的&lt;code&gt;http&lt;/code&gt;客户端, 这里主要介绍&lt;code&gt;Feign&lt;/code&gt;是如何初始化的, 并如何进行&lt;code&gt;http&lt;/code&gt;请求的.&lt;br&gt;省略部分不重要的代码. 剥离了&lt;code&gt;hystrix&lt;/code&gt;和&lt;code&gt;ribbon&lt;/code&gt;的相关逻辑.&lt;br&gt;读完这篇源码解析, 之前写的**&lt;code&gt;SpringCloud-Feign&lt;/code&gt;之重复出现的&lt;code&gt;FeignClientSpecification&lt;/code&gt;**也可以再复习下.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Feign</code>是一个面向对象的<code>http</code>客户端, 这里主要介绍<code>Feign</code>是如何初始化的, 并如何进行<code>http</code>请求的.<br>省略部分不重要的代码. 剥离了<code>hystrix</code>和<code>ribbon</code>的相关逻辑.<br>读完这篇源码解析, 之前写的**<code>SpringCloud-Feign</code>之重复出现的<code>FeignClientSpecification</code>**也可以再复习下.</p><span id="more"></span><h1 id="FeignClientsRegistrar-创建-FactoryBean"><a href="#FeignClientsRegistrar-创建-FactoryBean" class="headerlink" title="FeignClientsRegistrar 创建 FactoryBean"></a>FeignClientsRegistrar 创建 FactoryBean</h1><p>要启用<code>Feign</code>, 首先要使用<code>@EnableFeignClients</code>注解.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(FeignClientsRegistrar.class)</span> <span class="comment">// 引入 FeignClientsRegistrar</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableFeignClients &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@EnableFeignClients</code>注解引入了<code>FeignClientsRegistrar</code>, 类实现了<code>ImportBeanDefinitionRegistrar</code>接口, 然后重写了<code>registerBeanDefinitions</code>方法.<br>说明加入到了<code>Spring</code>生命周期的管理中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.cloud.openfeign.FeignClientsRegistrar</span></span><br><span class="line"><span class="comment">// 实现了 ImportBeanDefinitionRegistrar 接口, 注册到 Spring 生命周期中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FeignClientsRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span>, ResourceLoaderAware, EnvironmentAware &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 将声明了 @EnableFeignClients 的类, 注册到名为 default.配置类名.FeignClientSpecification 的 FeignClientSpecification 实例中</span></span><br><span class="line">        registerDefaultConfiguration(metadata, registry);</span><br><span class="line">        <span class="comment">// 2. 创建 FeignClientFactoryBean 注入到 Spring 容器中</span></span><br><span class="line">        registerFeignClients(metadata, registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>registerBeanDefinitions</code>方法主要做了两件事</p><ol><li>将声明了<code>@EnableFeignClients</code>的类, 注册到一个新的<code>FeignClientSpecification</code>实例<code>Bean</code>中. 作为默认<code>Feign</code>配置.</li><li>将<code>@EnableFeignClients</code>的声明的包下的所有<code>@FeignClient</code>修饰的接口, 注册到新的<code>FeignClientFactoryBean</code>工厂中, 用于创建<code>JDK</code>动态代理.</li></ol><h2 id="registerDefaultConfiguration-注册默认配置"><a href="#registerDefaultConfiguration-注册默认配置" class="headerlink" title="registerDefaultConfiguration 注册默认配置"></a>registerDefaultConfiguration 注册默认配置</h2><p>第一行语句注册了一个名为<code>default.配置类名.FeignClientSpecification</code>的<code>FeignClientSpecification</code>实例为<code>Bean</code>.<br>作为之后创建的<code>Feign</code>动态代理的默认配置.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.cloud.openfeign.FeignClientsRegistrar</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FeignClientsRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span>, ResourceLoaderAware, EnvironmentAware &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerDefaultConfiguration</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取 EnableFeignClients 中的属性</span></span><br><span class="line">        Map&lt;String, Object&gt; defaultAttrs = metadata.getAnnotationAttributes(EnableFeignClients.class.getName(), <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (defaultAttrs != <span class="literal">null</span> &amp;&amp; defaultAttrs.containsKey(<span class="string">&quot;defaultConfiguration&quot;</span>)) &#123; <span class="comment">// 永远为 true</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;default.&quot;</span> + metadata.getClassName();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 注册一个 default.类名.FeignClientSpecification 的 Bean, 作为默认Feign配置</span></span><br><span class="line">            <span class="type">BeanDefinitionBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(FeignClientSpecification.class);</span><br><span class="line">            builder.addConstructorArgValue(name);</span><br><span class="line">            builder.addConstructorArgValue(configuration);</span><br><span class="line">            registry.registerBeanDefinition(name + <span class="string">&quot;.&quot;</span> + FeignClientSpecification.class.getSimpleName(), builder.getBeanDefinition());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="registerFeignClients-注册-FactoryBean"><a href="#registerFeignClients-注册-FactoryBean" class="headerlink" title="registerFeignClients 注册 FactoryBean"></a>registerFeignClients 注册 FactoryBean</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.cloud.openfeign.FeignClientsRegistrar</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FeignClientsRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span>, ResourceLoaderAware, EnvironmentAware &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerFeignClients</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathScanningCandidateComponentProvider</span> <span class="variable">scanner</span> <span class="operator">=</span> getScanner();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 根据 @EnableFeignClients 的 clients 属性或者 value、basePackages、basePackageClasses 属性初始化 basePackages 变量</span></span><br><span class="line">        Map&lt;String, Object&gt; attrs = metadata.getAnnotationAttributes(EnableFeignClients.class.getName());</span><br><span class="line">        Class&lt;?&gt;[] clients = attrs.get(<span class="string">&quot;clients&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; basePackages;</span><br><span class="line">        <span class="keyword">if</span> (clients == <span class="literal">null</span> || clients.length == <span class="number">0</span>) &#123;</span><br><span class="line">            scanner.addIncludeFilter(annotationTypeFilter); <span class="comment">// scanner 的过滤器, 只扫描 @FeignClient 注解修饰的类</span></span><br><span class="line">            <span class="comment">// 1.1. 将 value、basePackages、basePackageClasses 属性的包名做并集, 如果都为空, 那就取配置类所在的包名</span></span><br><span class="line">            basePackages = getBasePackages(metadata);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 1.2. 将 clients 中的类的包名加入 basePackages, 并且 scanner 只扫描 clients 中的类以及 @FeignClient 注解修饰的类</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 扫描 basePackage 包下的所有被 @FeignClient 注解修饰的接口</span></span><br><span class="line">        <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">            Set&lt;BeanDefinition&gt; candidateComponents = scanner.findCandidateComponents(basePackage);</span><br><span class="line">            <span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">                <span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                    <span class="comment">// 2.1. 校验是否是接口</span></span><br><span class="line">                    <span class="type">AnnotatedBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">                    <span class="type">AnnotationMetadata</span> <span class="variable">annotationMetadata</span> <span class="operator">=</span> beanDefinition.getMetadata();</span><br><span class="line">                    Assert.isTrue(annotationMetadata.isInterface(), <span class="string">&quot;@FeignClient can only be specified on an interface&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 2.2. 获取 FeignClient 的参数</span></span><br><span class="line">                    Map&lt;String, Object&gt; attributes = annotationMetadata.getAnnotationAttributes(FeignClient.class.getCanonicalName());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 2.3. 按 contextId、value、name、serviceId 的优先级顺序获取 name, 用来做下面 bean name 的前缀</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> getClientName(attributes);</span><br><span class="line">                    <span class="comment">// 2.4. 将 @FeignClient 的 configuration 属性中的类, 注册为 FeignClientSpecification 类的实例 Bean</span></span><br><span class="line">                    registerClientConfiguration(registry, name, attributes.get(<span class="string">&quot;configuration&quot;</span>));</span><br><span class="line">                    <span class="comment">// 2.5. 根据 @FeignClient 的属性, 注册 FeignClientFactoryBean 类的实例 Bean</span></span><br><span class="line">                    <span class="comment">//      Bean 名称规则为, 按 contextId、serviceId、name、value 的优先级顺序获取 name, 后面加上 FeignClient 字符串</span></span><br><span class="line">                    registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="FeignClientFactoryBean-创建-JDK-动态代理"><a href="#FeignClientFactoryBean-创建-JDK-动态代理" class="headerlink" title="FeignClientFactoryBean 创建 JDK 动态代理"></a>FeignClientFactoryBean 创建 JDK 动态代理</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.cloud.openfeign.FeignClientFactoryBean</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FeignClientFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Object&gt;, InitializingBean, ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> getTarget();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T <span class="title function_">getTarget</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 初始化 FeignAutoConfiguration 中的 FeignContext, 将刚才声明的一堆 FeignClientSpecification 注入到 FeignContext 中</span></span><br><span class="line">        <span class="type">FeignContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationContext.getBean(FeignContext.class);</span><br><span class="line">        <span class="comment">// 2. 根据 @FeignClient 里的 configuration 配置, 获取 builder</span></span><br><span class="line">        Feign.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> feign(context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 如果 @FeignClient 没有配置 url, 就用 ribbon 做负载均衡</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(<span class="built_in">this</span>.url)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) loadBalance(builder, context, <span class="keyword">new</span> <span class="title class_">HardCodedTarget</span>&lt;&gt;(<span class="built_in">this</span>.type, <span class="built_in">this</span>.name, <span class="built_in">this</span>.url));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 生成 @FeignClient 接口的 JDK 代理实现, 这里返回的是 ReflectiveFeign$FeignInvocationHandler 类的 JDK 动态代理</span></span><br><span class="line">        <span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> getOptional(context, Client.class);</span><br><span class="line">        <span class="keyword">if</span> (client != <span class="literal">null</span>) &#123;</span><br><span class="line">            builder.client(client);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5. 最终是调用 ReflectiveFeign 的 newInstance 方法, 创建 FeignInvocationHandler 的 JDK 动态代理</span></span><br><span class="line">        <span class="type">Targeter</span> <span class="variable">targeter</span> <span class="operator">=</span> get(context, Targeter.class);</span><br><span class="line">        <span class="keyword">return</span> (T) targeter.target(<span class="built_in">this</span>, builder, context, <span class="keyword">new</span> <span class="title class_">HardCodedTarget</span>&lt;&gt;(<span class="built_in">this</span>.type, <span class="built_in">this</span>.name, url));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// feign.ReflectiveFeign</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectiveFeign</span> <span class="keyword">extends</span> <span class="title class_">Feign</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">newInstance</span><span class="params">(Target&lt;T&gt; target)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 根据方法初始化 MethodHandler 实例, 内部封装执行 http 请求的代码, 执行时根据 method 路由</span></span><br><span class="line">        Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;Method, MethodHandler&gt;();</span><br><span class="line">        <span class="comment">// 2. 创建 FeignInvocationHandler 动态代理</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> factory.create(target, methodToHandler);</span><br><span class="line">        <span class="type">T</span> <span class="variable">proxy</span> <span class="operator">=</span> (T) Proxy.newProxyInstance(target.type().getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123;target.type()&#125;, handler);</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FeignInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            <span class="comment">// 根据 method 路由到 MethodHandler 中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化完毕后, 就可以<code>@Autowired</code>声明的<code>Feign</code>接口了.</p><h1 id="Feign-调用"><a href="#Feign-调用" class="headerlink" title="Feign 调用"></a>Feign 调用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// feign.ReflectiveFeign</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectiveFeign</span> <span class="keyword">extends</span> <span class="title class_">Feign</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FeignInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MethodHandler&gt; dispatch;</span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dispatch.get(method).invoke(args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// feign.SynchronousMethodHandler</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SynchronousMethodHandler</span> <span class="keyword">implements</span> <span class="title class_">MethodHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 1. 用原型模式, 构造 http 请求客户端</span></span><br><span class="line">        <span class="type">RequestTemplate</span> <span class="variable">template</span> <span class="operator">=</span> buildTemplateFromArgs.create(argv);</span><br><span class="line">        <span class="comment">// 2. 如果参数中没有 Options, 就返回默认的 Options </span></span><br><span class="line">        <span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> findOptions(argv);</span><br><span class="line">        <span class="comment">// 3. FeignClientsConfiguration 会初始化一个默认的 Retryer.NEVER_RETRY</span></span><br><span class="line">        <span class="type">Retryer</span> <span class="variable">retryer</span> <span class="operator">=</span> <span class="built_in">this</span>.retryer.clone();</span><br><span class="line">        <span class="comment">// 4. while 是为了做重试</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 5. 业务请求</span></span><br><span class="line">                <span class="keyword">return</span> executeAndDecode(template, options);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RetryableException e) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    retryer.continueOrPropagate(e);  <span class="comment">// 重试策略</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RetryableException th) &#123;</span><br><span class="line">                    <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> th.getCause();</span><br><span class="line">                    <span class="keyword">if</span> (propagationPolicy == UNWRAP &amp;&amp; cause != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> cause; <span class="comment">// 中断重试</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">throw</span> th; <span class="comment">// 中断重试</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">                    logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的时候会根据<code>method</code>路由到各自的<code>MethodHandler</code>中.<br>然后<code>MethodHandler</code>会创建新的<code>http</code>客户端, 进行请求操作, 失败的时候做重试.</p><h1 id="executeAndDecode-执行http请求并解码响应体"><a href="#executeAndDecode-执行http请求并解码响应体" class="headerlink" title="executeAndDecode 执行http请求并解码响应体"></a>executeAndDecode 执行http请求并解码响应体</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// feign.SynchronousMethodHandler</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SynchronousMethodHandler</span> <span class="keyword">implements</span> <span class="title class_">MethodHandler</span> &#123;</span><br><span class="line">    Object <span class="title function_">executeAndDecode</span><span class="params">(RequestTemplate template, Options options)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 1. 经过拦截器处理, 根据 template 创建出 Request 对象</span></span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> targetRequest(template);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 真正发起 http 请求</span></span><br><span class="line">        Response response;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 默认是使用 HttpURLConnection 连接, 可以自己实现 Client 接口并注册为 Bean</span></span><br><span class="line">            response = client.execute(request, options);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> errorExecuting(request, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 解析 http 响应体</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3.1. 如果方法声明返回体是 Response 就直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (Response.class == metadata.returnType()) &#123;</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3.2. 如果状态码是 200 或者 404 就解码</span></span><br><span class="line">            <span class="keyword">if</span> (response.status() &gt;= <span class="number">200</span> &amp;&amp; response.status() &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> decoder.decode(response, metadata.returnType());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (decode404 &amp;&amp; response.status() == <span class="number">404</span> &amp;&amp; <span class="keyword">void</span>.class != metadata.returnType()) &#123;</span><br><span class="line">                <span class="keyword">return</span> decoder.decode(response, metadata.returnType());</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 3.3. 否则使用错误解码器</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> errorDecoder.decode(metadata.configKey(), response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 3.3. 然后跑出异常</span></span><br><span class="line">            <span class="keyword">throw</span> errorReading(request, response, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ensureClosed(response.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拦截器的注入时机"><a href="#拦截器的注入时机" class="headerlink" title="拦截器的注入时机"></a>拦截器的注入时机</h2><p>拦截器是在创建<code>Feign.Builder</code>时初始化的, 具体代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.cloud.openfeign.FeignClientFactoryBean#configureFeign</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FeignClientFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Object&gt;, InitializingBean, ApplicationContextAware &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configureFeign</span><span class="params">(FeignContext context, Feign.Builder builder)</span> &#123;</span><br><span class="line">        <span class="type">FeignClientProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationContext.getBean(FeignClientProperties.class);</span><br><span class="line">        <span class="comment">// FeignAutoConfiguration 里注入了, 必定为 true</span></span><br><span class="line">        <span class="keyword">if</span> (properties != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 默认也是 true, 这里主要是配置优先级不同</span></span><br><span class="line">            <span class="keyword">if</span> (properties.isDefaultToProperties()) &#123;</span><br><span class="line">                configureUsingConfiguration(context, builder);</span><br><span class="line">                <span class="comment">// @EnableFeignClients#defaultConfiguration 自定义全局默认配置</span></span><br><span class="line">                configureUsingProperties(properties.getConfig().get(properties.getDefaultConfig()), builder);</span><br><span class="line">                <span class="comment">// @FeignClient#configuration 单个Feign接口局部配置</span></span><br><span class="line">                configureUsingProperties(properties.getConfig().get(<span class="built_in">this</span>.contextId), builder);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// @EnableFeignClients#defaultConfiguration 自定义全局默认配置</span></span><br><span class="line">                configureUsingProperties(properties.getConfig().get(properties.getDefaultConfig()), builder);</span><br><span class="line">                <span class="comment">// @FeignClient#configuration 单个Feign接口局部配置</span></span><br><span class="line">                configureUsingProperties(properties.getConfig().get(<span class="built_in">this</span>.contextId), builder);</span><br><span class="line">                <span class="comment">// 去 Spring 容器中找配置</span></span><br><span class="line">                configureUsingConfiguration(context, builder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 去 Spring 容器中找配置</span></span><br><span class="line">            configureUsingConfiguration(context, builder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下, <code>Feign</code>会依次从<code>Spring</code>容器、<code>@EnableFeignClients#defaultConfiguration</code>、<code>@FeignClient#configuration</code>寻找相关配置.<br>值得注意的一点是, 不要将<code>@EnableFeignClients#defaultConfiguration</code>、<code>@FeignClient#configuration</code>的配置声明为<code>Bean</code>.<br>因为<code>Feign</code>已经将配置注册到<code>FeignClientSpecification</code>类的实例<code>Bean</code>中了. 在上面也有提到.</p><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img data-src="https://yuml.me/diagram/nofunky;dir:UD/class/[@EnableFeignClients]-%3E[FeignClientsRegistrar],[FeignClientsRegistrar]-%3E[FeignClientFactoryBean],[FeignClientFactoryBean]-%3E[ReflectiveFeign$FeignInvocationHandler]" alt="feign流程"></p>]]></content:encoded>
      
      
      <category domain="https://blog.ahao.moe/categories/Spring-Cloud/">Spring Cloud</category>
      
      
      <category domain="https://blog.ahao.moe/tags/Feign/">Feign</category>
      
      <category domain="https://blog.ahao.moe/tags/Spring-Cloud/">Spring Cloud</category>
      
      
      <comments>https://blog.ahao.moe/posts/source_code_of_feign_and_init_and_execute.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Apache Bench使用</title>
      <link>https://blog.ahao.moe/posts/How_to_use_Apache_Bench.html</link>
      <guid>https://blog.ahao.moe/posts/How_to_use_Apache_Bench.html</guid>
      <pubDate>Tue, 03 Nov 2020 03:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Apache Bench&lt;/code&gt;简称&lt;code&gt;ab&lt;/code&gt;工具, 是一款简单方便的测试工具.&lt;br&gt;安装方式&lt;/p</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>Apache Bench</code>简称<code>ab</code>工具, 是一款简单方便的测试工具.<br>安装方式</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install httpd-tools</span><br><span class="line">apt -y install apache2-utils</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>使用方式: <code>ab [options] [http[s]://]hostname[:port]/path</code><br>常用选项</p><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>-n</code></td><td align="center">总请求次数, 最小默认为<code>1</code></td></tr><tr><td align="center"><code>-c</code></td><td align="center">并发次数, 最小默认为<code>1</code>, 且不能大于总请求次数. 例如, <code>10</code>个请求, <code>10</code>个并发，实际就是<code>1</code>人请求<code>1</code>次</td></tr><tr><td align="center"><code>-p</code></td><td align="center"><code>post</code> 参数文档路径（-p 和 -T 参数要配合使用）</td></tr><tr><td align="center"><code>-T</code></td><td align="center"><code>header</code>头内容类型</td></tr></tbody></table><h1 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a>分析结果</h1><p>我们简单的对百度做个压测, <code>20</code>个用户同时发起请求, 总共请求<code>1000</code>次.</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -n 1000 -c 20 &quot;https://www.baidu.com/s?wd=test&quot;</span><br></pre></td></tr></table></figure><p>结果马上就出来了, 我们主要看以下几个参数</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">完成所有请求花费的时间</span></span><br><span class="line">Time taken for tests:   5.058 seconds</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">吞吐率，指某个并发用户数下单位时间内处理的请求数</span></span><br><span class="line">Requests per second:    197.72 [#/sec] (mean)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户平均请求等待时间 = 完成所有请求花费的时间 / (总请求数 / 并发用户数)</span></span><br><span class="line">Time per request:       101.155 [ms] (mean)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务器平均请求处理时间 = 完成所有请求花费的时间 / 总请求数</span></span><br><span class="line">Time per request:       5.058 [ms] (mean, across all concurrent requests)</span><br></pre></td></tr></table></figure><h1 id="常用例子"><a href="#常用例子" class="headerlink" title="常用例子"></a>常用例子</h1><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. get请求, 20个用户同时发起请求, 总共请求1000次</span></span><br><span class="line">ab -n 1000 -c 20 -H &quot;header1:value1&quot; -H &quot;header1:value1&quot; &quot;https://www.baidu.com/s?wd=test&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. post请求, 将 post.txt 的内容作为请求参数发送出去</span></span><br><span class="line">ab -n 1000 -c 10 -p post.txt -T &quot;application/x-www-form-urlencoded&quot; &quot;https://www.baidu.com/s?wd=test&quot;</span><br><span class="line">ab -n 1000 -c 10 -p post.txt -T &quot;application/json&quot; &quot;https://www.baidu.com/s?wd=test&quot;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://blog.ahao.moe/categories/%E6%B5%8B%E8%AF%95/">测试</category>
      
      
      <category domain="https://blog.ahao.moe/tags/Apache-Bench/">Apache Bench</category>
      
      
      <comments>https://blog.ahao.moe/posts/How_to_use_Apache_Bench.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring MVC同时支持驼峰和下划线</title>
      <link>https://blog.ahao.moe/posts/Support_both_snake_case_and_camelCase_in_Spring_MVC.html</link>
      <guid>https://blog.ahao.moe/posts/Support_both_snake_case_and_camelCase_in_Spring_MVC.html</guid>
      <pubDate>Fri, 31 Jul 2020 10:44:03 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;PHP&lt;/code&gt;是下划线命名变量, &lt;code&gt;Java&lt;/code&gt;是驼峰命名变量.&lt;br&gt;对于前端来说, 服务端有两种命名规则, 这是不合理的, 他们希望有一种统一的命名规则.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>PHP</code>是下划线命名变量, <code>Java</code>是驼峰命名变量.<br>对于前端来说, 服务端有两种命名规则, 这是不合理的, 他们希望有一种统一的命名规则.</p><span id="more"></span><h1 id="歪路1-用ObjectMapper在Controller层做转换"><a href="#歪路1-用ObjectMapper在Controller层做转换" class="headerlink" title="歪路1: 用ObjectMapper在Controller层做转换"></a>歪路1: 用ObjectMapper在Controller层做转换</h1><p>为了赶进度, 我直接在<code>Controller</code>层做了转换.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/post1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">post1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取数据</span></span><br><span class="line">        <span class="type">MyObj</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObj</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 创建一个 SNAKE_CASE 下划线风格的 ObjectMapper, 转为 Map</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> om.convertValue(result, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;Map&lt;String, Object&gt;&gt;() &#123;&#125;);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题迎刃而解, 简单粗暴.<br>但是这里有个待优化的地方</p><ol><li>每个方法都要写一套转换代码, 就算转成<code>AOP</code>的实现, 也不够优雅</li><li>每次都要<code>new ObjectMapper()</code>和转换.</li></ol><h1 id="歪路2-Hack-ResponseBody-处理器"><a href="#歪路2-Hack-ResponseBody-处理器" class="headerlink" title="歪路2: Hack @ResponseBody 处理器"></a>歪路2: Hack @ResponseBody 处理器</h1><p><code>Jackson</code>提供了一个<code>@JsonNaming</code>的注解, 用于修饰<code>POJO</code>的序列化命名方式.<br>但是这个<code>@JsonNaming</code>注解只能修饰在类上, 不能修饰在方法级别.</p><p>我们猜测, 可以创建一个<code>@MyJsonNaming</code>的注解, 仿照<code>@ResponseBody</code>处理器对返回体做处理.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/post2&quot;)</span></span><br><span class="line">    <span class="meta">@MyJsonNaming(PropertyNamingStrategy.SnakeCaseStrategy.class)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">post2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取数据</span></span><br><span class="line">        <span class="type">MyObj</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObj</span>();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看<code>Spring MVC</code>是怎么拦截<code>@ResponseBody</code>注解的?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestMappingHandlerAdapter</span> <span class="keyword">extends</span> <span class="title class_">AbstractHandlerMethodAdapter</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span>, InitializingBean &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 省略其他代码</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.returnValueHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里初始化一堆默认的返回值处理器, 其中就包括了 @ResponseBody 的处理器</span></span><br><span class="line">            List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();</span><br><span class="line">            <span class="built_in">this</span>.returnValueHandlers = <span class="keyword">new</span> <span class="title class_">HandlerMethodReturnValueHandlerComposite</span>().addHandlers(handlers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerMethodReturnValueHandler&gt; <span class="title function_">getDefaultReturnValueHandlers</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;HandlerMethodReturnValueHandler&gt; handlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 省略其他代码</span></span><br><span class="line">        handlers.add(<span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(getMessageConverters(), <span class="built_in">this</span>.contentNegotiationManager, <span class="built_in">this</span>.requestResponseBodyAdvice));</span><br><span class="line">        <span class="comment">// WebMvcConfigurer 自定义处理器</span></span><br><span class="line">        <span class="keyword">if</span> (getCustomReturnValueHandlers() != <span class="literal">null</span>) &#123;</span><br><span class="line">            handlers.addAll(getCustomReturnValueHandlers());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handlers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就有个问题了, 我通过实现<code>WebMvcConfigurer</code>自定义的处理器, 它的优先级永远比<code>RequestResponseBodyMethodProcessor</code>处理器的优先级要低.<br>也就是说, 我如果想使用<code>@MyJsonNaming</code>注解覆盖<code>@ResponseBody</code>的处理逻辑, 只能这样做.</p><ol><li>所有代码里, 不允许使用<code>@ResponseBody</code>和<code>@RestController</code>, 只允许使用<code>@MyJsonNaming</code>. 这是不可能也不允许的事情.</li><li>使用<code>BeanPostProcessor</code>调整<code>RequestMappingHandlerAdapter</code>的<code>HandlerMethodReturnValueHandler</code>列表顺序. 看起来可行, 但总感觉走了弯路.</li></ol><p>并且这样也有弊端, 如果同一个接口, 前端想用下划线的命名格式, 另一个<code>Java</code>服务想用驼峰的命名格式.<br>使用这种方式也实现不了.</p><h1 id="正解-使用Accept请求头决定响应体是驼峰还是下划线"><a href="#正解-使用Accept请求头决定响应体是驼峰还是下划线" class="headerlink" title="正解: 使用Accept请求头决定响应体是驼峰还是下划线"></a>正解: 使用Accept请求头决定响应体是驼峰还是下划线</h1><p>换个思路, <code>Spring MVC</code>是支持<code>xml</code>和<code>json</code>的返回格式的.<br><code>Spring MVC</code>里面是怎么做到同一套代码支持不同的返回格式的? 本质上我们这个需求也是不同的返回格式.<br>我们前面已经知道, <code>@ResponseBody</code>的处理类是<code>RequestResponseBodyMethodProcessor</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestResponseBodyMethodProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractMessageConverterMethodProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123;</span><br><span class="line">        <span class="comment">// 调用父类的方法</span></span><br><span class="line">        <span class="built_in">super</span>.writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractMessageConverterMethodProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractMessageConverterMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodReturnValueHandler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">writeWithMessageConverters</span><span class="params">(T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)</span> <span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123;</span><br><span class="line">        <span class="comment">// 省略其他代码</span></span><br><span class="line">        <span class="comment">// 1. 获取请求头的 Accept</span></span><br><span class="line">        <span class="type">MediaType</span> <span class="variable">selectedMediaType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 2. 遍历 messageConverters, 找到支持该 MediaType 的 HttpMessageConverter 实现</span></span><br><span class="line">        <span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="built_in">this</span>.messageConverters) &#123;</span><br><span class="line">            <span class="type">GenericHttpMessageConverter</span> <span class="variable">genericConverter</span> <span class="operator">=</span> (converter <span class="keyword">instanceof</span> GenericHttpMessageConverter ? (GenericHttpMessageConverter&lt;?&gt;) converter : <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (genericConverter != <span class="literal">null</span> ? ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (genericConverter != <span class="literal">null</span>) &#123;</span><br><span class="line">                   genericConverter.write(body, targetType, selectedMediaType, outputMessage);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);</span><br><span class="line">               &#125;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 注意这里!!! 匹配上就直接return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终请求头<code>Accept:application/json</code>会匹配到<code>MappingJackson2HttpMessageConverter</code>.<br>它支持<code>application/json</code>和<code>application/*+json</code>, 注意这个通配符, 它会导致下面我的自定义请求头失效.<br>因为 <code>HttpMessageConverter</code> 匹配到第一个就直接 <code>return</code> 了.</p><table><thead><tr><th align="center">请求头</th><th align="center">例子</th></tr></thead><tbody><tr><td align="center"><code>application/vnd.snake.case+json</code></td><td align="center"><code>my_name</code></td></tr><tr><td align="center"><code>application/vnd.upper.camel.case+json</code></td><td align="center"><code>MyName</code></td></tr><tr><td align="center"><code>application/vnd.lower.camel.case+json</code></td><td align="center"><code>myName</code></td></tr><tr><td align="center"><code>application/vnd.lower.case+json</code></td><td align="center"><code>myname</code></td></tr><tr><td align="center"><code>application/vnd.kebab+json</code></td><td align="center"><code>my-name</code></td></tr><tr><td align="center"><code>application/vnd.lower.dot+json</code></td><td align="center"><code>my.name</code></td></tr></tbody></table><p>所以我们要做几个事情</p><ol><li>修改原有的<code>MappingJackson2HttpMessageConverter</code>, 让它只支持<code>application/json</code></li><li>在原有的<code>MappingJackson2HttpMessageConverter</code>后面追加我的自定义请求体的<code>MessageConverter</code>实现类.</li><li>在最后添加一个处理<code>application/*+json</code>的兜底<code>MessageConverter</code>实现类.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/Ahaochan/ahao-common-utils/blob/master/src/main/java/com/ahao/spring/web/config/JacksonHttpMessageConvertersWebMvcConfigurer.java</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JacksonHttpMessageConvertersWebMvcConfigurer</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖 &#123;<span class="doctag">@link</span> JacksonHttpMessageConvertersConfiguration&#125; 的配置, 移除 application/*+json 的支持</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> JacksonHttpMessageConvertersConfiguration.MappingJackson2HttpMessageConverterConfiguration#mappingJackson2HttpMessageConverter(com.fasterxml.jackson.databind.ObjectMapper)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MappingJackson2HttpMessageConverter <span class="title function_">mappingJackson2HttpMessageConverter</span><span class="params">(ObjectMapper objectMapper)</span> &#123;</span><br><span class="line">        <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>(objectMapper);</span><br><span class="line">        List&lt;MediaType&gt; mediaTypes = Arrays.asList(</span><br><span class="line">            MediaType.APPLICATION_JSON</span><br><span class="line">            <span class="comment">// new MediaType(&quot;application&quot;, &quot;*+json&quot;) // 移除 application/*+json 的支持</span></span><br><span class="line">        );</span><br><span class="line">        converter.setSupportedMediaTypes(mediaTypes);</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 找到插入位置</span></span><br><span class="line">        List&lt;MediaType&gt; exceptMediaTypes = Collections.singletonList(MediaType.APPLICATION_JSON);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; converters.size(); i++) &#123;</span><br><span class="line">            HttpMessageConverter&lt;?&gt; converter = converters.get(i);</span><br><span class="line">            <span class="keyword">if</span> (converter <span class="keyword">instanceof</span> MappingJackson2HttpMessageConverter) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                List&lt;MediaType&gt; supportedMediaTypes = converter.getSupportedMediaTypes();</span><br><span class="line">                Assert.isTrue(Objects.equals(exceptMediaTypes, supportedMediaTypes), <span class="string">&quot;第 1 个 MappingJackson2HttpMessageConverter 支持的 MediaType:&quot;</span> + supportedMediaTypes + <span class="string">&quot;应为&quot;</span> + exceptMediaTypes);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 补充多种 PropertyNamingStrategy</span></span><br><span class="line">        <span class="type">PropertyNamingStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> PropertyNamingStrategy.SNAKE_CASE;</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">clone</span> <span class="operator">=</span> objectMapper.copy();</span><br><span class="line">        clone.setPropertyNamingStrategy(strategy);</span><br><span class="line"></span><br><span class="line">        <span class="type">MediaType</span> <span class="variable">mediaType</span> <span class="operator">=</span> ExtMappingJackson2HttpMessageConverter.createMediaType(strategy);</span><br><span class="line">        <span class="type">ExtMappingJackson2HttpMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExtMappingJackson2HttpMessageConverter</span>(clone, mediaType);</span><br><span class="line"></span><br><span class="line">        converters.add(index, converter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此, 响应体已经能根据请求头<code>Accept</code>来判断返回的数据格式是下划线命名还是驼峰命名了.</p><h1 id="正解-使用Content-Type请求头决定请求体是驼峰还是下划线"><a href="#正解-使用Content-Type请求头决定请求体是驼峰还是下划线" class="headerlink" title="正解: 使用Content-Type请求头决定请求体是驼峰还是下划线"></a>正解: 使用Content-Type请求头决定请求体是驼峰还是下划线</h1><p>请求参数也一样可以根据请求头<code>Content-Type</code>来判断.<br>还是<code>RequestResponseBodyMethodProcessor</code>这个类来处理.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestResponseBodyMethodProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractMessageConverterMethodProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123;</span><br><span class="line">        <span class="comment">// 调用父类的方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">arg</span> <span class="operator">=</span> readWithMessageConverters(inputMessage, parameter, paramType);</span><br><span class="line">        <span class="keyword">return</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractMessageConverterMethodProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractMessageConverterMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodReturnValueHandler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; Object <span class="title function_">readWithMessageConverters</span><span class="params">(HttpInputMessage inputMessage, MethodParameter parameter, Type targetType)</span> <span class="keyword">throws</span> IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException &#123;</span><br><span class="line">        <span class="comment">// 省略其他代码</span></span><br><span class="line">        <span class="comment">// 1. 获取请求头的 Content-Type</span></span><br><span class="line">        <span class="type">MediaType</span> <span class="variable">contentType</span> <span class="operator">=</span> inputMessage.getHeaders().getContentType();</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 2. 遍历 messageConverters, 找到支持该 MediaType 的 HttpMessageConverter 实现</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">body</span> <span class="operator">=</span> NO_VALUE;</span><br><span class="line">        <span class="type">EmptyBodyCheckingHttpInputMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmptyBodyCheckingHttpInputMessage</span>(inputMessage);</span><br><span class="line">        <span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="built_in">this</span>.messageConverters) &#123;</span><br><span class="line">            Class&lt;HttpMessageConverter&lt;?&gt;&gt; converterType = (Class&lt;HttpMessageConverter&lt;?&gt;&gt;) converter.getClass();</span><br><span class="line">            GenericHttpMessageConverter&lt;?&gt; genericConverter = (converter <span class="keyword">instanceof</span> GenericHttpMessageConverter ? (GenericHttpMessageConverter&lt;?&gt;) converter : <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (genericConverter != <span class="literal">null</span> ? genericConverter.canRead(targetType, contextClass, contentType) : (targetClass != <span class="literal">null</span> &amp;&amp; converter.canRead(targetClass, contentType))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (message.hasBody()) &#123;</span><br><span class="line">                    body = (genericConverter != <span class="literal">null</span> ? genericConverter.read(targetType, contextClass, msgToUse) : ((HttpMessageConverter&lt;T&gt;) converter).read(targetClass, msgToUse));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 注意这里!!! 匹配上就直接return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到和响应体的处理逻辑差不多, 也是筛选<code>MessageConverter</code>.<br>那么我们之前的配置, 也可以派上用场了. 直接在请求头<code>Content-Type</code>添加自定义的参数即可.</p><h1 id="自定义-MessageConverter-不能处理的情况"><a href="#自定义-MessageConverter-不能处理的情况" class="headerlink" title="自定义 MessageConverter 不能处理的情况"></a>自定义 MessageConverter 不能处理的情况</h1><p>现在的<code>Web</code>开发, 基本都是前后端分离的架构, 所以基本每个请求都是用<code>@ResponseBody</code>修饰的.<br>但是请求的话, 不一定都是<code>application/json</code>的请求, 也不一定都是<code>@RequestBody</code>修饰的请求参数.</p><p>对于客户端来说, 它可能会发送<code>GET</code>请求过来, 也可能发请求头为<code>application/x-www-form-urlencoded</code>的请求过来, 也可能发请求头为<code>application/json</code>的请求过来.</p><h2 id="GET-请求如何处理"><a href="#GET-请求如何处理" class="headerlink" title="GET 请求如何处理"></a>GET 请求如何处理</h2><p>对于<code>GET</code>请求, 会走<code>RequestParamMethodArgumentResolver</code>这个参数处理器.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractNamedValueMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodArgumentResolver</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> NamedValueInfo <span class="title function_">getNamedValueInfo</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 交给子类实现, 从 @RequestParam 获取参数名</span></span><br><span class="line">        <span class="type">NamedValueInfo</span> <span class="variable">namedValueInfo</span> <span class="operator">=</span> createNamedValueInfo(parameter);</span><br><span class="line">        <span class="comment">// 2. 如果没有配置 @RequestParam, 就反射获取变量名</span></span><br><span class="line">        namedValueInfo = updateNamedValueInfo(parameter, namedValueInfo);</span><br><span class="line">        <span class="keyword">return</span> namedValueInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> NamedValueInfo <span class="title function_">updateNamedValueInfo</span><span class="params">(MethodParameter parameter, NamedValueInfo info)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> info.name;</span><br><span class="line">        <span class="keyword">if</span> (info.name.isEmpty()) &#123;</span><br><span class="line">            name = parameter.getParameterName();</span><br><span class="line">            <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">defaultValue</span> <span class="operator">=</span> (ValueConstants.DEFAULT_NONE.equals(info.defaultValue) ? <span class="literal">null</span> : info.defaultValue);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NamedValueInfo</span>(name, info.required, defaultValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.springframework.web.method.annotation.RequestParamMethodArgumentResolver</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestParamMethodArgumentResolver</span> <span class="keyword">extends</span> <span class="title class_">AbstractNamedValueMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title class_">UriComponentsContributor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> NamedValueInfo <span class="title function_">createNamedValueInfo</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">        <span class="comment">// 从 @RequestParam 获取参数名</span></span><br><span class="line">        <span class="type">RequestParam</span> <span class="variable">ann</span> <span class="operator">=</span> parameter.getParameterAnnotation(RequestParam.class);</span><br><span class="line">        <span class="keyword">return</span> (ann != <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">RequestParamNamedValueInfo</span>(ann) : <span class="keyword">new</span> <span class="title class_">RequestParamNamedValueInfo</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GET</code> 请求并不会根据请求头<code>Content-Type</code>的不同而选择不同的命名规则. 代码里写的是什么就是什么.<br>如果想让<code>GET</code>请求也支持根据请求头<code>Content-Type</code>选择不同的命名规则, 只能写一个<strong>过滤器</strong>来处理了.<br>可以参考这个实现: <a href="https://gist.github.com/azhawkes/3db84b194b3e47423df2">https://gist.github.com/azhawkes/3db84b194b3e47423df2</a></p><h2 id="Content-Type-application-x-www-form-urlencoded-请求如何处理"><a href="#Content-Type-application-x-www-form-urlencoded-请求如何处理" class="headerlink" title="Content-Type: application/x-www-form-urlencoded 请求如何处理"></a>Content-Type: application/x-www-form-urlencoded 请求如何处理</h2><p><code>form data</code>的请求方式会走<code>ModelAttributeMethodProcessor</code>这个参数处理器.<br>同样的也不会受请求头<code>Content-Type</code>影响, 代码里写的是什么参数就是什么参数.<br>同样也只能写一个<strong>过滤器</strong>来处理.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从<code>RequestResponseBodyMethodProcessor</code>这个处理器的名字也可以看出, 它只支持<code>@RequestBody</code>和<code>@ResponseBody</code>.<br>其他格式的请求参数, 就只能用过滤器的形式<code>Hack</code>了.</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://www.baeldung.com/spring-httpmessageconverter-rest">Http Message Converters with the Spring Framework</a></li><li><a href="https://stackoverflow.com/a/43085405">Hot to make jackson to use snake_case / camelCase on demand in a Spring Boot REST API?</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.ahao.moe/categories/Java-Web/">Java Web</category>
      
      
      <category domain="https://blog.ahao.moe/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</category>
      
      <category domain="https://blog.ahao.moe/tags/Spring-MVC/">Spring MVC</category>
      
      
      <comments>https://blog.ahao.moe/posts/Support_both_snake_case_and_camelCase_in_Spring_MVC.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Docker Swarm容器编排</title>
      <link>https://blog.ahao.moe/posts/Docker_Swarm_mode_overview.html</link>
      <guid>https://blog.ahao.moe/posts/Docker_Swarm_mode_overview.html</guid>
      <pubDate>Sat, 11 Jul 2020 15:08:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Swarm&lt;/code&gt;是一个&lt;code&gt;Docker&lt;/code&gt;官方提供的容器编排工具. 是&lt;code&gt;Docker&lt;/code&gt;推出的一个&lt;code&gt;kubernetes&lt;/code&gt;的竞品(当然现在已经是&lt;code&gt;kubernetes&lt;/code&gt;的天下了&lt;br&gt;&lt;code&gt;Swarm&lt;/code&gt;用来解决多机下&lt;code&gt;Docker&lt;/code&gt;容器的部署问题, 这是传统&lt;code&gt;Docker&lt;/code&gt;和&lt;code&gt;Docker compose&lt;/code&gt;解决不了的.&lt;br&gt;并且&lt;code&gt;Swarm&lt;/code&gt;已经集成到&lt;code&gt;Docker&lt;/code&gt;原生工具里了, 可以直接使用.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Swarm</code>是一个<code>Docker</code>官方提供的容器编排工具. 是<code>Docker</code>推出的一个<code>kubernetes</code>的竞品(当然现在已经是<code>kubernetes</code>的天下了<br><code>Swarm</code>用来解决多机下<code>Docker</code>容器的部署问题, 这是传统<code>Docker</code>和<code>Docker compose</code>解决不了的.<br>并且<code>Swarm</code>已经集成到<code>Docker</code>原生工具里了, 可以直接使用.</p><span id="more"></span><h1 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h1><p><img data-src="https://yuml.me/diagram/nofunky;dir:UD/class/[manager1]-%3E[worker1],[manager1]-%3E[worker2],[manager1]-%3E[worker3],[manager2]-%3E[worker2],[manager2]-%3E[worker3]" alt="拓扑图"><br><code>Docker Swarm</code>有两个角色, <code>Manager</code>和<code>Worker</code>.<br><code>Manager</code>用于管理多个<code>Worker</code>.</p><h1 id="手动创建三个节点的Swarm集群"><a href="#手动创建三个节点的Swarm集群" class="headerlink" title="手动创建三个节点的Swarm集群"></a>手动创建三个节点的Swarm集群</h1><p>这里用一个在线环境来搭建. <a href="https://labs.play-with-docker.com/"><code>labs.play-with-docker</code></a><br>先创建<code>3</code>个节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 在节点A上声明自己是 manager</span></span><br><span class="line">docker swarm init --advertise-addr=`hostname -i | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>`</span><br><span class="line"><span class="comment"># Swarm initialized: current node (ob8gsaxiz3a4k8rubrv20im2q) is now a manager.</span></span><br><span class="line"><span class="comment"># To add a worker to this swarm, run the following command:</span></span><br><span class="line"><span class="comment">#     docker swarm join --token SWMTKN-1-4luou0jd1580qrjuodc74c7nnavzdoj6pmo8sdfjxy7i0mdld3-45orfnut6qf9ey4kxzs36yjkw 192.168.0.8:2377</span></span><br><span class="line"><span class="comment"># To add a manager to this swarm, run &#x27;docker swarm join-token manager&#x27; and follow the instructions.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 在节点B和节点C上执行上面提供的命令, 加入到 manager 的管理下 </span></span><br><span class="line">docker swarm <span class="built_in">join</span> --token SWMTKN-1-4luou0jd1580qrjuodc74c7nnavzdoj6pmo8sdfjxy7i0mdld3-45orfnut6qf9ey4kxzs36yjkw 192.168.0.8:2377</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 在 manager 上查看节点</span></span><br><span class="line">docker node <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># ID                            HOSTNAME    STATUS  AVAILABILITY    MANAGER STATUS  ENGINE VERSION</span></span><br><span class="line"><span class="comment">#  ob8gsaxiz3a4k8rubrv20im2q *   node1       Ready   Active          Leader          19.03.11</span></span><br><span class="line"><span class="comment">#  jlhp9zpjdhgwygxxl0hrky794     node2       Ready   Active                          19.03.11</span></span><br><span class="line"><span class="comment">#  cohz6uotcm6iogvlxmrh7cdwi     node3       Ready   Active                          19.03.11</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 在 manager 上创建一个 service</span></span><br><span class="line">docker service create --name service1 alpine /bin/ping 127.0.0.1</span><br><span class="line"><span class="comment"># u83i2d5k6aiog3elo9fndbic5</span></span><br><span class="line"><span class="comment"># overall progress: 1 out of 1 tasks </span></span><br><span class="line"><span class="comment"># 1/1: running   [==================================================&gt;] </span></span><br><span class="line"><span class="comment"># verify: Service converged </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 在 manager 上查看 service</span></span><br><span class="line">docker service <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># ID                  NAME                MODE                REPLICAS            IMAGE               PORTS</span></span><br><span class="line"><span class="comment"># u83i2d5k6aio        service1            replicated          1/1                 alpine:latest</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 在 manager 上给 service 动态扩容成 2 个节点</span></span><br><span class="line">docker service scale service1=2</span><br></pre></td></tr></table></figure><h1 id="手动搭建一个-wordpress"><a href="#手动搭建一个-wordpress" class="headerlink" title="手动搭建一个 wordpress"></a>手动搭建一个 wordpress</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建一个 overlay 网络</span></span><br><span class="line">docker network create -d overlay my-overlay</span><br><span class="line"><span class="comment"># 2. 创建 mysql 的 service </span></span><br><span class="line">docker service create --name my-mysql --network my-overlay --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=mysql-data,destination=/var/lib/mysql --<span class="built_in">env</span> MYSQL_ROOT_PASSWORD=root --<span class="built_in">env</span> MYSQL_DATABASE=wordpress mysql</span><br><span class="line"><span class="comment"># 3. 创建 wordpress 的 service </span></span><br><span class="line">docker service create --name my-wordpress --network my-overlay -p 80:80 --<span class="built_in">env</span> WORDPRESS_DB_PASSWORD=root --<span class="built_in">env</span> WORDPRESS_DB_HOST=mysql wordpress</span><br><span class="line"><span class="comment"># 4. 为 wordpress 扩容</span></span><br><span class="line">docker service scale my-wordpress=3</span><br></pre></td></tr></table></figure><p>这又回到了古老的<code>docker run</code>, 有没有类似<code>docker compose</code>的东西呢?</p><h1 id="使用-yaml-配置文件部署-swarm-集群"><a href="#使用-yaml-配置文件部署-swarm-集群" class="headerlink" title="使用 yaml 配置文件部署 swarm 集群"></a>使用 yaml 配置文件部署 swarm 集群</h1><p><code>docker stack</code>就是在<code>swarm</code>上的<code>docker compose</code>, 用的也是<code>yaml</code>配置.<br><code>compose file</code>在<code>3</code>之后提供了一个<code>deploy</code>的配置, 用于<code>swarm</code>集群的部署.</p><p>这里还是用<code>wordpress</code>举例</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">wordpress:</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wordpress:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">db:3306</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_USER:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_NAME:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-overlay</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">replicated</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">endpoint_mode:</span> <span class="string">vip</span></span><br><span class="line">      <span class="attr">update_config:</span></span><br><span class="line">        <span class="attr">parallelism:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">5s</span></span><br><span class="line">        <span class="attr">max_attempts:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql-data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-overlay</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">global</span> <span class="comment"># 只部署一个节点</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.role</span> <span class="string">==</span> <span class="string">manager</span> <span class="comment"># 只部署在 manager 节点上</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql-data:</span> &#123;&#125;</span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my-overlay:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">overlay</span></span><br></pre></td></tr></table></figure><p>然后使用<code>docker stack</code>命令启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 编辑 docker-compose.yml</span></span><br><span class="line">vim docker-compose.yml</span><br><span class="line"><span class="comment"># 2. 部署 swarm 集群</span></span><br><span class="line">docker stack deploy wordpress --compose-file=docker-compose.yml</span><br><span class="line"><span class="comment"># 3. 查看 service</span></span><br><span class="line">docker stack services wordpress</span><br><span class="line"><span class="comment"># ID                  NAME                  MODE                REPLICAS            IMAGE               PORTS</span></span><br><span class="line"><span class="comment"># 3uuc9055uadr        wordpress_db          global              1/1                 mysql:5.7           </span></span><br><span class="line"><span class="comment"># z7l7b5chkq0t        wordpress_wordpress   replicated          3/3                 wordpress:latest    *:80-&gt;80/tcp</span></span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://docs.docker.com/compose/compose-file/"><code>compose-file</code>文档</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.ahao.moe/categories/Docker/">Docker</category>
      
      
      <category domain="https://blog.ahao.moe/tags/Docker/">Docker</category>
      
      
      <comments>https://blog.ahao.moe/posts/Docker_Swarm_mode_overview.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Docker多阶段构建</title>
      <link>https://blog.ahao.moe/posts/docker_multi_stage_build.html</link>
      <guid>https://blog.ahao.moe/posts/docker_multi_stage_build.html</guid>
      <pubDate>Mon, 22 Jun 2020 14:36:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Docker多阶段构建是17.05以后引入的新特性，旨在解决编译和构建复杂的问题。&lt;br&gt;减小镜像大小。因此要使用多阶段构建特性必须使用高于或等于17.05的Docker。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;Docker&lt;/code&gt;多阶段构建出现之前, 要将&lt;code&gt;java&lt;/code&gt;程序打包运行, 需要编写两个&lt;code&gt;Dockerfile&lt;/code&gt;文件, 一个用来打包, 一个用来部署.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>Docker多阶段构建是17.05以后引入的新特性，旨在解决编译和构建复杂的问题。<br>减小镜像大小。因此要使用多阶段构建特性必须使用高于或等于17.05的Docker。</p></blockquote><p>在<code>Docker</code>多阶段构建出现之前, 要将<code>java</code>程序打包运行, 需要编写两个<code>Dockerfile</code>文件, 一个用来打包, 一个用来部署.</p><span id="more"></span><h1 id="两个-Dockerfile-的部署方式"><a href="#两个-Dockerfile-的部署方式" class="headerlink" title="两个 Dockerfile 的部署方式"></a>两个 Dockerfile 的部署方式</h1><p>创建用于打包的<code>Dockerfile</code>文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile.build</span></span><br><span class="line"><span class="keyword">FROM</span> registry.cn-hangzhou.aliyuncs.com/acs/maven:<span class="number">3</span>-jdk-<span class="number">8</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /usr/app</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /root/.m2</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ../../.. .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;mvn&quot;</span>, <span class="string">&quot;clean&quot;</span>, <span class="string">&quot;package&quot;</span>, <span class="string">&quot;-DfinalName=ahao&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>创建用于部署的<code>Dockerfile</code>文件.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-jre-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./ahao.jar /ahao.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/usr/bin/java&quot;</span>, <span class="string">&quot;-jar&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/ahao.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>然后编写<code>shell</code>脚本, 将两个<code>Dockerfile</code>构建镜像后, 关联起来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 构建打包镜像</span></span><br><span class="line">docker build -t ahao-build-image -f Dockerfile.build .</span><br><span class="line"><span class="comment"># 2. 创建 volume 存储, 缓存依赖项</span></span><br><span class="line">docker volume create --name maven-repo</span><br><span class="line"><span class="comment"># 3. 执行打包命令</span></span><br><span class="line">docker run -it -v maven-repo:/root/.m2 --name ahao-build ahao-build-image</span><br><span class="line"><span class="comment"># 4. 将打包后的 jar 包移出容器</span></span><br><span class="line">docker <span class="built_in">cp</span> ahao-build:/usr/app/target/ahao.jar .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 构建部署镜像</span></span><br><span class="line">docker build -t ahao-jar-deploy -f Dockerfile .</span><br><span class="line"><span class="comment"># 6. 启动部署容器</span></span><br><span class="line">docker run -it --name ahao-deploy ahao-jar-deploy</span><br></pre></td></tr></table></figure><h1 id="Docker-多阶段构建"><a href="#Docker-多阶段构建" class="headerlink" title="Docker 多阶段构建"></a>Docker 多阶段构建</h1><p>在<code>Docker</code>多阶段构建出现之前, 除了两个<code>Dockerfile</code>文件之外, 还要编写<code>shell</code>脚本.<br>真复杂, 于是多阶段构建就出现了.</p><p>在编写<code>Dockerfile</code>之前, 先把<code>pom.xml</code>几个重要的参数设置一下.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file.encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">file.encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">start-class</span>&gt;</span>moe.ahao.docker.Main<span class="tag">&lt;/<span class="name">start-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;-$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;finalName&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>$&#123;start-class&#125;<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">addDefaultImplementationEntries</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addDefaultImplementationEntries</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里用<code>maven-jar-plugin</code>打包, 还用到几个参数</p><ol><li><code>finalName</code>, 用于指定打包出来的<code>jar</code>名称, 方便编写<code>Dockfile</code></li><li><code>mainClass</code>, 用于指定<code>jar</code>包的主类.</li></ol><p>将上面的打包部署脚本翻译一下.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> registry.cn-hangzhou.aliyuncs.com/acs/maven:<span class="number">3</span>-jdk-<span class="number">8</span> AS build</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /usr/app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> pom.xml .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;/usr/local/bin/mvn-entrypoint.sh&quot;</span>, <span class="string">&quot;mvn&quot;</span>, <span class="string">&quot;verify&quot;</span>, <span class="string">&quot;clean&quot;</span>, <span class="string">&quot;--fail-never&quot;</span>]</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> src ./src</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;/usr/local/bin/mvn-entrypoint.sh&quot;</span>, <span class="string">&quot;mvn&quot;</span>, <span class="string">&quot;verify&quot;</span>, <span class="string">&quot;-DfinalName=ahao&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-jre-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build /usr/app/target/ahao.jar /usr/app/app.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/usr/bin/java&quot;</span>, <span class="string">&quot;-jar&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/usr/app/app.jar&quot;</span>]</span></span><br><span class="line"><span class="comment"># docker build -t ahao-docker .</span></span><br><span class="line"><span class="comment"># docker run -it ahao-docker</span></span><br></pre></td></tr></table></figure><p>然后构建镜像, 部署.</p><p>相关代码可以看我的<a href="https://github.com/Ahaochan/project/tree/master/ahao-docker">例子</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://stackoverflow.com/a/14417340"><code>Is it possible to rename a maven jar-with-dependencies?</code></a></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.ahao.moe/categories/Docker/">Docker</category>
      
      
      <category domain="https://blog.ahao.moe/tags/Docker/">Docker</category>
      
      
      <comments>https://blog.ahao.moe/posts/docker_multi_stage_build.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>RabbitMQ消息的可靠性投递</title>
      <link>https://blog.ahao.moe/posts/How_to_ensure_the_reliable_delivery_of_RabbitMQ.html</link>
      <guid>https://blog.ahao.moe/posts/How_to_ensure_the_reliable_delivery_of_RabbitMQ.html</guid>
      <pubDate>Fri, 19 Jun 2020 11:29:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;消息中间件&lt;code&gt;MQ&lt;/code&gt;主要的工作流程如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生产端&lt;code&gt;Producer&lt;/code&gt;发送消息给消息中间件&lt;code&gt;MQ&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;消息中间件&lt;code&gt;MQ&lt;/code&gt;接收到消息, 告诉生产者&lt;code&gt;Producer&lt;/code&gt;消息已经收到&lt;/li&gt;
&lt;li&gt;消息中间件&lt;code&gt;MQ&lt;/code&gt;将消息路由&lt;code&gt;Routing&lt;/code&gt;后, 投递给消费者&lt;code&gt;Consumer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;消费者告诉&lt;code&gt;MQ&lt;/code&gt;消息是否消费成功&lt;/li&gt;
&lt;/ol&gt;
&lt;img src=&quot;/images/RabbitMQ%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92_01.png&quot; class=&quot;&quot;&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>消息中间件<code>MQ</code>主要的工作流程如下</p><ol><li>生产端<code>Producer</code>发送消息给消息中间件<code>MQ</code></li><li>消息中间件<code>MQ</code>接收到消息, 告诉生产者<code>Producer</code>消息已经收到</li><li>消息中间件<code>MQ</code>将消息路由<code>Routing</code>后, 投递给消费者<code>Consumer</code></li><li>消费者告诉<code>MQ</code>消息是否消费成功</li></ol><img data-src="/images/RabbitMQ%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92_01.png" class=""><span id="more"></span><p>但是, 现实世界是不可能如此理想的. 如果在某个阶段发生了异常.</p><p>比如消息中间件<code>MQ</code>接收到消息后, 所在的服务器重启了, 没能告诉生产者<code>Producer</code>消息接收成功, 也没能将消息投递给消费者<code>Consumer</code>, 这时候就应该让生产者<code>Producer</code>重新投递.<br>比如发生了重放攻击, 生产者<code>Producer</code>连续发送了两条相同的消息, 那么消费者<code>Consumer</code>应该判断此消息是否消费过, 不应该重复消费.</p><p>业界有两种方案保证消息的可靠性投递</p><ol><li>消息落库, 对消息状态进行打标</li><li>消息延迟投递, 做二次确认, 回调检查</li></ol><p>两种方案都需要做消息的落库处理, 这里提供一个简单的消息表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> rabbitmq (</span><br><span class="line">`id`          <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">not</span> <span class="keyword">null</span> auto_increment comment <span class="string">&#x27;消息ID&#x27;</span>,</span><br><span class="line">`msg`         <span class="type">varchar</span>(<span class="number">4096</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;消息&#x27;</span>,</span><br><span class="line">`status`      tinyint unsigned <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;状态, 0:未投递, 1:已投递, 2:已确认, 3:已消费, 4: 失败&#x27;</span>,</span><br><span class="line">`retry_count` tinyint unsigned <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span> comment <span class="string">&#x27;重试次数&#x27;</span>,</span><br><span class="line">`create_time` datetime <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">`update_time` datetime <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line"><span class="keyword">primary</span> key (`id`)</span><br><span class="line">) engine <span class="operator">=</span> InnoDB <span class="keyword">default</span> charset <span class="operator">=</span> utf8mb4 comment<span class="operator">=</span><span class="string">&#x27;消息表&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="方案一-消息落库-对状态打标"><a href="#方案一-消息落库-对状态打标" class="headerlink" title="方案一: 消息落库, 对状态打标"></a>方案一: 消息落库, 对状态打标</h1><p>以电商下单为场景</p><img data-src="/images/RabbitMQ%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92_02.png" class=""><p>主要的步骤如图</p><ol><li>下单请求<code>Request</code>发送到订单系统<code>Order Center</code></li><li>将订单数据落库<code>DB</code>, 将消息落库<code>DB</code>, 状态为<code>1 已投递</code></li><li>发送消息给消息中间件<code>MQ</code></li><li>消息中间件<code>MQ</code>告诉订单系统<code>Order Center</code>消息接收到了</li><li>订单系统<code>Order Center</code>接收到消息中间件<code>MQ</code>的确认信息<code>confirm</code>, 更新<code>DB</code>中的消息状态为<code>2 已确认</code></li><li>消息中间件<code>MQ</code>将消息投递给结算系统<code>Settlement-Center</code></li><li>结算系统<code>Settlement-Center</code>收到消息, 更新<code>DB</code>中的消息状态为<code>3 已消费</code></li><li>分布式定时任务扫描那些超过一天还没消费的消息, 重新投递</li></ol><p>这算是一个比较完整的解决方案, 不管哪个步骤出问题, 只要状态没有流转到<code>3 已消费</code>, 那么分布式定时任务就会抓取消息, 重新投递, 超过特定次数就不再自动投递.<br>这里就会带来几个问题.</p><ol><li>订单落库和消息落库, 是否要加事务?</li><li>定时任务必须要是分布式的.</li></ol><h2 id="保证生产者和消息中间件的之间的可靠性投递"><a href="#保证生产者和消息中间件的之间的可靠性投递" class="headerlink" title="保证生产者和消息中间件的之间的可靠性投递"></a>保证生产者和消息中间件的之间的可靠性投递</h2><p>订单落库和消息落库, 我们可以看成是两次<code>insert</code>写库操作, 如果订单库和消息库在同一个<code>DB</code>实例下, 直接开启本地事务保存即可.<br>但是如果订单库和消息库在不同的<code>DB</code>实例下, 我们要使用分布式事务吗? 业务是否能接受分布式事务带来的性能损耗吗?</p><p>如果体量小的项目, 用分布式事务是可以的, 但如果碰到了海量请求的情况下. 我们也可以通过快速失败的方式, 来保证两个消息落库成功.<br>但是如果遇到更大的流量请求, 就要通过方案二来解决了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">order</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 生成订单号</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 订单落库</span></span><br><span class="line">        <span class="comment">// 2. 消息落库</span></span><br><span class="line">        <span class="comment">// 3. 发送MQ</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 4. 根据订单号做回滚操作 或者 根据定时任务扫描失败的记录</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;下单失败&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果订单落库失败, 或着消息落库失败, 那么就直接返回客户端下单失败的提醒. 后续定时任务轮询, 根据业务做回滚操作.<br>如果订单落库成功, 消息落库成功, 但是发送消息失败, 此时消息库应该有一条消息记录, 状态是<code>1:已投递</code>, 后续定时任务轮询重新投递.<br>如果订单落库成功, 消息落库成功, 消息发送成功, 但是**<code>MQ</code>想要告诉生产者发送成功**的这个动作失败了, 消息记录的状态是<code>1:已投递</code>, 后续定时任务轮询重新投递.<br>如果上述的操作都成功了, 那么消息的状态变更为<code>2:已确认</code>, 生产者和消费者之间的可靠性投递就算保证了.</p><p>那么怎么判断消息发送成功呢?<br><code>RabbitMQ</code>有两套机制保证, <code>Confirm</code>机制和<code>Return</code>机制.</p><h3 id="Confirm-确认消息"><a href="#Confirm-确认消息" class="headerlink" title="Confirm 确认消息"></a>Confirm 确认消息</h3><p><img data-src="https://yuml.me/diagram/nofunky/class/[%E7%94%9F%E4%BA%A7%E8%80%85]-1.%E6%B6%88%E6%81%AF%3E[%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6],[%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6]-2.Confirm%3E[%E7%94%9F%E4%BA%A7%E8%80%85]" alt="Confirm消息确认机制"></p><ol><li>生产者发送消息给消息中间件</li><li>消息中间件应答, 发送<code>Confirm</code>消息给生产者, 告诉生产者发送成功与否.</li></ol><p><code>RabbitMQ</code>通过调用<code>channel.confirmSelect()</code>开启<code>Confirm</code>消息确认机制.</p><h4 id="普通confirm"><a href="#普通confirm" class="headerlink" title="普通confirm"></a>普通confirm</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleConfirm</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1. 开启确认模式</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    <span class="comment">// 2. 发送消息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;deliveryTag: &quot;</span> + deliveryTag + <span class="string">&quot;, 现在时间&quot;</span> + LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>));</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">// 3. 同步 confirm</span></span><br><span class="line">        <span class="keyword">if</span> (!channel.waitForConfirms()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息[&quot;</span> + msg + <span class="string">&quot;]发送失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 批量同步 confirm</span></span><br><span class="line">    <span class="comment">// if (!channel.waitForConfirms()) &#123;</span></span><br><span class="line">    <span class="comment">//     System.out.println(&quot;消息[&quot; + msg + &quot;]发送失败&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Channel</code>提供了一个<code>waitForConfirms</code>方法. 会阻塞等待服务器端<code>confirm</code>.</p><blockquote><p>Wait until all messages published since the last call have been either ack’d or nack’d by the broker</p></blockquote><p><code>waitForConfirms</code>还支持批量<code>confirm</code>, 放在<code>for</code>循环外面即可.<br>当超时或返回<code>false</code>时, 需要自己编写业务代码重发消息.</p><h4 id="异步confirm"><a href="#异步confirm" class="headerlink" title="异步confirm"></a>异步confirm</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncConfirm</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1. 开启确认模式</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(size);</span><br><span class="line">    TreeSet&lt;Long&gt; confirmSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(); <span class="comment">// 记录未确认的 deliveryTag</span></span><br><span class="line"></span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    <span class="comment">// 添加异步监听器</span></span><br><span class="line">    channel.addConfirmListener(<span class="keyword">new</span> <span class="title class_">ConfirmListener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleAck</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(multiple) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;消息唯一标识:&quot;</span> + deliveryTag + <span class="string">&quot; 之前的消息都 ACK&quot;</span>);</span><br><span class="line">                    confirmSet.headSet(deliveryTag-<span class="number">1</span>).clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;消息唯一标识:&quot;</span> + deliveryTag + <span class="string">&quot; 消息 ACK&quot;</span>);</span><br><span class="line">                    confirmSet.remove(deliveryTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNack</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(multiple) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;消息唯一标识:&quot;</span> + deliveryTag + <span class="string">&quot; 之前的消息都 NACK&quot;</span>);</span><br><span class="line">                    confirmSet.headSet(deliveryTag-<span class="number">1</span>).clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;消息唯一标识:&quot;</span> + deliveryTag + <span class="string">&quot; 消息 NACK&quot;</span>);</span><br><span class="line">                    confirmSet.remove(deliveryTag);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(confirmSet.contains(deliveryTag)) &#123;</span><br><span class="line">                    <span class="comment">// 从数据库捞记录重发消息</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 发送消息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> channel.getNextPublishSeqNo();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;deliveryTag: &quot;</span>+deliveryTag+<span class="string">&quot;, 现在时间&quot;</span> + LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>));</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        confirmSet.add(deliveryTag);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 延迟, 保证 multiple 为 false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    latch.await();</span><br><span class="line">    Assertions.assertTrue(confirmSet.isEmpty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当生产者接受到<code>confirm</code>通知时, 会回调监听器的两个方法, <code>handleAck</code>和<code>handleNack</code>.</p><ol><li><code>handleAck</code>表示成功处理的消息</li><li><code>handleNack</code>表示<code>Broker</code>丢失了消息. <strong>但是</strong>, 即使返回<code>Nack</code>, 也有可能已经将消息投递给了消费者.</li></ol><p><code>handleAck</code>和<code>handleNack</code>有两个参数, 消息标识<code>deliveryTag</code>和批量标识<code>multiple</code>.</p><ol><li><code>deliveryTag</code>用于表示一个<code>Channel</code>下的消息的唯一<code>Id</code>, 可以通过<code>channel.getNextPublishSeqNo()</code>来获取接下来要发送的消息的<code>deliveryTag</code>.</li><li><code>multiple</code>用于表示当前的<code>ACK</code>或<code>NACK</code>是否批量操作, 如果是批量操作, 那么小于<code>deliveryTag</code>的消息都要处理.</li></ol><h4 id="Spring-Boot-实现-confirm"><a href="#Spring-Boot-实现-confirm" class="headerlink" title="Spring Boot 实现 confirm"></a>Spring Boot 实现 confirm</h4><p>首先要在配置文件里面开启<code>confirm</code>模式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># confirm模式</span></span><br></pre></td></tr></table></figure><p>然后设置<code>ConfirmCallback</code>, 多线程跑一下.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;sendString()&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(size);</span><br><span class="line">    rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收: &quot;</span> + correlationData + <span class="string">&quot;, ack:[&quot;</span> + ack + <span class="string">&quot;], cause:[&quot;</span> + cause + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 不能在这里设置 ConfirmCallback</span></span><br><span class="line">            <span class="type">CorrelationData</span> <span class="variable">correlationId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">            System.out.println(<span class="string">&quot;发送:&quot;</span> + msg + <span class="string">&quot;, correlationId: &quot;</span> + correlationId);</span><br><span class="line">            rabbitTemplate.convertAndSend(DirectConsumer.QUEUE_NAME, (Object) msg, correlationId);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> latch.await(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    Assertions.assertTrue(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一点需要注意下, 一个<code>RabbitTemplate</code>只能有一个<code>ConfirmCallback</code>. 这里看下源码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.amqp.rabbit.core.RabbitTemplate#setConfirmCallback</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConfirmCallback</span><span class="params">(ConfirmCallback confirmCallback)</span> &#123;</span><br><span class="line">    Assert.state(<span class="built_in">this</span>.confirmCallback == <span class="literal">null</span> || <span class="built_in">this</span>.confirmCallback == confirmCallback, <span class="string">&quot;Only one ConfirmCallback is supported by each RabbitTemplate&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.confirmCallback = confirmCallback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果业务要求需要对不同的生产者执行不同的<code>ConfirmCallback</code>逻辑, 那么再应该<code>new</code>一个<code>RabbitTemplate</code>.</p><h3 id="Return-不可达消息"><a href="#Return-不可达消息" class="headerlink" title="Return 不可达消息"></a>Return 不可达消息</h3><p><img data-src="https://yuml.me/diagram/nofunky/class/[%E7%94%9F%E4%BA%A7%E8%80%85]-1.%E6%B6%88%E6%81%AF%3E[%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6],[%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6]-2.%E6%B2%A1%E6%89%BE%E5%88%B0%3E[%E7%94%9F%E4%BA%A7%E8%80%85]" alt="Return不可达消息"></p><blockquote><p><a href="https://www.rabbitmq.com/confirms.html">https://www.rabbitmq.com/confirms.html</a><br>For unroutable messages, the broker will issue a confirm once the exchange verifies a message won’t route to any queue (returns an empty list of queues).<br>If the message is also published as mandatory, the basic.return is sent to the client before basic.ack.<br>The same is true for negative acknowledgements (basic.nack).</p></blockquote><p>当生产者生产一条消息, 投递到<code>MQ</code>消息中间件中, 但是<code>MQ</code>消息中间件判定投递失败<code>unroutable</code>, 比如没有对应的路由<code>Key</code>, 就会触发<code>return</code>机制.<br>在生产消息时, 如果指定<code>Mandatory</code>是<code>true</code>, 则监听器会接收到路由不可达的消息, 交由<code>ReturnListener</code>进行后续处理. 如果为false, 那么<code>MQ</code>消息中间件会自动删除这条消息.</p><h4 id="原生-API-方式"><a href="#原生-API-方式" class="headerlink" title="原生 API 方式"></a>原生 API 方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">_return</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1. 开启 return</span></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">mandatory</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// true监听不可达消息, false则自动删除消息</span></span><br><span class="line"></span><br><span class="line">    channel.addReturnListener((replyCode, replyText, exchange, routingKey, properties, body) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;replyCode:[&quot;</span> + replyCode + <span class="string">&quot;], replyText:[&quot;</span> + replyText + <span class="string">&quot;], exchange:[&quot;</span> + exchange + <span class="string">&quot;], routingKey:[&quot;</span> + routingKey + <span class="string">&quot;], BasicProperties:[&quot;</span> + properties + <span class="string">&quot;], body:[&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body, StandardCharsets.UTF_8) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 发送消息</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> channel.getNextPublishSeqNo();</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;deliveryTag: &quot;</span> + deliveryTag + <span class="string">&quot;, 现在时间&quot;</span> + LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>));</span><br><span class="line">    channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;NULL_KEY&quot;</span>, mandatory, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    <span class="comment">// channel.basicPublish(&quot;NULL_EXCHANGE&quot;, ROUTING_KEY, mandatory, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes(StandardCharsets.UTF_8));</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> latch.await(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    Assertions.assertTrue(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上, 如果传递一个未声明的<code>Exchange</code>过去, 不会触发<code>return</code>. 而传递不可路由的<code>RoutingKey</code>, 则可以触发<code>return</code>.</p><h4 id="Spring-Boot-实现-return"><a href="#Spring-Boot-实现-return" class="headerlink" title="Spring Boot 实现 return"></a>Spring Boot 实现 return</h4><p>首先要在配置文件里面开启<code>return</code>模式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># return机制</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">mandatory:</span> <span class="literal">true</span> <span class="comment"># 与 return 机制结合配置次属性</span></span><br></pre></td></tr></table></figure><p>然后设置<code>ReturnCallback</code>, 多线程跑一下.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">_return</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;sendString()&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(size);</span><br><span class="line">    rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收: &quot;</span> + message + <span class="string">&quot;, replyCode:[&quot;</span> + replyCode + <span class="string">&quot;], replyText:[&quot;</span> + replyText + <span class="string">&quot;], exchange:[&quot;</span> + exchange + <span class="string">&quot;], routingKey:[&quot;</span> + routingKey + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 不能在这里设置 ReturnCallback</span></span><br><span class="line">            <span class="type">CorrelationData</span> <span class="variable">correlationId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">            System.out.println(<span class="string">&quot;发送:&quot;</span> + msg + <span class="string">&quot;, correlationId: &quot;</span> + correlationId);</span><br><span class="line">            rabbitTemplate.convertAndSend(<span class="string">&quot;UNKNOWN&quot;</span>, (Object) msg, correlationId);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> latch.await(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    Assertions.assertTrue(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一点需要注意下, 和<code>Callback</code>一样, 一个<code>RabbitTemplate</code>只能有一个<code>ReturnCallback</code>. 这里看下源码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.amqp.rabbit.core.RabbitTemplate#setReturnCallback</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setReturnCallback</span><span class="params">(ReturnCallback returnCallback)</span> &#123;</span><br><span class="line">    Assert.state(<span class="built_in">this</span>.returnCallback == <span class="literal">null</span> || <span class="built_in">this</span>.returnCallback == returnCallback, <span class="string">&quot;Only one ReturnCallback is supported by each RabbitTemplate&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.returnCallback = returnCallback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果业务要求需要对不同的生产者执行不同的<code>ReturnCallback</code>逻辑, 那么再应该<code>new</code>一个<code>RabbitTemplate</code>.</p><h3 id="我们需要判断消息发送成功吗"><a href="#我们需要判断消息发送成功吗" class="headerlink" title="我们需要判断消息发送成功吗?"></a>我们需要判断消息发送成功吗?</h3><p>如果我们只管投递消息, 不管是否投递成功, 会有什么情况?<br>投递成功当然是最好的, 投递失败的话, 订单状态会一直处于<code>1:已投递</code>, 而不会变成<code>2:已确认</code>.<br>这样的话, 定时任务扫描到这条处于<code>1:已投递</code>的消息, 就会重新发送.</p><p>看起来似乎用不用<code>confirm</code>和<code>return</code>都可以保证消息投递成功了.<br>我能想象到使用<code>confirm</code>和<code>return</code>的业务场景有两种情况</p><ol><li>投递失败时, 尽快重新投递, 不等定时任务扫描.</li><li>监控投递流程, 单位时间内投递失败消息超过一定数量就报警.</li></ol><h2 id="保证消息中间件的持久化存储-避免消息丢失"><a href="#保证消息中间件的持久化存储-避免消息丢失" class="headerlink" title="保证消息中间件的持久化存储, 避免消息丢失"></a>保证消息中间件的持久化存储, 避免消息丢失</h2><p>经过上面的操作, 消息已经存储到消息中间件了. 为了保证消息不丢失, 消息中间件应该将消息做持久化处理.<br>否则当消息中间件宕机的时候, 在内存中的消息就会丢失.</p><p><code>RabbitMQ</code>可持久化的东西有三样, <code>Exchange</code>、<code>Queue</code>、消息.<br>持久化也很简单, 只要调用<code>API</code>传参即可.</p><h3 id="原生-API-方式-1"><a href="#原生-API-方式-1" class="headerlink" title="原生 API 方式"></a>原生 API 方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="comment">// Exchange.DeclareOk exchangeDeclare(String exchange, BuiltinExchangeType type, boolean durable, boolean autoDelete, boolean internal, Map&lt;String, Object&gt; arguments);</span></span><br><span class="line">    channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue.DeclareOk queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) throws IOException;</span></span><br><span class="line">    channel.queueDeclare(QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// public BasicProperties(String contentType, String contentEncoding, Map&lt;String,Object&gt; headers, Integer deliveryMode, </span></span><br><span class="line">    <span class="comment">//                          Integer priority, String correlationId, String replyTo, String expiration, String messageId,</span></span><br><span class="line">    <span class="comment">//                          Date timestamp, String type, String userId, String appId, String clusterId)</span></span><br><span class="line">    <span class="comment">// new BasicProperties(&quot;text/plain&quot;, null, null, 2, 0, null, null, null, null, null, null, null, null, null)</span></span><br><span class="line">    channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Exchange</code>和<code>Queue</code>的持久化只要在声明的时候, 指定<code>durable</code>为<code>true</code>即可.<br>而消息的持久化, 需要在发送消息的时候, 指定<code>BasicProperties</code>属性, 将<code>deliveryMode</code>设置为<code>2</code>持久化.</p><h3 id="Spring-Boot-实现"><a href="#Spring-Boot-实现" class="headerlink" title="Spring Boot 实现"></a>Spring Boot 实现</h3><p><code>Spring Boot</code>可以通过使用<code>Bean</code>声明<code>Exchange</code>和<code>Queue</code>来实现持久化.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">durable</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 持久化</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">exchange</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(EXCHANGE_NAME, durable, <span class="literal">false</span>, <span class="literal">null</span>); &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(QUEUE_NAME, durable, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用注解的形式声明<code>Exchange</code>和<code>Queue</code>实现持久化.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(key = &quot;#&quot;,</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(type = ExchangeTypes.TOPIC, name = EXCHANGE_NAME, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            value = @Queue(name = QUEUE_NAME, durable = &quot;true&quot;)))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">(<span class="meta">@Payload</span> String msg, Channel channel, <span class="meta">@Header(AmqpHeaders.DELIVERY_TAG)</span> <span class="type">long</span> tag,</span></span><br><span class="line"><span class="params">                         <span class="meta">@Headers</span> Map&lt;String, Object&gt; header)</span> &#123;</span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息的持久化也是在发消息时通过指定<code>MessageProperties</code>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String exchange, String routingKey, String msg)</span> &#123;</span><br><span class="line">    <span class="type">MessageProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">    properties.setDeliveryMode(MessageDeliveryMode.PERSISTENT); <span class="comment">// 指定持久化消息</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(msg.getBytes(StandardCharsets.UTF_8)).andProperties(properties).build();</span><br><span class="line">    rabbitTemplate.send(exchange, routingKey, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="保证消息中间件的消费可靠性"><a href="#保证消息中间件的消费可靠性" class="headerlink" title="保证消息中间件的消费可靠性"></a>保证消息中间件的消费可靠性</h2><p><code>RabbitMQ</code>要保证消息消费的可靠性, 就必须开启手动<code>ACK</code>.<br>默认情况下, 消费者是开启自动<code>ACK</code>的. 也就是说一条消息过来, 不管有没有执行成功, 都会告诉<code>RabbitMQ</code>消费成功. 如果出现异常, 也告诉<code>RabbitMQ</code>消费成功. 这明显是不合理的.</p><h3 id="原生-API-手动-ACK"><a href="#原生-API-手动-ACK" class="headerlink" title="原生 API 手动 ACK"></a>原生 API 手动 ACK</h3><p>可以看到, 自动<code>ACK</code>的配置, 是在创建消费者的时候就声明的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 声明自动 ACK</span></span><br><span class="line">    channel.basicConsume(QUEUE_NAME, autoAck, <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;接受到:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">                <span class="comment">// channel.basicAck(envelope.getDeliveryTag(), false);</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">// channel.basicNack(envelope.getDeliveryTag(), false, false);</span></span><br><span class="line">                <span class="comment">// channel.basicReject(envelope.getDeliveryTag(), false);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果设置成手动<code>ACK</code>, 那么就要手动调用几个方法来通知<code>MQ</code>消息的消费情况.</p><ol><li><code>channel.basicAck(long deliveryTag, boolean multiple)</code>, 表示正确处理这条消息.</li><li><code>channel.basicNack(long deliveryTag, boolean multiple, boolean requeue)</code>, 表示消息处理失败, 决定是否重回队列.</li><li><code>channel.basicReject(long deliveryTag, boolean requeue)</code>, 表示消息处理失败, 决定是否重回队列.</li></ol><p><code>basicNack</code>和<code>basicReject</code>有点像, 看了下文档, 区别就是能否支持<code>multiple</code>.</p><h3 id="Spring-Boot-手动-ACK"><a href="#Spring-Boot-手动-ACK" class="headerlink" title="Spring Boot 手动 ACK"></a>Spring Boot 手动 ACK</h3><p>首先在配置文件里设置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span> <span class="comment"># 手动ack</span></span><br></pre></td></tr></table></figure><p>然后在消费者那里手动调用原生<code>API</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(queueName))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">directQueue</span><span class="params">(<span class="meta">@Payload</span> String msg, Channel channel, <span class="meta">@Header(AmqpHeaders.DELIVERY_TAG)</span> <span class="type">long</span> tag)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息:&quot;</span> + msg);</span><br><span class="line">            channel.basicAck(tag, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            channel.basicNack(tag, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定时任务处理极端情况下的消息处理异常"><a href="#定时任务处理极端情况下的消息处理异常" class="headerlink" title="定时任务处理极端情况下的消息处理异常"></a>定时任务处理极端情况下的消息处理异常</h2><p>保证了消息发送、中间件存储、消息消费的可靠性.<br>但还是防止不了极端情况, 这些无法预料的情况, 必须有个兜底策略来处理.</p><p>比如用分布式定时任务扫描那些超过一天还没有流转到<code>3 已消费</code>的消息, 重新投递.</p><p>至于为什么要用<strong>分布式的</strong>定时任务, 是避免同一条消息, 在同一时刻重复投递.<br>从源头避免并发消息的产生.<br>当然, 消息的幂等性处理要由消费者来保证.</p><h1 id="方案二-消息延迟投递-做二次确认-回调检查"><a href="#方案二-消息延迟投递-做二次确认-回调检查" class="headerlink" title="方案二: 消息延迟投递, 做二次确认, 回调检查"></a>方案二: 消息延迟投递, 做二次确认, 回调检查</h1><p>方案一有一个问题, 消息发送之前, 需要落库两次, 业务库和消息库.<br>在海量高并发下, 每次磁盘<code>IO</code>的耗时, 都是不可忽视的. 在这种情况下, 要保证高性能, 将一致性降级为最终一致性.</p><p>和方案一相比, 方案二多了一个回调系统, 少了一步落库的操作.<br>要注意的是, 这里没有使用<code>RabbitMQ</code>的<code>Confirm</code>和<code>Return</code>机制.</p><img data-src="/images/RabbitMQ%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92_03.png" class=""><ol><li>下单请求<code>Request</code>发送到订单系统<code>Order Center</code></li><li>将订单数据落库<code>DB</code>, 发送一条业务消息, 发送一条延时消息(用于检查第一条消息是否处理成功)</li><li>结算系统<code>Settlement-Center</code>收到消息, 处理成功后, 发送一条确认消息</li><li>回调系统消费这条确认消息, 这个时候再进行消息落库</li><li>过了几分钟, 回调系统消费了订单系统发送的延迟消息, 去消息库里检查是否存在这条信息.</li><li>如果没有, 就调用订单系统的接口, 重投消息.</li><li>分布式定时任务扫描那些超过一天还没消费的消息, 重新投递.</li></ol><p>以上都是流程正常的情况.<br>那万一中间哪一步出现异常, 要怎么保证消息再次重发呢? 关键点就在于这个用于<strong>检查</strong>的延迟消息.</p><p>这个用于检查的延迟消息, 消息体带上订单号等业务信息, 会在一段时间, 比如十分钟后投递到<code>MQ</code>消息中间件, 然后回调系统消费这条消息, 去检查消息库.<br>如果看到这条订单消息没有被处理, 那么就调用订单系统的接口, 让订单系统重新投递这条消息.</p><p>这里有个大问题, 如果这条延迟消息丢失了怎么办?<br>只能通过定时任务来补偿了.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><a href="https://coding.imooc.com/class/262.html">RabbitMQ消息中间件技术精讲</a></li><li><a href="https://www.javazhiyin.com/47715.html">消息中间件——RabbitMQ（七）高级特性全在这里!（上）</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.ahao.moe/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</category>
      
      
      <category domain="https://blog.ahao.moe/tags/RabbitMQ/">RabbitMQ</category>
      
      
      <comments>https://blog.ahao.moe/posts/How_to_ensure_the_reliable_delivery_of_RabbitMQ.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>DockerFile详解</title>
      <link>https://blog.ahao.moe/posts/DockerFile.html</link>
      <guid>https://blog.ahao.moe/posts/DockerFile.html</guid>
      <pubDate>Thu, 18 Jun 2020 16:47:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们使用&lt;code&gt;Docker&lt;/code&gt;镜像, 一般都是从远程&lt;a href=&quot;https://hub.docker.com/&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt;仓库&lt;code&gt;pull&lt;/code&gt;下来的.&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker pull hello-world&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是实际开发过程中, 经常会需要把自己的应用程序打包成一个&lt;code&gt;images&lt;/code&gt;镜像. 这个镜像是需要自己打包的.&lt;br&gt;打包的方式一般有两种, &lt;code&gt;Docker File&lt;/code&gt;和&lt;code&gt;Docker Compose&lt;/code&gt;.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们使用<code>Docker</code>镜像, 一般都是从远程<a href="https://hub.docker.com/"><code>Registry</code></a>仓库<code>pull</code>下来的.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull hello-world</span><br></pre></td></tr></table></figure><p>但是实际开发过程中, 经常会需要把自己的应用程序打包成一个<code>images</code>镜像. 这个镜像是需要自己打包的.<br>打包的方式一般有两种, <code>Docker File</code>和<code>Docker Compose</code>.</p><span id="more"></span><h1 id="如何在已有-image-上做修改"><a href="#如何在已有-image-上做修改" class="headerlink" title="如何在已有 image 上做修改"></a>如何在已有 image 上做修改</h1><p>官方虽然提供了很多的<code>Image</code>, 但是我们总会要做一些定制化需求.<br>比如往<code>Image</code>里面塞一些应用程序. 下面列举一个不推荐使用的修改<code>Image</code>的方法.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 拉取基础image</span></span><br><span class="line">docker pull alpine</span><br><span class="line"><span class="comment"># 2. 运行基础image, 并创建一个 hello.txt 文件</span></span><br><span class="line">docker run -it --name base-alpine alpine /bin/sh</span><br><span class="line"><span class="comment"># /bin/echo hello &gt; /hello.txt</span></span><br><span class="line"><span class="comment"># exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 使用这个退出后的container, 重新构建一个新的image</span></span><br><span class="line">docker commit base-alpine ahao-alpine</span><br><span class="line"><span class="comment"># 4. 使用这个新构建的镜像, 能找到之前编辑过的 hello.txt</span></span><br><span class="line">docker run -it ahao-alpine /bin/sh</span><br><span class="line"><span class="comment"># /bin/cat /hello.txt</span></span><br></pre></td></tr></table></figure><p>但是这种方法不推荐, 也不安全.<br>如果是有恶意的人, 在第二步创建了一个恶意脚本, 然后发布到官方仓库. 使用者根本不知道上传者做了什么操作, 无法进行<code>Review</code>.<br>为了能进行<code>Review</code>代码审查, <code>Docker</code>提供了一个叫<code>DockerFile</code>的文件. 用来记录修改了哪些操作.</p><h1 id="使用-Dockerfile-改造上述例子"><a href="#使用-Dockerfile-改造上述例子" class="headerlink" title="使用 Dockerfile 改造上述例子"></a>使用 Dockerfile 改造上述例子</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 基于 alpine 镜像构建</span></span><br><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="comment"># 2. 创建一个 hello.txt 文件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> /bin/echo hello &gt; /hello.txt</span></span><br><span class="line"><span class="comment"># 3. 输出 hello.txt</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/bin/cat&quot;</span>, <span class="string">&quot;/hello.txt&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>我们创建了一个<code>Dockerfile</code>文件, 然后执行构建命令, 输出了<code>hello</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 在当前目录根据 Dockerfile 构建 Docker 镜像</span></span><br><span class="line">docker build -t ahaochan/ahao-alpine .</span><br><span class="line"><span class="comment"># 2. 运行构建的镜像, 输出</span></span><br><span class="line">docker run ahaochan/ahao-alpine</span><br><span class="line"><span class="comment"># hello</span></span><br></pre></td></tr></table></figure><h1 id="Dockerfile-语法"><a href="#Dockerfile-语法" class="headerlink" title="Dockerfile 语法"></a>Dockerfile 语法</h1><p>下面讲讲<code>Dockerfile</code>的一些命令的语法和使用, 不过建议还是看<a href="https://docs.docker.com/engine/reference/builder/">官方文档</a>的好.</p><h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h2><p><code>FROM</code>表示当前镜像是基于哪个镜像做的.<br>比如之前用的<code>FROM alpine</code>, 表示当前镜像是基于<code>alpine</code>来做定制化需求.<br>推荐使用官方的<code>Image</code>来作为<code>FROM</code>基础镜像.</p><h2 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h2><p><code>LABEL</code>用来标记一些元数据<code>metadata</code>, 相当于镜像的注释.<br>虽然可以没有, 但是建议要有. 不然就是一个三无产品<code>Image</code>, 谁敢放心用呢?</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 基于 alpine 镜像构建</span></span><br><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="comment"># 2. 元数据 metadata</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;作者&quot;</span> version=<span class="string">&quot;版本号&quot;</span> description=<span class="string">&quot;描述&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h2><p><code>WORKDIR</code>相当于<code>linux</code>的<code>cd</code>命令, 用于进入某个目录中, 如果目录不存在会自动创建目录.<br>有两点需要注意</p><ol><li>千万不要使用<code>RUN cd</code>, 因为每一次<code>RUN</code>都会产生一层<code>Image Layer</code>.</li><li>尽量使用绝对目录, 避免弄混淆了</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /test</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> demo</span></span><br><span class="line"><span class="comment"># 输出 /test/demo</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure><h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><p><code>ENV</code>用于设置环境变量, 提高可维护性.<br>比如我要升级<code>MySQL</code>版本, 改变量就可以了.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> MYSQL_VERSION <span class="number">5.6</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y mysql-server=<span class="string">&quot;<span class="variable">$&#123;MYSQL_VERSION&#125;</span>&quot;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure><p>除了上面这种简单用法还有一些高级用法</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">ENV</span> VAR ahao</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo <span class="variable">$&#123;VAR&#125;</span> <span class="variable">$&#123;VAR:-default&#125;</span> <span class="variable">$&#123;NO:-default&#125;</span> <span class="variable">$&#123;VAR:+value&#125;</span> <span class="variable">$&#123;NO:+value&#125;</span>&quot;</span>]</span></span><br><span class="line"><span class="comment"># ahao ahao default value</span></span><br></pre></td></tr></table></figure><ol><li><code>$&#123;VAR:-default&#125;</code>的意思是, 当<code>VAR</code>没有被定义的时候, 使用后面的<code>default</code>值</li><li><code>$&#123;VAR:+default&#125;</code>的意思是, 当<code>VAR</code>被定义的时候, 使用后面的<code>value</code>值, 否则使用空字符串</li></ol><p>当重复定义一个变量的时候, 当前<code>Image Layer</code>会使用上一层<code>Image Layer</code>定义的变量.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">ENV</span> a=hello</span><br><span class="line"><span class="keyword">ENV</span> a=world b=$a</span><br><span class="line"><span class="keyword">ENV</span> c=$a</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo <span class="variable">$&#123;a&#125;</span> <span class="variable">$&#123;b&#125;</span> <span class="variable">$&#123;c&#125;</span>&quot;</span>]</span></span><br><span class="line"><span class="comment"># world hello world</span></span><br></pre></td></tr></table></figure><h2 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h2><p><code>ARG &lt;name&gt;[=&lt;default value&gt;]</code><br>在<code>docker build</code>镜像的时候使用<code>--build-arg &lt;varname&gt;=&lt;value&gt;</code>参数, 可以将外部参数传入<code>Dockerfile</code>文件中, 用来构建镜像.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> VERSION=latest</span><br><span class="line"><span class="keyword">FROM</span> alpine:$&#123;VERSION&#125;</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> /bin/echo hello</span></span><br></pre></td></tr></table></figure><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 构建基于 最新alpine 的镜像</span></span><br><span class="line">docker build -t ahaochan/ahao-alpine-last .</span><br><span class="line"><span class="comment"># 2. 构建基于 2.7 alpine 的镜像</span></span><br><span class="line">docker build --build-arg VERSION=2.7 -t ahaochan/ahao-alpine-2.7 .</span><br></pre></td></tr></table></figure><p>值得注意的是, 官方文档提到, <code>ARG</code>不要传递敏感数据, 不安全.</p><p>还有就是同名变量<code>ENV</code>会覆盖<code>ARG</code>. 根据这个特性, 可以做一些默认的操作.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">ARG</span> VERSION</span><br><span class="line"><span class="keyword">ENV</span> VERSION $&#123;VERSION:-lastest&#125;</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> /bin/echo <span class="variable">$VERSION</span></span></span><br></pre></td></tr></table></figure><h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h2><p><code>ADD</code>和<code>COPY</code>都是在构建镜像的时候, 将上下文的文件拷贝到镜像中.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t ahaochan/ahao-alpine .</span><br></pre></td></tr></table></figure><p>关于上下文, 其实我们一直有在用, 在构建的时候会传入一个参数<code>.</code>, 表示将当前目录作为上下文.<br>构建的时候, <code>docker</code>客户端会把上下文中的所有文件发送给<code>docker daemon</code>.<br>那么如果<code>docker</code>客户端和<code>docker daemon</code>不在同一台机器上, <code>docker daemon</code>是获取不到除了上下文之外的文件的.<br>所以<code>Dockerfile</code>里面的文件, 都要基于这个上下文来访问.</p><p>如果只是简单的将文件复制到镜像中, 直接使用<code>COPY</code>就可以了</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="comment"># 1. 将 file1 文件 复制到镜像内 /tmp/test1/ 目录下</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> file1  /tmp/test1/</span></span><br><span class="line"><span class="comment"># 2. 将 file2开头的 文件 复制到镜像内 /tmp/test2/ 目录下</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> file2* /tmp/test2/</span></span><br><span class="line"><span class="comment"># 3. 将 file3开头的 文件 复制到镜像内 /tmp/test3/ 目录下, ?占一个字符, *占多个字符</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> file3? /tmp/test3/</span></span><br><span class="line"><span class="comment"># 4. 将 dir4目录下的 文件 复制到镜像内 /tmp/test4/ 目录下</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> dir4/ /tmp/test4/</span></span><br><span class="line"><span class="comment"># 5. 将 dir5目录下的 文件 复制到镜像内 /tmp/test4/ 目录下, 不会复制 dir5目录本身</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> dir5 /tmp/test5/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> /bin/ls /tmp/test*</span></span><br></pre></td></tr></table></figure><p>构建完毕后, 我们进去看看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 准备文件</span></span><br><span class="line"><span class="built_in">touch</span> file1</span><br><span class="line"><span class="built_in">touch</span> file2 file22 file222</span><br><span class="line"><span class="built_in">touch</span> file3 file33 file333</span><br><span class="line"><span class="built_in">mkdir</span> dir4 &amp;&amp; <span class="built_in">touch</span> dir4/1 dir4/2 dir4/3</span><br><span class="line"><span class="built_in">mkdir</span> dir5 &amp;&amp; <span class="built_in">touch</span> dir5/1 dir5/2 dir5/3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 构建镜像并运行</span></span><br><span class="line">docker build -t ahaochan/ahao-alpine .</span><br><span class="line">docker run ahaochan/ahao-alpine</span><br><span class="line"><span class="comment"># /tmp/test1:</span></span><br><span class="line"><span class="comment"># file1</span></span><br><span class="line"><span class="comment"># /tmp/test2:</span></span><br><span class="line"><span class="comment"># file2     file22       file222</span></span><br><span class="line"><span class="comment"># /tmp/test3:</span></span><br><span class="line"><span class="comment"># file33</span></span><br><span class="line"><span class="comment"># /tmp/test4:</span></span><br><span class="line"><span class="comment"># 1         2           3</span></span><br><span class="line"><span class="comment"># /tmp/test5:</span></span><br><span class="line"><span class="comment"># 1         2           3</span></span><br></pre></td></tr></table></figure><p>另外, <code>COPY</code>还能在多阶段构建中使用, 这是区别于<code>ADD</code>的一个用法.<br>多阶段构建常用在编译打包阶段, 这里不细讲.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> /bin/echo hello &gt; /hello.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="comment"># from = 0 引用第一个阶段的 stage, 拉取 hello.txt</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=0 /hello.txt .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;/bin/cat hello.txt&quot;</span>]</span></span><br></pre></td></tr></table></figure><h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h2><p><code>ADD</code>和<code>COPY</code>差不多, 也是将上下文的文件拷贝到镜像中.<br><code>ADD</code>除了不能应用在多阶段构建的场景之外, <code>ADD</code>比<code>COPY</code>多了两个功能.</p><ol><li>自动解压缩文件并添加到镜像中</li><li>从<code>url</code>拷贝文件并添加到镜像中. (<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#add-or-copy">官方不推荐</a>, 使用<code>curl</code>或<code>wget</code>替代)</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> hello.tar.gz /</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> https://greasyfork.org/zh-CN/users/30831.json /</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;/bin/ls -l hello.txt 30831.json&quot;</span>]</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 准备压缩包</span></span><br><span class="line"><span class="built_in">echo</span> hello &gt; hello.txt</span><br><span class="line">tar zcvf hello.tar.gz hello.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 构建镜像</span></span><br><span class="line">docker build -t ahaochan/ahao-alpine .</span><br><span class="line">docker run ahaochan/ahao-alpine</span><br><span class="line"><span class="comment"># -rw-------    1 root  root  7748 Jan  1  1970 30831.json</span></span><br><span class="line"><span class="comment"># -rw-r--r--    1 root  root     6 Jun  7 08:09 hello.txt</span></span><br></pre></td></tr></table></figure><h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p><code>RUN</code>有2种形式</p><ol><li><code>shell</code>形式: <code>RUN &lt;command&gt;</code></li><li><code>exec</code>形式: <code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">ENV</span> VAR ahao</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;VAR&#125;</span>&quot;</span></span></span><br><span class="line"><span class="comment"># ahao</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="variable">$&#123;VAR&#125;</span></span></span><br><span class="line"><span class="comment"># ahao</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;/bin/echo&quot;</span>, <span class="string">&quot;<span class="variable">$&#123;VAR&#125;</span>&quot;</span>]</span></span><br><span class="line"><span class="comment"># $&#123;VAR&#125;</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo <span class="variable">$&#123;VAR&#125;</span>&quot;</span>]</span></span><br><span class="line"><span class="comment"># ahao</span></span><br></pre></td></tr></table></figure><p>可以看到, <code>exec</code>形式的<code>RUN</code>命令(其实不止<code>RUN</code>, 还有<code>CMD</code>和<code>ENTRYPOINT</code>), 不会去解析<code>$&#123;VAR&#125;</code>.</p><p><code>RUN</code>命令一般用来安装一些依赖, 删除缓存等操作.<br>但是每一次<code>RUN</code>都会产生一层<code>Image Layer</code>, 所以需要尽可能的少用<code>RUN</code>, 安装依赖尽量一行代码搞定.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum 安装例子</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    yum install -y vim</span></span><br><span class="line"><span class="comment"># apt 安装例子, 注意删除缓存</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y vim &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p><code>CMD</code>有3种形式</p><ol><li><code>shell</code>形式: <code>CMD &lt;command&gt;</code></li><li><code>exec</code>形式: <code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></li><li><code>exec</code>形式: <code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code>, 作为<code>ENTRYPOINT</code>的默认参数.<br><code>CMD</code>是<code>container</code>启动时默认执行的命令.<br>使用<code>CMD</code>有几个需要注意的地方.</li><li>如果<code>Dockerfile</code>有多个<code>CMD</code>, 就只会执行最后一个.</li><li>外部命令会覆盖内部的<code>CMD</code>.</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 基于 alpine 镜像构建</span></span><br><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="comment"># 2. 第1个 CMD 命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/ping&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>]</span></span><br><span class="line"><span class="comment"># 3. 第2个 CMD 命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/echo&quot;</span>, <span class="string">&quot;hello&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>编写完<code>Dockerfile</code>后, 我们来构建它.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 构建镜像</span></span><br><span class="line">docker build -t ahaochan/ahao-alpine .</span><br><span class="line"><span class="comment"># 2. 不指定外部命令, 默认执行 Dockerfile 最后一个 CMD 命令 </span></span><br><span class="line">docker run ahaochan/ahao-alpine</span><br><span class="line"><span class="comment"># hello</span></span><br><span class="line"><span class="comment"># 3. 指定外部命令, 覆盖 Dockerfile 里的 CMD 命令</span></span><br><span class="line">docker run -it ahaochan/ahao-alpine /bin/echo ahao</span><br><span class="line"><span class="comment"># ahao</span></span><br></pre></td></tr></table></figure><h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p><code>ENTRYPOINT</code>有2种形式</p><ol><li><code>shell</code>形式: <code>ENTRYPOINT command param1 param2</code></li><li><code>exec</code>形式: <code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>, 推荐使用.</li></ol><p><code>ENTRYPOINT</code>让<code>container</code>以应用程序或者服务的形式在后台运行.<br>等价于<code>docker run --entrypoint &quot;command&quot;</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/bin/ping&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>]</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker build -t ahaochan/ahao-alpine .</span><br><span class="line"><span class="comment"># 1. 错误使用--entrypoint覆盖</span></span><br><span class="line">docker run --entrypoint <span class="string">&quot;/bin/echo hello&quot;</span> ahaochan/ahao-alpine</span><br><span class="line"><span class="comment"># docker: Error response from daemon: OCI runtime create failed: container_linux.go:345: starting container process caused &quot;exec: \&quot;/bin/echo hello\&quot;: stat /bin/echo hello: no such file or directory&quot;: unknown.</span></span><br><span class="line"><span class="comment"># 2. 正确使用--entrypoint覆盖</span></span><br><span class="line">docker run --entrypoint /bin/echo ahaochan/ahao-alpine hello</span><br><span class="line"><span class="comment"># hello</span></span><br><span class="line"><span class="comment"># 3. 循环执行ping 127.0.0.1</span></span><br><span class="line">docker run ahaochan/ahao-alpine </span><br><span class="line"><span class="comment"># 4. CMD 和 ENTRYPOINT 组合使用, ping 127.0.0.1 -c 3</span></span><br><span class="line">docker run ahaochan/ahao-alpine -c 3</span><br></pre></td></tr></table></figure><h1 id="Docker-Compose-语法"><a href="#Docker-Compose-语法" class="headerlink" title="Docker Compose 语法"></a>Docker Compose 语法</h1><p>我们在进行容器间的通信的时候, 要分别启动容器, 关闭还要一个个关闭.<br>比如我要在<code>ahao-alpine2</code>向<code>ahao-alpine1</code>发送请求, 需要先启动<code>ahao-alpine1</code>, 然后再启动<code>ahao-alpine2</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name ahao-alpine1  alpine /bin/ping 127.0.0.1</span><br><span class="line">docker run --name ahao-alpine2 --<span class="built_in">link</span> ahao-alpine1 alpine /bin/ping ahao-alpine1</span><br></pre></td></tr></table></figure><p>为了解决这个繁琐的操作, <code>Docker</code>提供了一个工具<code>Docker Compose</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不推荐使用 apt install, 这安装的是旧版本</span></span><br><span class="line"><span class="comment"># apt install docker-compose -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># https://docs.docker.com/compose/install/#install-compose-on-linux-systems</span></span><br><span class="line">curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.26.0/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br><span class="line"><span class="built_in">ln</span> -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><p>我们创建一个<code>docker-compose.yml</code>文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">ahao-alpine1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/ping&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>]</span><br><span class="line">  <span class="attr">ahao-alpine2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ahao-alpine1</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/ping&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>]</span><br></pre></td></tr></table></figure><p>一个<code>Service</code>代表一个<code>Container</code>, 启动类似<code>docker run</code>, 可以为其指定<code>network</code>和<code>volume</code>.<br>然后执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在后台启动 compose</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"><span class="comment"># 进行容器间的网络通信</span></span><br><span class="line">docker-compose <span class="built_in">exec</span> ahao-alpine2 /bin/ping -c 3 ahao-alpine1</span><br><span class="line"><span class="comment"># 关闭进程并删除镜像</span></span><br><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><h2 id="搭建-wordpress"><a href="#搭建-wordpress" class="headerlink" title="搭建 wordpress"></a>搭建 wordpress</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">wordpress:</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wordpress:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">db:3306</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_USER:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_NAME:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-bridge</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql-data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-bridge</span></span><br><span class="line">  <span class="attr">pma:</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">phpmyadmin/phpmyadmin</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># https://docs.phpmyadmin.net/en/latest/setup.html#docker-environment-variables</span></span><br><span class="line">      <span class="attr">PMA_HOST:</span> <span class="string">db</span></span><br><span class="line">      <span class="attr">PMA_PORT:</span> <span class="number">3306</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-bridge</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql-data:</span> &#123;&#125;</span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my-bridge:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://docs.docker.com/engine/reference/builder/">官方文档</a></li><li><a href="https://docs.docker.com/compose/compose-file/"><code>compose-file</code>文档</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.ahao.moe/categories/Docker/">Docker</category>
      
      
      <category domain="https://blog.ahao.moe/tags/Docker/">Docker</category>
      
      
      <comments>https://blog.ahao.moe/posts/DockerFile.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>RabbitMQ概念入门</title>
      <link>https://blog.ahao.moe/posts/Getting_started_with_RabbitMQ.html</link>
      <guid>https://blog.ahao.moe/posts/Getting_started_with_RabbitMQ.html</guid>
      <pubDate>Tue, 02 Jun 2020 06:21:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;RabbitMQ&lt;/code&gt;是一个&lt;code&gt;Erlang&lt;/code&gt;实现的开源消息中间件, 实现了&lt;code&gt;Advanced Message Queuing Protocol(AMQP)&lt;/code&gt;协议.&lt;br&gt;&lt;code&gt;AMQP&lt;/code&gt;协议是一个抽象协议, 定义了一系列的接口, 而&lt;code&gt;RabbitMQ&lt;/code&gt;等消息中间件实现了这些接口.&lt;/p&gt;
&lt;p&gt;本文使用原生&lt;code&gt;RabbitMQ&lt;/code&gt;的&lt;code&gt;API&lt;/code&gt;来进行调用, 不使用&lt;code&gt;Spring AMQP&lt;/code&gt;.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>RabbitMQ</code>是一个<code>Erlang</code>实现的开源消息中间件, 实现了<code>Advanced Message Queuing Protocol(AMQP)</code>协议.<br><code>AMQP</code>协议是一个抽象协议, 定义了一系列的接口, 而<code>RabbitMQ</code>等消息中间件实现了这些接口.</p><p>本文使用原生<code>RabbitMQ</code>的<code>API</code>来进行调用, 不使用<code>Spring AMQP</code>.</p><span id="more"></span><h1 id="AMQP核心概念"><a href="#AMQP核心概念" class="headerlink" title="AMQP核心概念"></a>AMQP核心概念</h1><p><code>Server</code>: 又称为<code>Broker</code>, 其实就是<code>RabbitMQ</code>的服务端, 接收客户端的连接, 实现<code>AMQP</code>协议.<br><code>Connection</code>: 连接, 应用程序与<code>Broker</code>的连接.<br><code>Channel</code>: 网络信道, 生产消费消息都在<code>Channel</code>进行, 一个客户端可以建立多个<code>Channel</code>.</p><p><code>Message</code>: 消息, 应用程序和<code>Broker</code>之间传送的数据, 由<code>Properties</code>属性和<code>Body</code>消息体组成.</p><p><code>Virtual Host</code>: 虚拟地址, 用于逻辑隔离. 一般用于区分<code>dev</code>环境, <code>test</code>环境.<br><code>Exchange</code>: 交换机, 接收消息, 根据消息的路由<code>Key</code>和绑定规则, 投递到对应的<code>Queue</code>队列中.<br><code>Binding</code>: <code>Exchange</code>交换机和<code>Queue</code>队列之间的绑定规则.<br><code>Queue</code>: 队列, 保存消息并转发给消费者.</p><h1 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h1><p><code>Broker</code>服务端直接用<code>docker</code>启动就好了, 使用默认参数.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3-management</span><br></pre></td></tr></table></figure><p>然后访问<code>http://虚拟机IP:15672</code>.<br>除了单节点的启动, <code>RabbitMQ</code>还支持集群部署.</p><h1 id="Connection、Channel"><a href="#Connection、Channel" class="headerlink" title="Connection、Channel"></a>Connection、Channel</h1><p>接下来是<code>Connection</code>和<code>Channel</code>, 和数据库连接类似, 我们可以对比下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mq</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 建立连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取连接, 获取 Channel</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">             <span class="type">Channel</span> <span class="variable">channel1</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">             <span class="type">Channel</span> <span class="variable">channel2</span> <span class="operator">=</span> connection.createChannel();) &#123;</span><br><span class="line">            <span class="comment">// 3. 使用 Channel 创建 Exchange、Queue, 生产消息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">db</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 获取连接, 获取 Statement</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">             <span class="type">PreparedStatement</span> <span class="variable">statement1</span> <span class="operator">=</span> connection.prepareStatement(SQL);</span><br><span class="line">             <span class="type">PreparedStatement</span> <span class="variable">statement2</span> <span class="operator">=</span> connection.prepareStatement(SQL);) &#123;</span><br><span class="line">            <span class="comment">// 2. 执行语句    </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般一个应用程序共享一个<code>Connection</code>, 每个线程创建自己的<code>Channel</code>.<br>所有的操作, 包括<code>Exchange</code>、<code>Queue</code>的创建绑定, 消息的生产消费, 都是在<code>Channel</code>上执行的.</p><img data-src="/images/RabbitMQ%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8_01.png" class=""><h1 id="Virtual-Host、Exchange、Binding、Queue"><a href="#Virtual-Host、Exchange、Binding、Queue" class="headerlink" title="Virtual Host、Exchange、Binding、Queue"></a>Virtual Host、Exchange、Binding、Queue</h1><img data-src="/images/RabbitMQ%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8_02.png" class=""><p><code>Virtual Host</code>用来区分<code>dev</code>环境和<code>test</code>环境, 避免两个环境的数据混淆在一起.</p><p>从图中可以看到, 生产者只管投递到<code>Exchange</code>上, 消费者也只管从<code>Queue</code>消费消息, 其中它们是怎么路由的, 生产者和消费者不需要关心.<br>而<code>Exchange</code>和<code>Queue</code>之间的路由规则, 就是根据<code>Message</code>消息提供的<code>RoutingKey</code>, 以及<code>Exchange</code>和<code>Queue</code>之间的<code>BindingKey</code>, 两者匹配上, 路由成功就投递到<code>Queue</code>队列上.</p><h1 id="Demo-例子"><a href="#Demo-例子" class="headerlink" title="Demo 例子"></a>Demo 例子</h1><p>概念讲完, 这里提供简单的一个<a href="https://github.com/Ahaochan/project/blob/master/ahao-spring-boot-rabbitmq/src/test/java/com/ahao/spring/boot/rabbitmq/NativeTest.java">单元测试</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ahao-exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;ahao-routing-key&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ahao-queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 建立连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="built_in">this</span>.initFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取连接, 获取 Channel</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">             <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 创建 Exchange 和 Queue 并绑定</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">            channel.queueDeclare(QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ROUTING_KEY, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 发送消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;现在时间&quot;</span>+ LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>));</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 建立连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="built_in">this</span>.initFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取连接, 获取 Channel</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">             <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 创建 Exchange 和 Queue 并绑定</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">            channel.queueDeclare(QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ROUTING_KEY, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 消费消息</span></span><br><span class="line">            <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">            channel.basicQos(<span class="number">64</span>);</span><br><span class="line">            channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接受到:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 等待消息消费后, 再关闭资源</span></span><br><span class="line">            latch.await(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ConnectionFactory <span class="title function_">initFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;MQ地址&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://blog.ahao.moe/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</category>
      
      
      <category domain="https://blog.ahao.moe/tags/RabbitMQ/">RabbitMQ</category>
      
      
      <comments>https://blog.ahao.moe/posts/Getting_started_with_RabbitMQ.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>使用rsync同步两台服务器的文件</title>
      <link>https://blog.ahao.moe/posts/use_rsync_to_sync_file_between_two_unix_system.html</link>
      <guid>https://blog.ahao.moe/posts/use_rsync_to_sync_file_between_two_unix_system.html</guid>
      <pubDate>Sun, 24 May 2020 09:07:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;rsync&lt;/code&gt;是&lt;code&gt;unix&lt;/code&gt;文件同步和传送工具。使用方法也很简单, 和&lt;code&gt;cp&lt;/code&gt;类似。&lt;br&gt;首先安装&lt;code&gt;rsync&lt;/code&gt;程序。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;apt install -y rsync&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>rsync</code>是<code>unix</code>文件同步和传送工具。使用方法也很简单, 和<code>cp</code>类似。<br>首先安装<code>rsync</code>程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install -y rsync</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h1><p>先做一个简单的例子测试下, 稍后再解释参数用法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 初始化必要的文件</span></span><br><span class="line"><span class="built_in">mkdir</span> /opt/dir1 /opt/dir2 -p</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /opt/dir1/file1</span><br><span class="line"><span class="comment"># 2. 现在 dir1 有 file1 文件, dir2 没有</span></span><br><span class="line">ll /opt/dir1/ /opt/dir2/</span><br><span class="line"><span class="comment"># dir1/:</span></span><br><span class="line"><span class="comment"># -rw-r--r--. 1 root root 2 9月  18 10:12 file1</span></span><br><span class="line"><span class="comment"># dir2/:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 同步两个文件夹, 这里只会同步一次, 不会持续同步</span></span><br><span class="line">rsync -avzP /opt/dir1/ /opt/dir2/</span><br><span class="line"><span class="comment"># sending incremental file list</span></span><br><span class="line"><span class="comment"># ./</span></span><br><span class="line"><span class="comment"># file1</span></span><br><span class="line"><span class="comment">#               2 100%    0.00kB/s    0:00:00 (xfr#1, to-chk=0/2)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># sent 107 bytes  received 38 bytes  290.00 bytes/sec</span></span><br><span class="line"><span class="comment"># total size is 2  speedup is 0.01</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 现在 dir1/file1 已经同步到 dir2 中了</span></span><br><span class="line">ll /opt/dir1/ /opt/dir2/</span><br><span class="line"><span class="comment"># dir1/:</span></span><br><span class="line"><span class="comment"># -rw-r--r--. 1 root root 2 9月  18 10:12 file1</span></span><br><span class="line"><span class="comment"># dir2/:</span></span><br><span class="line"><span class="comment"># -rw-r--r--. 1 root root 2 9月  18 10:12 file1</span></span><br></pre></td></tr></table></figure><h1 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h1><table><thead><tr><th align="center">选项缩写</th><th align="center">选项全称</th><th align="center">选项说明</th></tr></thead><tbody><tr><td align="center"><code>-a</code></td><td align="center"><code>--archive</code></td><td align="center">完全的复制, 等于<code>-rlptgoD</code>。</td></tr><tr><td align="center"><code>-v</code></td><td align="center"><code>--verbose</code></td><td align="center">输出详细日志</td></tr><tr><td align="center"><code>-q</code></td><td align="center"><code>--quiet</code></td><td align="center">输出简单日志</td></tr><tr><td align="center"><code>-r</code></td><td align="center"><code>--recursive</code></td><td align="center">递归处理所有子目录</td></tr><tr><td align="center"><code>-z</code></td><td align="center"><code>--compress</code></td><td align="center">对备份的文件在传输时进行压缩处理</td></tr><tr><td align="center"><code>-P</code></td><td align="center"><code>--partial</code></td><td align="center">保留那些因故没有完全传输的文件, 用于加快随后的再次传输</td></tr></tbody></table><p>更多选项查看: <a href="https://man.linuxde.net/rsync"><code>rsync命令</code></a></p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p><code>rsync</code>有三个配置文件</p><ol><li><code>rsyncd.conf</code>是<code>rsync</code>服务器主要配置文件.</li><li><code>rsyncd.secrets</code>是登录<code>rsync</code>服务器的密码文件.</li><li><code>rsyncd.motd</code>是定义<code>rysnc</code>服务器信息的, 也就是用户登录信息. 非必须.</li></ol><h2 id="rsyncd-conf"><a href="#rsyncd-conf" class="headerlink" title="rsyncd.conf"></a>rsyncd.conf</h2><p>配置文件<a href="https://download.samba.org/pub/rsync/rsyncd.conf.html">官方<code>example</code></a><br>如果<code>/etc/rsync.conf</code>不存在, 就手动创建。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局通用配置</span></span><br><span class="line"><span class="comment">## 指定该模块以指定的 UID 传输文件。</span></span><br><span class="line"><span class="attr">uid</span> = <span class="number">0</span></span><br><span class="line"><span class="comment">## 指定该模块以指定的 GID 传输文件。</span></span><br><span class="line"><span class="attr">gid</span> = <span class="number">0</span></span><br><span class="line"><span class="comment">## 不使用 chroot 修改根的位置</span></span><br><span class="line">use <span class="attr">chroot</span> = <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 存放 rsync 后台守护进程的 pid 的值的文件</span></span><br><span class="line">pid <span class="attr">file</span> = /var/run/rsyncd.pid</span><br><span class="line"><span class="comment">## 存放 rsync 的日志文件</span></span><br><span class="line">log <span class="attr">file</span> = /var/log/rsyncd.log</span><br><span class="line">lock <span class="attr">file</span> = /var/run/rsyncd.lock</span><br><span class="line"><span class="comment">## 存放远程服务器的用户名和密码, username:password 的形式</span></span><br><span class="line">secrets <span class="attr">file</span> = /etc/rsyncd.passwd</span><br><span class="line"></span><br><span class="line"><span class="comment">## 最大并发连接数为4</span></span><br><span class="line">max <span class="attr">connections</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 某个模块的配置</span></span><br><span class="line"><span class="section">[module_test1]</span></span><br><span class="line">auth <span class="attr">users</span> = root</span><br><span class="line"><span class="attr">path</span> = /opt/dir1</span><br><span class="line"><span class="attr">comment</span> = rsync test1 logs</span><br><span class="line">read <span class="attr">only</span> = <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="section">[module_test2]</span></span><br><span class="line">auth <span class="attr">users</span> = root</span><br><span class="line"><span class="attr">path</span> = /opt/dir1</span><br><span class="line"><span class="attr">comment</span> = rsync test2 logs</span><br><span class="line">read <span class="attr">only</span> = <span class="literal">no</span></span><br></pre></td></tr></table></figure><h2 id="rsyncd-secrets"><a href="#rsyncd-secrets" class="headerlink" title="rsyncd.secrets"></a>rsyncd.secrets</h2><p>将远程服务器用户名密码存入<code>/etc/rsyncd.passwd</code>文件, 重启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 存放用户名密码</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;root:root&quot;</span> &gt; /etc/rsyncd.passwd</span><br><span class="line"><span class="built_in">chown</span> root.root /etc/rsyncd.passwd</span><br><span class="line"><span class="built_in">chmod</span> 600 /etc/rsyncd.passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 以daemon方式重启服务</span></span><br><span class="line">service rsync stop</span><br><span class="line">rsync --daemon --config=/etc/rsync.conf</span><br></pre></td></tr></table></figure><h1 id="自动同步"><a href="#自动同步" class="headerlink" title="自动同步"></a>自动同步</h1><p>自动同步有两种方案</p><ol><li>使用<code>crontab</code>定时调用</li><li>使用<code>inotifytools</code>监控文件变化, 请参照另一篇文章<strong>使用<code>inotifytools</code>监控文件</strong></li></ol><p>这里提供一个简单的<code>shell</code>脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 1. 声明一个同步函数, rs(remoteIp, path)</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">rs</span></span>() &#123;</span><br><span class="line">    rsync -azP --delete <span class="variable">$3</span> rsync://<span class="variable">$1</span>/<span class="variable">$2</span>  --password-file=/etc/rsyncd.passwd</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 2. 声明项目路径, 后面要加 / , 否则会连目录也一起传输过去</span></span><br><span class="line">path=/opt/dir1/</span><br><span class="line">module=module_test2</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;开始同步到远程机器&quot;</span></span><br><span class="line"><span class="comment"># 3. 开始传输</span></span><br><span class="line"><span class="comment">## B机器ip,格式：用户名@ip</span></span><br><span class="line">rs root@192.168.154.128 <span class="variable">$&#123;module&#125;</span> <span class="variable">$&#123;path&#125;</span></span><br><span class="line"><span class="comment">## C机器ip,格式：用户名@ip</span></span><br><span class="line">rs root@192.168.154.129 <span class="variable">$&#123;module&#125;</span> <span class="variable">$&#123;path&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;结束同步&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## TODO 这个同步到远程的操作一直失败, 应该是哪里配错了, 等以后有机会再来改改吧</span></span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://rsync.samba.org/examples.html">官方文档</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.ahao.moe/categories/Linux/">Linux</category>
      
      
      <category domain="https://blog.ahao.moe/tags/Linux/">Linux</category>
      
      
      <comments>https://blog.ahao.moe/posts/use_rsync_to_sync_file_between_two_unix_system.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ThreadLocal源码分析以及线程池下的使用问题</title>
      <link>https://blog.ahao.moe/posts/ThreadLocal_source_code.html</link>
      <guid>https://blog.ahao.moe/posts/ThreadLocal_source_code.html</guid>
      <pubDate>Sun, 03 May 2020 12:15:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;如果我想要在多线程下, 同一个变量在不同线程下使用不同的值, 如何去做?&lt;br&gt;我可以声明一个&lt;code&gt;Map&lt;/code&gt;, 线程作为&lt;code&gt;Key&lt;/code&gt;(实际上并不是这样设计的), &lt;code&gt;Map&lt;/code&gt;作为&lt;code&gt;value&lt;/code&gt;, 存储当前线程下的键值对.&lt;br&gt;下面是一个简单的例子(生产不要这样用)&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果我想要在多线程下, 同一个变量在不同线程下使用不同的值, 如何去做?<br>我可以声明一个<code>Map</code>, 线程作为<code>Key</code>(实际上并不是这样设计的), <code>Map</code>作为<code>value</code>, 存储当前线程下的键值对.<br>下面是一个简单的例子(生产不要这样用)</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Thread, Map&lt;String, Object&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        map.get(Thread.currentThread()).put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(Thread.currentThread()).get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很简单? 但是我们不需要去重复造轮子.<br><code>JDK</code>早就给我们实现了一套轮子, 本质和我写的这个<code>Demo</code>是一样的.</p><h1 id="ThreadLocal-实现线程隔离"><a href="#ThreadLocal-实现线程隔离" class="headerlink" title="ThreadLocal 实现线程隔离"></a>ThreadLocal 实现线程隔离</h1><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>我们来看个简单的<a href="https://github.com/Ahaochan/project/blob/master/ahao-spring-boot-async/src/test/java/com/ahao/spring/boot/async/ThreadLocalTest.java">单元测试例子</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadLocal1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ThreadLocal&lt;String&gt; context = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Assertions.assertNull(context.get());</span><br><span class="line">        <span class="type">String</span> <span class="variable">expectP</span> <span class="operator">=</span> <span class="string">&quot;hello &quot;</span> + DateHelper.getNow(DateHelper.yyyyMMdd_hhmmssSSS);</span><br><span class="line">        context.set(expectP);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            Assertions.assertNull(context.get());</span><br><span class="line">            <span class="type">String</span> <span class="variable">expect</span> <span class="operator">=</span> <span class="string">&quot;hello &quot;</span> + DateHelper.getNow(DateHelper.yyyyMMdd_hhmmssSSS);</span><br><span class="line">            context.set(expect);</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> context.get();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get &quot;</span> + value);</span><br><span class="line">            Assertions.assertEquals(expect, value);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> context.get();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get &quot;</span> + value);</span><br><span class="line">        Assertions.assertEquals(expectP, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完毕输出</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread-1 get hello 2020-04-19 00:54:44:249</span><br><span class="line">Thread-2 get hello 2020-04-19 00:54:44:254</span><br><span class="line">main get hello 2020-04-19 00:54:44:230</span><br></pre></td></tr></table></figure><p>可以看到, 明明是同一个变量, 在不同线程下, 获取到的值却不一样.</p><h2 id="get-和-set-源码分析"><a href="#get-和-set-源码分析" class="headerlink" title="get 和 set 源码分析"></a>get 和 set 源码分析</h2><p>关键点就在于<code>set</code>和<code>get</code>方法. 我们现在先来看<code>set</code>方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang.ThreadLocal</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取当前线程内的 ThreadLocalMap</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="comment">// 2. 往 Map 塞值, 以 ThreadLocal为key</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span> createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到和我一开始写的一样, 就是往一个<code>Map</code>里塞数据.<br>再看看<code>get</code>方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang.ThreadLocal</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取当前线程内的 ThreadLocalMap</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="comment">// 2. 根据 key 获取 value</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (T) e.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 找不到就返回一个默认值, 默认为 null</span></span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也一样, 就是从一个<code>Map</code>里, 把<code>ThreadLocal</code>作为<code>key</code>, 获取数据.</p><p>那么不同点来了, 就是这个<code>Map</code>的构造, 可以看到不是我用的<code>HashMap</code>.<br>而是当前线程里的<code>ThreadLocalMap</code>实例变量<code>threadLocals</code>.</p><h2 id="ThreadLocalMap-源码分析"><a href="#ThreadLocalMap-源码分析" class="headerlink" title="ThreadLocalMap 源码分析"></a>ThreadLocalMap 源码分析</h2><p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类, 而每一个线程<code>Thread</code>都有各自的<code>ThreadLocalMap</code>成员变量.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang.Thread</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们继续来看<code>ThreadLocalMap</code>. 和普通的<code>HashMap</code>一样, 内部是一个节点数组.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang.ThreadLocal</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 节点数组</span></span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line">        <span class="comment">// 2. 弱引用</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            Object value;</span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="built_in">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>ThreadLocalMap</code>是以<code>ThreadLocal</code>对象的弱引用为<code>Key</code>, <code>Object</code>为<code>Value</code>的<code>Map</code>集合.<br>而<code>Entry</code>继承了弱引用<code>WeakReference</code>, 所以当每次<code>GC</code>发生时, 扫描到这个对象时, <strong>如果没有强引用持有这个对象</strong>, 就会回收<code>ThreadLocal</code>. 但这里会导致一些内存问题, 这里后面讲.</p><p>接下来是<code>ThreadLocalMap</code>的<code>set</code>和<code>get</code>方法, 和普通的<code>HashMap</code>差不多, 无非就是扩容, <code>rehash</code>那一套.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 对 key 进行 hash, 获取 Entry 节点的下标</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 如果 hash 冲突, 就 开放定址法 找到下一个下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 2.1. 清除 null key 的节点</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. 往下标位置塞数据, 扩容, rehash </span></span><br><span class="line">            tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 对 key 进行 hash, 获取 Entry 节点的下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 2. 从节点数组获取数据</span></span><br><span class="line">            <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 开放定址法获取数据</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是, <code>ThreadLocalMap</code>的哈希冲突解决方案是<strong>开放定址法</strong>, 而不是<code>HashMap</code>的链表红黑树那套.</p><h2 id="ThreadLocal-为什么必须设置为-static"><a href="#ThreadLocal-为什么必须设置为-static" class="headerlink" title="ThreadLocal 为什么必须设置为 static ?"></a>ThreadLocal 为什么必须设置为 static ?</h2><p>经常会听到一种言论, <code>ThreadLocal</code>必须设置为<code>static</code>静态变量, 否则会浪费内存的问题.</p><p>我们先来看一个<a href="https://github.com/Ahaochan/project/blob/master/ahao-spring-boot-async/src/test/java/com/ahao/spring/boot/async/ThreadLocalTest.java">单元测试例子</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; staticContext = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">staticVerify</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 静态ThreadLocal 设置值</span></span><br><span class="line">        Assertions.assertNull(staticContext.get());</span><br><span class="line">        staticContext.set(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="comment">// 2. 普通ThreadLocal 设置值</span></span><br><span class="line">            ThreadLocal&lt;String&gt; context = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"></span><br><span class="line">            staticContext.set(thread.getName());</span><br><span class="line">            context.set(thread.getName());</span><br><span class="line"></span><br><span class="line">            System.out.println(thread.getName() + <span class="string">&quot; static get &quot;</span> + staticContext.get());</span><br><span class="line">            System.out.println(thread.getName() + <span class="string">&quot; get &quot;</span> + context.get()); <span class="comment">// 打断点</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> staticContext.get();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot; static get &quot;</span> + staticContext.get());</span><br><span class="line">        Assertions.assertEquals(thread.getName(), value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们打个断点看看<code>Thread</code>里的<code>ThreadLocalMap</code>的<code>Key</code>引用很容易就发现问题.</p><img data-src="/images/ThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98_01.png" class=""><p>当线程执行的时候, 线程的<code>ThreadLocalMap</code>持有两个<code>Entry</code>, 一个是静态的<code>ThreadLocal</code>, 一个是<code>new</code>出来的<code>ThreadLocal</code>.<br>可以看到，静态的<code>ThreadLocal</code>在<code>ThreadLocalMap</code>是固定的<code>hashcode</code>, 而另一个<code>ThreadLocal</code>是不同的<code>hashcode</code>，说明每次运行都会创建<code>ThreadLocal</code>。<br>虽然并不影响正常使用，但是用<code>static</code>修饰<code>ThreadLocal</code>可以减少对象的频繁创建，降低<code>GC</code>频率, 如果没有特殊要求, 还是用<code>static</code>最佳.</p><p>另外还有一点需要注意的是, <code>ThreadLocal</code>如果设置成<code>static</code>了, 就会被当前类对象强引用, 下面的内存泄漏问题会提到.</p><h2 id="ThreadLocal的-内存泄漏-问题"><a href="#ThreadLocal的-内存泄漏-问题" class="headerlink" title="ThreadLocal的 内存泄漏 问题"></a>ThreadLocal的 内存泄漏 问题</h2><p><img data-src="https://yuml.me/diagram/nofunky;dir:LR/class/[Thread%E5%BC%95%E7%94%A8]-%3E[Thread%E5%AF%B9%E8%B1%A1],[Thread%E5%AF%B9%E8%B1%A1]-%3E[ThreadLocalMap],[ThreadLocalMap]-%3E[Entry],[Entry]-%E5%BC%B1%E5%BC%95%E7%94%A8%3E[ThreadLocal%E5%AF%B9%E8%B1%A1],[Entry]-%3E[value],[ThreadLocal%E5%BC%95%E7%94%A8]-%E5%BC%BA%E5%BC%95%E7%94%A8%3E[ThreadLocal%E5%AF%B9%E8%B1%A1]" alt="ThreadLocal引用链"></p><p><code>ThreadLocalMap</code>的<code>Key</code>是<code>ThreadLocal</code>的弱引用对象.<br>不管<code>ThreadLocal</code>对象是否因为弱引用被<code>GC</code>回收, <code>Entry</code>节点都会持有<code>value</code>的强引用.<br>要回收掉<code>value</code>只有两种方法</p><ol><li>结束当前线程</li><li>手动释放<code>Key</code>为<code>null</code>的<code>Entry</code>, 常用的是<code>remove</code>方法</li></ol><p>在<code>ThreadLocal</code>的<code>set</code>、<code>get</code>、<code>remove</code>方法内都有对<code>Key</code>为<code>null</code>的<code>Entry</code>做清除引用的操作.</p><p>那为什么<code>Entry</code>的<code>Key</code>要做弱引用, 不直接强引用呢?<br>我们反推一下, 如果<code>Entry</code>的<code>Key</code>是强引用, 当<code>ThreadLocal</code>的外部强引用取消后, <code>ThreadLocalMap</code>内部的<code>Entry</code>还持有<code>ThreadLocal</code>的强引用.<br>那么<code>ThreadLocal</code>就一直不能被<code>GC</code>回收, 需要手动<code>remove</code>才能回收.<br>反之, 如果是弱引用, 那么<code>ThreadLocal</code>的外部强引用取消后, 因为<code>Entry</code>持有的是<code>ThreadLocal</code>的弱引用, 当发生<code>GC</code>时, 能及时回收掉<code>ThreadLocal</code>.<br>在下次<code>set</code>、<code>get</code>、<code>remove</code>方法做清除<code>key</code>为<code>null</code>的<code>value</code>的操作.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Thread</code>线程有一个<code>ThreadLocalMap</code>成员变量, 这是一个存储了以<code>ThreadLocal</code>为<code>Key</code>, 值为<code>Value</code>的<code>Map</code>集合.<br><code>ThreadLocal</code>的<code>set</code>和<code>get</code>方法, 本质是获取当前线程的<code>ThreadLocalMap</code>, 对这个<code>Map</code>进行操作, 做到线程隔离.</p><p>下面是一个简单的最佳实践.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; local = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        local.set(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务操作</span></span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            local.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="InheritableThreadLocal-实现父子线程变量共享"><a href="#InheritableThreadLocal-实现父子线程变量共享" class="headerlink" title="InheritableThreadLocal 实现父子线程变量共享"></a>InheritableThreadLocal 实现父子线程变量共享</h1><p>那如果我想要创建一个线程, 然后子线程继承父线程的变量, 要怎么做呢?<br>你可以看到在上面的单元测试用例中, 我使用了一个断言<code>Assertions.assertNull(context.get());</code>.</p><p>也就是说, 如果单单使用<code>ThreadLocal</code>, 子线程是不能获取到父线程的变量的.<br>其实这也很好理解, 线程都不一样, 线程对象里面的<code>Map</code>变量当然也不一样.</p><p>如果让我们来实现, 也很容易. 只要在创建线程的时候, 将父线程的<code>ThreadLocalMap</code>复制一份到子线程即可.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title function_">createThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">parentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">childThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制 ThreadLocalMap</span></span><br><span class="line">        childThread.threadLocals = parentThread.threadLocals.clone();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> childThread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JDK</code>内部已经实现了, 我们只要直接使用<code>InheritableThreadLocal</code>即可.</p><h2 id="InheritableThreadLocal-源码分析"><a href="#InheritableThreadLocal-源码分析" class="headerlink" title="InheritableThreadLocal 源码分析"></a>InheritableThreadLocal 源码分析</h2><p><code>InheritableThreadLocal</code>继承了<code>ThreadLocal</code>, 并重写了<code>ThreadLocalMap</code>的相关方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang.InheritableThreadLocal</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritableThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> T <span class="title function_">childValue</span><span class="params">(T parentValue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// java.lang.ThreadLocal</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到, <code>InheritableThreadLocal</code>就是换了个变量操作, 它操作的是<code>inheritableThreadLocals</code>变量. 避免和<code>ThreadLocal</code>操作的变量冲突.<br>代码就短短几行, 没有涉及到我们说的**复制<code>ThreadLocalMap</code>**的操作.<br>那我们继续看下<code>Thread</code>的创建过程.</p><h2 id="Thread-创建"><a href="#Thread-创建" class="headerlink" title="Thread 创建"></a>Thread 创建</h2><p>我们直接追源码, 这里省略部分非核心代码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang.Thread</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">()</span> &#123;</span><br><span class="line">        init(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name, <span class="type">long</span> stackSize)</span> &#123;</span><br><span class="line">        init(g, target, name, stackSize, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name, <span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params">                      <span class="type">boolean</span> inheritThreadLocals)</span> &#123; <span class="comment">// 注意这个 inheritThreadLocals 变量, 默认为 true</span></span><br><span class="line">        <span class="comment">// 1. 获取创建Thread变量的线程, 作为父线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">parent</span> <span class="operator">=</span> currentThread();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 如果父线程有 inheritableThreadLocals 的值, 那么就复制一份到子线程</span></span><br><span class="line">        <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.inheritableThreadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(parent.inheritableThreadLocals);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一目了然, 就是在<code>new Thread()</code>的时候, 从父线程中复制一份<code>ThreadLocalMap</code>到子线程.</p><h1 id="TransmittableThreadLocal-线程池子任务共享父线程的变量"><a href="#TransmittableThreadLocal-线程池子任务共享父线程的变量" class="headerlink" title="TransmittableThreadLocal 线程池子任务共享父线程的变量"></a>TransmittableThreadLocal 线程池子任务共享父线程的变量</h1><p><code>InheritableThreadLocal</code>解决了父子线程变量共享的问题, 但生产环境下, 我们一般都是用线程池来管理线程的.<br>这里就涉及到一个线程复用的问题.<br><code>InheritableThreadLocal</code>只有在创建线程的时候才会将父线程的变量复制给子线程, 但是线程池的线程是复用的.<br><code>new Thread()</code>之后, 可能会执行多个不同的任务. 这个时候就不能继承父线程的变量了.</p><p>还是老套路, 既然线程是复用的, 那我能不能在创建任务的时候, 存一份父线程数据, 在<code>run()</code>执行之前丢到子线程里去呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableWrapper</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个 ThreadLocal, 用于暂存创建Runnable时父线程的数据, 在外部直接使用 RunnableWrapper.holder.set();</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; holder = ThreadLocal.withInitial(HashMap::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; value;</span><br><span class="line">    <span class="keyword">private</span> Runnable runnable;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RunnableWrapper</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.runnable = runnable;</span><br><span class="line">        <span class="comment">// 2. 创建任务的时候, 暂存父线程的数据</span></span><br><span class="line">        <span class="built_in">this</span>.value = holder.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 在子线程执行任务前, 将父线程的数据存入子线程</span></span><br><span class="line">        holder.set(value);</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>JDK</code>可没有提供轮子了, 但是<code>Alibaba</code>提供了一个<a href="https://github.com/alibaba/transmittable-thread-local"><code>transmittable-thread-local</code></a>的轮子.</p><h2 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h2><p>我们来看个<a href="https://github.com/Ahaochan/project/blob/master/ahao-spring-boot-async/src/test/java/com/ahao/spring/boot/async/TtlTest.java">单元测试例子</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wrapper</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 创建 线程池 和 TransmittableThreadLocal</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        TransmittableThreadLocal&lt;String&gt; context = <span class="keyword">new</span> <span class="title class_">TransmittableThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">expect</span> <span class="operator">=</span> <span class="string">&quot;hello &quot;</span> + DateHelper.getNow(DateHelper.yyyyMMdd_hhmmssSSS);</span><br><span class="line">        context.set(expect);</span><br><span class="line">        System.out.println(<span class="string">&quot;[parent thread] set &quot;</span> + context.get());</span><br><span class="line">        Assertions.assertEquals(expect, context.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 装饰 Runnable</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[child thread] get &quot;</span> + context.get() + <span class="string">&quot; in Runnable&quot;</span>);</span><br><span class="line">            Assertions.assertEquals(expect, context.get());</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">TtlRunnable</span> <span class="variable">ttlRunnable</span> <span class="operator">=</span> TtlRunnable.get(task);</span><br><span class="line">        executorService.submit(ttlRunnable).get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 关闭线程池</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完毕输出</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[parent thread] set hello 2020-04-19 00:54:44:230</span><br><span class="line">[child thread] get hello 2020-04-19 00:54:44:230 in Runnable</span><br></pre></td></tr></table></figure><p>可以看到, 尽管是在线程池里复用线程的情况, 依然能获取到父线程的变量.<br>如果觉得我只用一个<code>Runnable</code>样本不够, 可以自己多创建几百个<code>Runnable</code>.</p><p>陌生的类只有两个, <code>TtlRunnable</code>和<code>TransmittableThreadLocal</code>.</p><h2 id="TransmittableThreadLocal-的-set-get-源码分析"><a href="#TransmittableThreadLocal-的-set-get-源码分析" class="headerlink" title="TransmittableThreadLocal 的 set get 源码分析"></a>TransmittableThreadLocal 的 set get 源码分析</h2><p>我们先来看看<code>set</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.ttl.TransmittableThreadLocal</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransmittableThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">InheritableThreadLocal</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">TtlCopier</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!disableIgnoreNullValueSemantics &amp;&amp; <span class="literal">null</span> == value) &#123;</span><br><span class="line">            <span class="comment">// may set null to remove value</span></span><br><span class="line">            remove();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 调用 InheritableThreadLocal 的 set 方法, 保证子线程也能拿到数据</span></span><br><span class="line">            <span class="built_in">super</span>.set(value);</span><br><span class="line">            <span class="comment">// 2. 添加到 holder, 保证子任务能拿到数据</span></span><br><span class="line">            addThisToHolder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addThisToHolder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断 holder 没有当前 ThreadLocal 则 put 一份</span></span><br><span class="line">        <span class="keyword">if</span> (!holder.get().containsKey(<span class="built_in">this</span>)) &#123;</span><br><span class="line">            holder.get().put((TransmittableThreadLocal&lt;Object&gt;) <span class="built_in">this</span>, <span class="literal">null</span>); <span class="comment">// WeakHashMap supports null value.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等价于 Map&lt;线程, Map&lt;ThreadLocal, null&gt;&gt;, 因为没有弱引用的Set, 所以用 WeakHashMap 代替</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InheritableThreadLocal&lt;WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt;&gt; holder =</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt; initialValue() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt; childValue(WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt; parentValue) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;(parentValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>holder</code>存储了当前线程下的所有<code>TransmittableThreadLocal</code>对象, 并用<code>Set</code>去重.<br>有人看到这里可能有疑问, 上面没看到<code>Set</code>关键字. 是因为<code>JDK</code>没有弱引用的<code>Set</code>, 所以用<code>WeakHashMap</code>代替.</p><p>再来看看<code>get</code>方法, 也只是多了个<code>addThisToHolder</code>方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.ttl.TransmittableThreadLocal</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransmittableThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">InheritableThreadLocal</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">TtlCopier</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">super</span>.get();</span><br><span class="line">        <span class="keyword">if</span> (disableIgnoreNullValueSemantics || <span class="literal">null</span> != value) addThisToHolder();</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TtlRunnable-源码分析-保存快照"><a href="#TtlRunnable-源码分析-保存快照" class="headerlink" title="TtlRunnable 源码分析 保存快照"></a>TtlRunnable 源码分析 保存快照</h2><p>既然上面设置了参数, 下面就要获取这些参数了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.ttl.TtlRunnable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TtlRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>, TtlWrapper&lt;Runnable&gt;, TtlEnhanced, TtlAttachments &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Object&gt; capturedRef;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable runnable;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> releaseTtlValueReferenceAfterRun;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">TtlRunnable</span><span class="params">(<span class="meta">@NonNull</span> Runnable runnable, <span class="type">boolean</span> releaseTtlValueReferenceAfterRun)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 保存快照</span></span><br><span class="line">        <span class="built_in">this</span>.capturedRef = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;Object&gt;(TransmittableThreadLocal.Transmitter.capture());</span><br><span class="line">        <span class="built_in">this</span>.runnable = runnable;</span><br><span class="line">        <span class="built_in">this</span>.releaseTtlValueReferenceAfterRun = releaseTtlValueReferenceAfterRun;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 获取快照</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">captured</span> <span class="operator">=</span> capturedRef.get();</span><br><span class="line">        <span class="keyword">if</span> (captured == <span class="literal">null</span> || releaseTtlValueReferenceAfterRun &amp;&amp; !capturedRef.compareAndSet(captured, <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;TTL value reference is released after run!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 保存到当前线程</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">backup</span> <span class="operator">=</span> TransmittableThreadLocal.Transmitter.replay(captured);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            TransmittableThreadLocal.Transmitter.restore(backup);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺着开头提到的思路, 在<code>Runnable</code>创建时, 先对父线程的变量做一个快照, 在<code>run</code>执行时, 复制到新线程里.</p><p>那么第一步, 做快照, 关键就是这个<code>TransmittableThreadLocal.Transmitter.capture()</code>方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransmittableThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">InheritableThreadLocal</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">TtlCopier</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Transmitter</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">capture</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 1. captureTtlValues() 对当前线程下的所有 TransmittableThreadLocal 做一个快照</span></span><br><span class="line">            <span class="comment">// 2. TODO captureThreadLocalValues() 这个操作的是另一个变量, 目前这个场景没用到 </span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Snapshot</span>(captureTtlValues(), captureThreadLocalValues());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; <span class="title function_">captureTtlValues</span><span class="params">()</span> &#123;</span><br><span class="line">            WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; ttl2Value = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line">            <span class="keyword">for</span> (TransmittableThreadLocal&lt;Object&gt; threadLocal : holder.get().keySet()) &#123;</span><br><span class="line">                ttl2Value.put(threadLocal, threadLocal.copyValue()); <span class="comment">// 对当前线程下的所有 TransmittableThreadLocal 做一个快照</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ttl2Value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Snapshot</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; ttl2Value;</span><br><span class="line">            <span class="keyword">final</span> WeakHashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; threadLocal2Value;</span><br><span class="line">            <span class="keyword">private</span> <span class="title function_">Snapshot</span><span class="params">(WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; ttl2Value, WeakHashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; threadLocal2Value)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.ttl2Value = ttl2Value;</span><br><span class="line">                <span class="built_in">this</span>.threadLocal2Value = threadLocal2Value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步, 执行<code>run</code>方法的时候, 取出快照, 并保存到当前线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransmittableThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">InheritableThreadLocal</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">TtlCopier</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Transmitter</span> &#123;</span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">replay</span><span class="params">(<span class="meta">@NonNull</span> Object captured)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Snapshot</span> <span class="variable">capturedSnapshot</span> <span class="operator">=</span> (Snapshot) captured;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Snapshot</span>(replayTtlValues(capturedSnapshot.ttl2Value), replayThreadLocalValues(capturedSnapshot.threadLocal2Value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; <span class="title function_">replayTtlValues</span><span class="params">(<span class="meta">@NonNull</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; captured)</span> &#123;</span><br><span class="line">            WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; backup = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line">            <span class="comment">// 省略部分代码</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 精华! 从快照中获取 ThreadLocal 再重新 set 到当前线程</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; entry : captured.entrySet()) &#123;</span><br><span class="line">                TransmittableThreadLocal&lt;Object&gt; threadLocal = entry.getKey();</span><br><span class="line">                threadLocal.set(entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 省略部分代码</span></span><br><span class="line">            <span class="keyword">return</span> backup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老实说, 看到这里的代码, 不由让我惊叹. 这个<code>for</code>循环, 太神了.<br>如此一来, 就将之前保存的<code>ThreadLocal</code>快照, 在执行这个<code>Runnable</code>的线程重新复制了一遍.</p><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p><code>ThreadLocal</code>算是高频面试考点, 并且一个用的不小心就会造成线上生产问题. 使用的时候只要注意套模版就可以了.</p><ol><li><code>static</code>修饰<code>ThreadLocal</code></li><li><code>set</code>之后要用<code>try &#123;&#125; finally &#123;&#125;</code>做<code>remove</code>操作</li><li>线程池要用<code>TransmittableThreadLocal</code>来传递变量.</li></ol><p>另外, <code>Netty</code>还有一个<code>FastThreadLocal</code>的东西, 不过没有涉及本篇的线程变量传递的主题, 所以就不讲了.</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://github.com/alibaba/transmittable-thread-local/issues/123">小伙伴同学们写的 TTL使用场景 与 设计实现解析的文章（写得都很好！ ）❤️</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.ahao.moe/categories/Java-SE/">Java SE</category>
      
      
      <category domain="https://blog.ahao.moe/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</category>
      
      
      <comments>https://blog.ahao.moe/posts/ThreadLocal_source_code.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>分布式系统中的CAP理论</title>
      <link>https://blog.ahao.moe/posts/cap_theorem.html</link>
      <guid>https://blog.ahao.moe/posts/cap_theorem.html</guid>
      <pubDate>Tue, 07 Apr 2020 09:42:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;2020-02-06: 初版&lt;/li&gt;
&lt;li&gt;2020-04-07: 阅读&lt;a href=&quot;http://gk.link/a/10hoK&quot;&gt;从0开始学架构-想成为架构师，你必须知道CAP理论&lt;/a&gt;后觉得还有不足之处, 于是再次修改.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个分布式系统, 我们要关注的是它的可用性、一致性、分区容错性&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;C&lt;/strong&gt;onsistency 一致性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A&lt;/strong&gt;vailability 可用性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P&lt;/strong&gt;artition tolerance 分区容错性&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>2020-02-06: 初版</li><li>2020-04-07: 阅读<a href="http://gk.link/a/10hoK">从0开始学架构-想成为架构师，你必须知道CAP理论</a>后觉得还有不足之处, 于是再次修改.</li></ul><p>一个分布式系统, 我们要关注的是它的可用性、一致性、分区容错性</p><ol><li><strong>C</strong>onsistency 一致性</li><li><strong>A</strong>vailability 可用性</li><li><strong>P</strong>artition tolerance 分区容错性</li></ol><span id="more"></span><h1 id="什么样的系统适合CAP理论"><a href="#什么样的系统适合CAP理论" class="headerlink" title="什么样的系统适合CAP理论"></a>什么样的系统适合CAP理论</h1><p>在了解什么是<code>CAP</code>之前, 我们先来看看什么样的系统适合CAP理论.</p><p>从<strong>参考资料</strong>里的所有英文文章得知</p><ol><li><a href="https://www.teamsilverback.com/understanding-the-cap-theorem/"><code>Silverback</code></a>提到<code>A distributed system (generally running in a datacenter)</code>.</li><li><a href="https://en.wikipedia.org/wiki/CAP_theorem#cite_note-Brewer2012-6"><code>Wikipedia</code></a>提到<code>A distributed data store</code>.</li><li><a href="https://cloud.ibm.com/docs/services/Cloudant/guides?topic=cloudant-cap-theorem&locale=en#cap-"><code>IBM</code></a>只提到了<code>a distributed computer system</code>.</li><li><a href="https://robertgreiner.com/cap-theorem-revisited/"><code>Robert Greiner</code></a>一开始提到<a href="https://robertgreiner.com/cap-theorem-explained/"><code>any distributed system</code></a>, 两个月后重新定义为<a href="https://robertgreiner.com/cap-theorem-revisited/"><code>In a distributed system (a collection of interconnected nodes that share data.)</code></a></li></ol><p>大家都认为, 分布式系统才适合<code>CAP</code>理论, 但是, 不是所有分布式系统都适合.<br><a href="https://robertgreiner.com/cap-theorem-revisited/"><code>Robert Greiner</code></a>强调了这个分布式系统是<code>interconnected</code>互联和<code>share data</code>共享数据的.</p><p>举一个反例, 比如<code>Memcache</code>集群.<br><img data-src="https://yuml.me/diagram/nofunky/class/[%E5%AE%A2%E6%88%B7%E7%AB%AF]-1%E5%88%B0100%3E[Memcache_Server_1],[%E5%AE%A2%E6%88%B7%E7%AB%AF]-101%E5%88%B0200%3E[Memcache_Server_2]" alt="Memcache集群"><br><code>Memcache</code>的各个节点之间是不互联和共享数据的, 客户端根据路由规则, 自行决定存储数据到哪个节点上.<br>这确实是一个分布式系统, 但是却不适用于<code>CAP</code>理论.</p><p>举一个正例, 比如<code>MySQL</code>集群.<br><code>MySQL</code>我们熟, 主从复制, 就是<code>interconnected</code>和<code>share data</code>.</p><blockquote><p>In a distributed system (a collection of interconnected nodes that share data.)</p></blockquote><p>所以这里还是以<a href="https://robertgreiner.com/cap-theorem-revisited/"><code>Robert Greiner</code></a>的文章为准, 一个互联且共享数据的节点集合, 才是适用<code>CAP</code>的分布式系统. </p><h1 id="什么是CAP"><a href="#什么是CAP" class="headerlink" title="什么是CAP"></a>什么是CAP</h1><p>我们假设一个分布式系统有<code>4</code>个终端, 数据库<code>DB1</code>和<code>DB2</code>以及应用端<code>App1</code>和<code>App2</code>.<br><img data-src="https://yuml.me/diagram/nofunky/class/[DB1]-%3E[App1],[DB2]-%3E[App1],[DB1]-%3E[App2],[DB2]-%3E[App2]" alt="分布式系统"><br>假设有数据<code>a=1</code></p><h2 id="C-一致性"><a href="#C-一致性" class="headerlink" title="C 一致性"></a>C 一致性</h2><p>从<strong>参考资料</strong>里的所有英文文章得知</p><ol><li><a href="https://www.teamsilverback.com/understanding-the-cap-theorem/"><code>Silverback</code></a>提到<code>all nodes have access to the same data simultaneously</code>.</li><li><a href="https://en.wikipedia.org/wiki/CAP_theorem#cite_note-Brewer2012-6"><code>Wikipedia</code></a>提到<code>Every read receives the most recent write or an error</code>.</li><li><a href="https://cloud.ibm.com/docs/services/Cloudant/guides?topic=cloudant-cap-theorem&locale=en#cap-"><code>IBM</code></a>提到<code>where all nodes see the same data at the same time</code>.</li><li><a href="https://robertgreiner.com/cap-theorem-revisited/"><code>Robert Greiner</code></a>一开始提到<a href="https://robertgreiner.com/cap-theorem-explained/"><code>All nodes see the same data at the same time.</code></a>, 两个月后重新定义为<a href="https://robertgreiner.com/cap-theorem-revisited/"><code>A read is guaranteed to return the most recent write for a given client.</code></a></li></ol><p>在客户端看来, 每次读都要能读到最新写入的数据.<br>举个例子, 如果<code>App1</code>往<code>DB1</code>写入数据<code>a=2</code>, 然后从<code>APP2</code>读<code>DB2</code>得到数据<code>a=2</code>, 对于客户端来说, <code>DB1</code>和<code>DB2</code>的数据保持一致.</p><p>但是实际情况下, 对于这个<strong>最新写入</strong>的理解, 是不同的.<br>同一时刻, 不同节点可能拥有不同的最新数据.<br>我举个例子, 在事务执行过程中, 不同的节点的数据并不完全一致.</p><table><thead><tr><th align="center"></th><th align="center"><code>App1</code></th><th align="center"><code>App2</code></th></tr></thead><tbody><tr><td align="center"></td><td align="center"><code>start transaction</code></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"><code>update t set a = 2</code></td><td align="center"></td></tr><tr><td align="center">t1</td><td align="center"></td><td align="center"><code>select a from t</code>(a=1)</td></tr><tr><td align="center">t2</td><td align="center"><code>select a from t</code>(a=2)</td><td align="center"></td></tr><tr><td align="center"></td><td align="center"><code>commit</code></td><td align="center"></td></tr><tr><td align="center">t3</td><td align="center"></td><td align="center"><code>select a from t</code>(a=2)</td></tr></tbody></table><p><code>t1</code>和<code>t2</code>时刻, <code>App1</code>能读到最新写入的<code>a=2</code>的数据. <code>App2</code>能读到最新写入的<code>a=1</code>的数据.<br>此时, <code>App1</code>的事务还没有提交, 对于<code>App2</code>来说, <code>App1</code>的写入的数据是感知不到的, <code>App2</code>的最新数据还是<code>a=1</code>.<br>等到<code>t3</code>时刻, <code>App1</code>提交事务后, <code>App2</code>才能读到最新的<code>a=2</code>.</p><p>如果<code>App1</code>的事务回滚了, 那么<code>App2</code>是不知道<code>a=2</code>这个事件发生过的.</p><h2 id="A-可用性"><a href="#A-可用性" class="headerlink" title="A 可用性"></a>A 可用性</h2><p>从<strong>参考资料</strong>里的所有英文文章得知</p><ol><li><a href="https://www.teamsilverback.com/understanding-the-cap-theorem/"><code>Silverback</code></a>提到<code>a promise that every request receives a response, at minimum whether the request succeeded or failed</code>.</li><li><a href="https://en.wikipedia.org/wiki/CAP_theorem#cite_note-Brewer2012-6"><code>Wikipedia</code></a>提到<code>Every request receives a (non-error) response, without the guarantee that it contains the most recent write</code>.</li><li><a href="https://cloud.ibm.com/docs/services/Cloudant/guides?topic=cloudant-cap-theorem&locale=en#cap-"><code>IBM</code></a>提到<code>which guarantees that every request receives a response about whether it succeeded or failed.</code>.</li><li><a href="https://robertgreiner.com/cap-theorem-revisited/"><code>Robert Greiner</code></a>一开始提到<a href="https://robertgreiner.com/cap-theorem-explained/"><code>Every request gets a response on success/failure.</code></a>, 两个月后重新定义为<a href="https://robertgreiner.com/cap-theorem-revisited/"><code>A non-failing node will return a reasonable response within a reasonable amount of time (no error or timeout).</code></a></li></ol><p><code>Silverback</code>、<code>IBM</code>和<code>Robert Greiner</code>都认为只要每个请求能收到响应, 无论是成功还是失败, 就算满足可用性.<br><code>Robert Greiner</code>的第二篇文章和<code>Wikipedia</code>则认为请求要返回合理的成功的响应, 无论数据对错. 也就是说, 可用性的定义更严格一点.</p><p>我个人赞同第二种观点, 成功和失败的定义太广泛. 请求超时、错误也算失败的响应, 但这算可用吗? 我认为是不可用的.<br>比如<code>App1</code>读取<code>DB1</code>的数据</p><ol><li>得到正确的数据<code>a=1</code>, <code>DB1</code>是可用的.</li><li>得到错误的数据<code>a=111</code>, <code>DB1</code>是可用的.</li><li>得到<code>connection timeout</code>, <code>DB1</code>是不可用的.</li></ol><h2 id="P-分区容错性"><a href="#P-分区容错性" class="headerlink" title="P 分区容错性"></a>P 分区容错性</h2><p>从<strong>参考资料</strong>里的所有英文文章得知</p><ol><li><a href="https://www.teamsilverback.com/understanding-the-cap-theorem/"><code>Silverback</code></a>提到<code>the system will continue to work even if some arbitrary node goes offline or can’t communicate</code>.</li><li><a href="https://en.wikipedia.org/wiki/CAP_theorem#cite_note-Brewer2012-6"><code>Wikipedia</code></a>提到<code>The system continues to operate despite an arbitrary number of messages being dropped (or delayed) by the network between nodes</code>.</li><li><a href="https://cloud.ibm.com/docs/services/Cloudant/guides?topic=cloudant-cap-theorem&locale=en#cap-"><code>IBM</code></a>提到<code>where the system continues to operate even if any one part of the system is lost or fails.</code>.</li><li><a href="https://robertgreiner.com/cap-theorem-revisited/"><code>Robert Greiner</code></a>一开始提到<a href="https://robertgreiner.com/cap-theorem-explained/"><code>System continues to work despite message loss or partial failure.</code></a>, 两个月后重新定义为<a href="https://robertgreiner.com/cap-theorem-revisited/"><code>The system will continue to function when network partitions occur.</code></a></li></ol><p>分区容错性就是当网络发生分区的时候, 集群能够继续完成工作, 返回合理的成功的响应.<br>网络分区是一种现象, 举个例子, 就是<code>DB1</code>和<code>DB2</code>之间的通信断了, 主从复制失败.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>C</code>: 对客户端来说, 读操作保证能够返回最新的写操作结果. 这就是一致性.<br><code>A</code>: 对客户端来说, 非故障的节点在合理的时间内返回合理的响应, 不是错误和超时的响应. 这就是可用性<br><code>P</code>: 对集群来说, 当出现网络分区后, 系统能够继续返回合理的响应. 这就是分区容错性</p><h1 id="那么CAP能同时做到吗"><a href="#那么CAP能同时做到吗" class="headerlink" title="那么CAP能同时做到吗?"></a>那么<code>CAP</code>能同时做到吗?</h1><p>正常情况下是可以的, 我们说的只能三选二的情况一般都是网络故障的时候, 才会进行取舍.<br>还是以这张图为例<br><img data-src="https://yuml.me/diagram/nofunky/class/[DB1]-%3E[App1],[DB2]-%3E[App1],[DB1]-%3E[App2],[DB2]-%3E[App2]" alt="分布式系统"><br>因为网络的不可靠性, **<code>P</code><strong>分区容错性是一定要保证的.<br>那么当<code>DB1</code>和<code>DB2</code>之间的网络发生故障, 此时就要对</strong><code>AC</code>**进行取舍.</p><ol><li>保障**<code>A</code>**, <code>App</code>能正常读写<code>DB1</code>和<code>DB2</code>, 但是一旦进行了写入操作, <code>DB1</code>和<code>DB2</code>是不能进行通信做主从复制的, 换句话说, 就会导致数据不一致的情况.</li><li>保障**<code>C</code>**, 那么为了保证数据一致性, <code>App</code>就应该等待<code>DB1</code>和<code>DB2</code>之间的网络恢复, 这样就不能访问数据库了, 舍弃了可用性.</li></ol><p>那有人问, 能不能只保证**<code>AC</code><strong>?<br>可以啊, 我们把两个数据库都放在一台服务器上, 这样就不会因为网络分区导致</strong><code>AC</code>**二选一的问题了, 因为根本没有网络.<br>但是这还能叫做分布式吗?</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/">An Illustrated Proof of the CAP Theorem</a></li><li><a href="https://console.bluemix.net/docs/services/Cloudant/guides/cap_theorem.html#cap-">IBM CAP 定理</a></li><li><a href="https://en.wikipedia.org/wiki/CAP_theorem#cite_note-Brewer2012-6">Wiki CAP theorem</a></li><li><a href="https://www.teamsilverback.com/understanding-the-cap-theorem/">Understanding the CAP Theorem</a></li><li><a href="https://stackoverflow.com/a/12347673">cap-theorem-availability-and-partition-tolerance</a></li><li><a href="https://robertgreiner.com/cap-theorem-revisited/">cap-theorem-revisited</a></li><li>[cap-theorem-explained][<a href="https://robertgreiner.com/cap-theorem-explained/]">https://robertgreiner.com/cap-theorem-explained/]</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.ahao.moe/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%B0%88/">编程杂谈</category>
      
      
      <category domain="https://blog.ahao.moe/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</category>
      
      
      <comments>https://blog.ahao.moe/posts/cap_theorem.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
